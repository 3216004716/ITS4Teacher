import { defineComponent as F, mergeDefaults as H, toRef as C, computed as o, createVNode as i, mergeProps as k } from "vue";
import { a as p, c as l } from "../attachments/Attachments2.mjs";
import $ from "../_util/pick-attrs.mjs";
import z from "../x-provider/hooks/use-x-provider-context.mjs";
import "../x-provider/context.mjs";
import "ant-design-vue";
import S from "../_util/hooks/use-x-component-config.mjs";
import T from "./hooks/useCollapsible.mjs";
import V from "./style/index.mjs";
import { ThoughtChainNodeContextProvider as X } from "./context.mjs";
import j from "./item.mjs";
const L = /* @__PURE__ */ F({
  name: "AXThoughtChain",
  __name: "ThoughtChain",
  props: H({
    items: null,
    collapsible: {
      type: Boolean
    },
    size: null,
    styles: null,
    classNames: null,
    prefixCls: null,
    rootClassName: null
  }, {
    styles: () => ({}),
    classNames: () => ({}),
    size: "middle"
  }),
  setup(e) {
    const f = p(e, ["prefixCls", "rootClassName", "class", "items", "collapsible", "styles", "style", "classNames", "size"]);
    C(e, "class"), C(e, "prefixCls");
    const y = o(() => $(f, {
      attr: !0,
      aria: !0,
      data: !0
    })), {
      getPrefixCls: n,
      direction: r
    } = z(), v = o(() => n()), s = o(() => n("thought-chain", e.prefixCls)), t = S("thoughtChain"), [
      d,
      N,
      h
      // collapseMotion
    ] = T(() => e.collapsible, s.value, v.value), [x, g, P] = V(s), b = o(() => l(e.class, e.rootClassName, s.value, t.value.className, g.value, P, {
      [`${s.value}-rtl`]: r.value === "rtl"
    }, `${s.value}-${e.size}`));
    return () => x(i("div", k(y.value, {
      class: b.value,
      style: {
        ...typeof t.value.style == "object" ? t.value.style : {},
        ...typeof e.style == "object" ? e.style : {}
      }
    }), [i(X, {
      value: {
        prefixCls: s.value,
        enableCollapse: d.value,
        // collapseMotion,
        expandedKeys: N.value,
        direction: r.value,
        classNames: {
          itemHeader: l(t.value.classNames.itemHeader, e.classNames.itemHeader),
          itemContent: l(t.value.classNames.itemContent, e.classNames.itemContent),
          itemFooter: l(t.value.classNames.itemFooter, e.classNames.itemFooter)
        },
        styles: {
          itemHeader: {
            ...t.value.styles.itemHeader,
            ...e.styles.itemHeader
          },
          itemContent: {
            ...t.value.styles.itemContent,
            ...e.styles.itemContent
          },
          itemFooter: {
            ...t.value.styles.itemFooter,
            ...e.styles.itemFooter
          }
        }
      }
    }, {
      default: () => {
        var u;
        return [(u = e.items) == null ? void 0 : u.map((a, m) => {
          var c;
          return i(j, {
            key: a.key || `key_${m}`,
            class: l(t.value.classNames.item, e.classNames.item),
            style: {
              ...t.value.styles.item,
              ...e.styles.item
            },
            info: {
              ...a,
              icon: a.icon || m + 1
            },
            onClick: h,
            nextStatus: ((c = e.items[m + 1]) == null ? void 0 : c.status) || a.status
          }, null);
        })];
      }
    })]));
  }
});
export {
  L as default
};
