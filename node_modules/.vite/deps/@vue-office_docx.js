import {
  EMPTY_OBJ,
  NO,
  NOOP,
  PatchFlagNames,
  camelize,
  capitalize,
  extend,
  generateCodeFrame,
  init_runtime_dom_esm_bundler,
  init_shared_esm_bundler,
  isArray,
  isBuiltInDirective,
  isHTMLTag,
  isMathMLTag,
  isObject,
  isOn,
  isReservedProp,
  isSVGTag,
  isString,
  isSymbol,
  isVoidTag,
  makeMap,
  parseStringStyle,
  runtime_dom_esm_bundler_exports,
  shared_esm_bundler_exports,
  slotFlagsText,
  toHandlerKey
} from "./chunk-U3GNLDR7.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
function createRoot(children, source = "") {
  return {
    type: 0,
    source,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: [],
    temps: 0,
    codegenNode: void 0,
    loc: locStub
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, needPauseTracking = false, inVOnce = false) {
  return {
    type: 20,
    index,
    value,
    needPauseTracking,
    inVOnce,
    needArraySpread: false,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
function isTagStartChar(c) {
  return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function isWhitespace(c) {
  return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
}
function isEndOfTagSection(c) {
  return c === 47 || c === 62 || isWhitespace(c);
}
function toCharCodes(str) {
  const ret = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
function getCompatValue(key, { compatConfig }) {
  const value = compatConfig && compatConfig[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if (enabled) {
    warnDeprecation(key, context, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc) err.loc = loc;
  context.onWarn(err);
}
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
  console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = true ? (messages || errorMessages)[code] + (additionalMessage || ``) : `https://vuejs.org/error-reference/#compiler-${code}`;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function isInNewExpression(parentStack) {
  let i = parentStack.length;
  while (i--) {
    const p = parentStack[i];
    if (p.type === "NewExpression") {
      return true;
    } else if (p.type !== "MemberExpression") {
      break;
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare) continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id) continue;
      onIdent(stmt.id);
    } else if (isForStatement(stmt)) {
      walkForStatement(stmt, true, onIdent);
    }
  }
}
function isForStatement(stmt) {
  return stmt.type === "ForOfStatement" || stmt.type === "ForInStatement" || stmt.type === "ForStatement";
}
function walkForStatement(stmt, isVar, onIdent) {
  const variable = stmt.type === "ForStatement" ? stmt.init : stmt.left;
  if (variable && variable.type === "VariableDeclaration" && (variable.kind === "var" ? isVar : false)) {
    for (const decl of variable.declarations) {
      for (const id of extractIdentifiers(decl.id)) {
        onIdent(id);
      }
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element) extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
function unwrapTSNode(node) {
  if (TS_NODE_TYPES.includes(node.type)) {
    return unwrapTSNode(node.expression);
  } else {
    return node;
  }
}
function isCoreComponent(tag) {
  switch (tag) {
    case "Teleport":
    case "teleport":
      return TELEPORT;
    case "Suspense":
    case "suspense":
      return SUSPENSE;
    case "KeepAlive":
    case "keep-alive":
      return KEEP_ALIVE;
    case "BaseTransition":
    case "base-transition":
      return BASE_TRANSITION;
  }
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(
    {
      offset: pos.offset,
      line: pos.line,
      column: pos.column
    },
    source,
    numberOfCharacters
  );
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && (isString(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly) continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p) => p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
    p.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(
      (p) => p.key.type === 4 && p.key.content === propKeyName
    );
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c) => isObject(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
    case 20:
      return false;
    default:
      if (true) ;
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
function parseForExpression(input) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch) return;
  const [, LHS, RHS] = inMatch;
  const createAliasExpression = (content, offset, asParam = false) => {
    const start = loc.start.offset + offset;
    const end = start + content.length;
    return createExp(
      content,
      false,
      getLoc(start, end),
      0,
      asParam ? 1 : 0
      /* Normal */
    );
  };
  const result = {
    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: false
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(keyContent, keyOffset, true);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          indexContent,
          exp.indexOf(
            indexContent,
            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          ),
          true
        );
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(valueContent, trimmedOffset, true);
  }
  return result;
}
function getSlice(start, end) {
  return currentInput.slice(start, end);
}
function endOpenTag(end) {
  if (tokenizer.inSFCRoot) {
    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
  }
  addNode(currentOpenTag);
  const { tag, ns } = currentOpenTag;
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre++;
  }
  if (currentOptions.isVoidTag(tag)) {
    onCloseTag(currentOpenTag, end);
  } else {
    stack.unshift(currentOpenTag);
    if (ns === 1 || ns === 2) {
      tokenizer.inXML = true;
    }
  }
  currentOpenTag = null;
}
function onText(content, start, end) {
  {
    const tag = stack[0] && stack[0].tag;
    if (tag !== "script" && tag !== "style" && content.includes("&")) {
      content = currentOptions.decodeEntities(content, false);
    }
  }
  const parent = stack[0] || currentRoot;
  const lastNode = parent.children[parent.children.length - 1];
  if (lastNode && lastNode.type === 2) {
    lastNode.content += content;
    setLocEnd(lastNode.loc, end);
  } else {
    parent.children.push({
      type: 2,
      content,
      loc: getLoc(start, end)
    });
  }
}
function onCloseTag(el, end, isImplied = false) {
  if (isImplied) {
    setLocEnd(el.loc, backTrack(end, 60));
  } else {
    setLocEnd(el.loc, lookAhead(end, 62) + 1);
  }
  if (tokenizer.inSFCRoot) {
    if (el.children.length) {
      el.innerLoc.end = extend({}, el.children[el.children.length - 1].loc.end);
    } else {
      el.innerLoc.end = extend({}, el.innerLoc.start);
    }
    el.innerLoc.source = getSlice(
      el.innerLoc.start.offset,
      el.innerLoc.end.offset
    );
  }
  const { tag, ns, children } = el;
  if (!inVPre) {
    if (tag === "slot") {
      el.tagType = 2;
    } else if (isFragmentTemplate(el)) {
      el.tagType = 3;
    } else if (isComponent(el)) {
      el.tagType = 1;
    }
  }
  if (!tokenizer.inRCDATA) {
    el.children = condenseWhitespace(children);
  }
  if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {
    const first = children[0];
    if (first && first.type === 2) {
      first.content = first.content.replace(/^\r?\n/, "");
    }
  }
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre--;
  }
  if (currentVPreBoundary === el) {
    inVPre = tokenizer.inVPre = false;
    currentVPreBoundary = null;
  }
  if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
    tokenizer.inXML = false;
  }
  {
    const props = el.props;
    if (isCompatEnabled(
      "COMPILER_V_IF_V_FOR_PRECEDENCE",
      currentOptions
    )) {
      let hasIf = false;
      let hasFor = false;
      for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 7) {
          if (p.name === "if") {
            hasIf = true;
          } else if (p.name === "for") {
            hasFor = true;
          }
        }
        if (hasIf && hasFor) {
          warnDeprecation(
            "COMPILER_V_IF_V_FOR_PRECEDENCE",
            currentOptions,
            el.loc
          );
          break;
        }
      }
    }
    if (!tokenizer.inSFCRoot && isCompatEnabled(
      "COMPILER_NATIVE_TEMPLATE",
      currentOptions
    ) && el.tag === "template" && !isFragmentTemplate(el)) {
      warnDeprecation(
        "COMPILER_NATIVE_TEMPLATE",
        currentOptions,
        el.loc
      );
      const parent = stack[0] || currentRoot;
      const index = parent.children.indexOf(el);
      parent.children.splice(index, 1, ...el.children);
    }
    const inlineTemplateProp = props.find(
      (p) => p.type === 6 && p.name === "inline-template"
    );
    if (inlineTemplateProp && checkCompatEnabled(
      "COMPILER_INLINE_TEMPLATE",
      currentOptions,
      inlineTemplateProp.loc
    ) && el.children.length) {
      inlineTemplateProp.value = {
        type: 2,
        content: getSlice(
          el.children[0].loc.start.offset,
          el.children[el.children.length - 1].loc.end.offset
        ),
        loc: inlineTemplateProp.loc
      };
    }
  }
}
function lookAhead(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1) i++;
  return i;
}
function backTrack(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i >= 0) i--;
  return i;
}
function isFragmentTemplate({ tag, props }) {
  if (tag === "template") {
    for (let i = 0; i < props.length; i++) {
      if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
        return true;
      }
    }
  }
  return false;
}
function isComponent({ tag, props }) {
  if (currentOptions.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p.loc
        )) {
          return true;
        }
      }
    } else if (
      // :is on plain element - only treat as component in compat mode
      p.name === "bind" && isStaticArgOf(p.arg, "is") && checkCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        currentOptions,
        p.loc
      )
    ) {
      return true;
    }
  }
  return false;
}
function isUpperCase(c) {
  return c > 64 && c < 91;
}
function condenseWhitespace(nodes, tag) {
  const shouldCondense = currentOptions.whitespace !== "preserve";
  let removedWhitespace = false;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === 2) {
      if (!inPre) {
        if (isAllWhitespace(node.content)) {
          const prev = nodes[i - 1] && nodes[i - 1].type;
          const next = nodes[i + 1] && nodes[i + 1].type;
          if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = condense(node.content);
        }
      } else {
        node.content = node.content.replace(windowsNewlineRE, "\n");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function isAllWhitespace(str) {
  for (let i = 0; i < str.length; i++) {
    if (!isWhitespace(str.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
function hasNewlineChar(str) {
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c === 10 || c === 13) {
      return true;
    }
  }
  return false;
}
function condense(str) {
  let ret = "";
  let prevCharIsWhitespace = false;
  for (let i = 0; i < str.length; i++) {
    if (isWhitespace(str.charCodeAt(i))) {
      if (!prevCharIsWhitespace) {
        ret += " ";
        prevCharIsWhitespace = true;
      }
    } else {
      ret += str[i];
      prevCharIsWhitespace = false;
    }
  }
  return ret;
}
function addNode(node) {
  (stack[0] || currentRoot).children.push(node);
}
function getLoc(start, end) {
  return {
    start: tokenizer.getPos(start),
    // @ts-expect-error allow late attachment
    end: end == null ? end : tokenizer.getPos(end),
    // @ts-expect-error allow late attachment
    source: end == null ? end : getSlice(start, end)
  };
}
function cloneLoc(loc) {
  return getLoc(loc.start.offset, loc.end.offset);
}
function setLocEnd(loc, end) {
  loc.end = tokenizer.getPos(end);
  loc.source = getSlice(loc.start.offset, end);
}
function dirToAttr(dir) {
  const attr = {
    type: 6,
    name: dir.rawName,
    nameLoc: getLoc(
      dir.loc.start.offset,
      dir.loc.start.offset + dir.rawName.length
    ),
    value: void 0,
    loc: dir.loc
  };
  if (dir.exp) {
    const loc = dir.exp.loc;
    if (loc.end.offset < dir.loc.end.offset) {
      loc.start.offset--;
      loc.start.column--;
      loc.end.offset++;
      loc.end.column++;
    }
    attr.value = {
      type: 2,
      content: dir.exp.content,
      loc
    };
  }
  return attr;
}
function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0) {
  const exp = createSimpleExpression(content, isStatic, loc, constType);
  return exp;
}
function emitError(code, index, message) {
  currentOptions.onError(
    createCompilerError(code, getLoc(index, index), void 0, message)
  );
}
function reset() {
  tokenizer.reset();
  currentOpenTag = null;
  currentProp = null;
  currentAttrValue = "";
  currentAttrStartIndex = -1;
  currentAttrEndIndex = -1;
  stack.length = 0;
}
function baseParse(input, options) {
  reset();
  currentInput = input;
  currentOptions = extend({}, defaultParserOptions);
  if (options) {
    let key;
    for (key in options) {
      if (options[key] != null) {
        currentOptions[key] = options[key];
      }
    }
  }
  if (true) {
    if (!currentOptions.decodeEntities) {
      throw new Error(
        `[@vue/compiler-core] decodeEntities option is required in browser builds.`
      );
    }
  }
  tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
  tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
  const delimiters = options && options.delimiters;
  if (delimiters) {
    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
    tokenizer.delimiterClose = toCharCodes(delimiters[1]);
  }
  const root = currentRoot = createRoot([], input);
  tokenizer.parse(currentInput);
  root.loc = getLoc(0, input.length);
  root.children = condenseWhitespace(root.children);
  currentRoot = null;
  return root;
}
function cacheStatic(root, context) {
  walk(
    root,
    void 0,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0])
  );
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, parent, context, doNotHoistNode = false, inFor = false) {
  const { children } = node;
  const toCache = [];
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1;
          toCache.push(child);
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = codegenNode.patchFlag;
          if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType >= 2) {
        toCache.push(child);
        continue;
      }
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, node, context, false, inFor);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, node, context, child.children.length === 1, true);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(
          child.branches[i2],
          node,
          context,
          child.branches[i2].children.length === 1,
          inFor
        );
      }
    }
  }
  let cachedAsArray = false;
  const slotCacheKeys = [];
  if (toCache.length === children.length && node.type === 1) {
    if (node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
      node.codegenNode.children = getCacheExpression(
        createArrayExpression(node.codegenNode.children)
      );
      cachedAsArray = true;
    } else if (node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !isArray(node.codegenNode.children) && node.codegenNode.children.type === 15) {
      const slot = getSlotNode(node.codegenNode, "default");
      if (slot) {
        slotCacheKeys.push(context.cached.length);
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    } else if (node.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !isArray(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {
      const slotName = findDir(node, "slot", true);
      const slot = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);
      if (slot) {
        slotCacheKeys.push(context.cached.length);
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    }
  }
  if (!cachedAsArray) {
    for (const child of toCache) {
      slotCacheKeys.push(context.cached.length);
      child.codegenNode = context.cache(child.codegenNode);
    }
  }
  if (slotCacheKeys.length && node.type === 1 && node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !isArray(node.codegenNode.children) && node.codegenNode.children.type === 15) {
    node.codegenNode.children.properties.push(
      createObjectProperty(
        `__`,
        createSimpleExpression(JSON.stringify(slotCacheKeys), false)
      )
    );
  }
  function getCacheExpression(value) {
    const exp = context.cache(value);
    if (inFor && context.hmr) {
      exp.needArraySpread = true;
    }
    return exp;
  }
  function getSlotNode(node2, name) {
    if (node2.children && !isArray(node2.children) && node2.children.type === 15) {
      const slot = node2.children.properties.find(
        (p) => p.key === name || p.key.content === name
      );
      return slot && slot.value;
    }
  }
  if (toCache.length && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") {
        return 0;
      }
      if (codegenNode.patchFlag === void 0) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    case 20:
      return 2;
    default:
      if (true) ;
      return 0;
  }
}
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = NOOP,
  isCustomElement = NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    filename,
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    cached: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      if (true) {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if (!context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: NOOP,
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp)) exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false, inVOnce = false) {
      const cacheExp = createCacheExpression(
        context.cached.length,
        exp,
        isVNode,
        inVOnce
      );
      context.cached.push(cacheExp);
      return cacheExp;
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    cacheStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  root.transformed = true;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    if (children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
    }
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag,
      void 0,
      void 0,
      true,
      void 0,
      false
    );
  } else ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child)) continue;
    context.grandParent = context.parent;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit) exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, newlineIndex = -2, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push(
      "\n" + `  `.repeat(n),
      0
      /* Start */
    );
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated) options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(
        `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
        -1
        /* End */
      );
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(
      `
`,
      0
      /* Start */
    );
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push(
        `const _Vue = ${VueBinding}
`,
        -1
        /* End */
      );
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(
          `const { ${staticHelpers} } = _Vue
`,
          -1
          /* End */
        );
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = `);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function isText(n) {
  return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || nodes.some((n) => isArray(n) || !isText(n));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString(node)) {
      push(
        node,
        -3
        /* Unknown */
      );
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString(node)) {
    context.push(
      node,
      -3
      /* Unknown */
    );
    return;
  }
  if (isSymbol(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      assert(
        node.codegenNode != null,
        `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`
      );
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if (true) {
        assert(false, `unhandled codegen node type: ${node.type}`);
        const exhaustiveCheck = node;
        return exhaustiveCheck;
      }
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), -3, node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(
    isStatic ? JSON.stringify(content) : content,
    -3,
    node
  );
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure) push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString(child)) {
      context.push(
        child,
        -3
        /* Unknown */
      );
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, -2, node);
  } else {
    push(`[${node.content}]`, -3, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(
    `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
    -3,
    node
  );
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2
  } = node;
  let patchFlagString;
  if (patchFlag) {
    if (true) {
      if (patchFlag < 0) {
        patchFlagString = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
      } else {
        const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
        patchFlagString = patchFlag + ` /* ${flagNames} */`;
      }
    } else {
      patchFlagString = String(patchFlag);
    }
  }
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, -2, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlagString, dynamicProps]),
    context
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null) break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, -2, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, -2, node);
    return;
  }
  const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, -2, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  const { needPauseTracking, needArraySpread } = node;
  if (needArraySpread) {
    push(`[...(`);
  }
  push(`_cache[${node.index}] || (`);
  if (needPauseTracking) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1`);
    if (node.inVOnce) push(`, true`);
    push(`),`);
    newline();
    push(`(`);
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (needPauseTracking) {
    push(`).cacheIndex = ${node.index},`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
  if (needArraySpread) {
    push(`)]`);
  }
}
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(
      asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`
    );
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(
      createCompilerError(
        45,
        node.loc,
        void 0,
        message
      )
    );
  }
}
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    if (true) {
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }
    return node;
  }
}
function stringifyExpression(exp) {
  if (isString(exp)) {
    return exp;
  } else if (exp.type === 4) {
    return exp.content;
  } else {
    return exp.children.map(stringifyExpression).join("");
  }
}
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: cloneLoc(node.loc),
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        comments.unshift(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if (comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(context.parent && context.parent.type === 1 && (context.parent.tag === "transition" || context.parent.tag === "Transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        if (true) {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context.onError(
                  createCompilerError(
                    29,
                    branch.userKey.loc
                  )
                );
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit) onExit();
        context.currentNode = null;
      } else {
        context.onError(
          createCompilerError(30, node.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), [
        true ? '"v-if"' : '""',
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      if (!branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
      }
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag,
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = dir.forParseResult;
  if (!parseResult) {
    context.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  finalizeForParseResult(parseResult, context);
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit) onExit();
  };
}
function finalizeForParseResult(result, context) {
  if (result.finalized) return;
  if (true) {
    validateBrowserExpression(result.source, context);
    if (result.key) {
      validateBrowserExpression(
        result.key,
        context,
        true
      );
    }
    if (result.index) {
      validateBrowserExpression(
        result.index,
        context,
        true
      );
    }
    if (result.value) {
      validateBrowserExpression(
        result.value,
        context,
        true
      );
    }
  }
  result.finalized = true;
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i]) break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, void 0, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir(slotElement, "for");
    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
    let vIf;
    let vElse;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir(
      slotElement,
      /^else(-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, /^(else-)?if$/)) {
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.forParseResult;
      if (parseResult) {
        finalizeForParseResult(parseResult, context);
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
            )
          ])
        );
      } else {
        context.onError(
          createCompilerError(
            32,
            vFor.loc
          )
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, void 0, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``),
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn, index) {
  const props = [
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ];
  if (index != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches)) return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children)) return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(
    node,
    "is",
    false,
    true
    /* allow empty */
  );
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      context
    )) {
      let exp;
      if (isProp.type === 6) {
        exp = isProp.value && createSimpleExpression(isProp.value.content, true);
      } else {
        exp = isProp.exp;
        if (!exp) {
          exp = createSimpleExpression(`is`, false, isProp.arg.loc);
        }
      }
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr) context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
      properties = [];
    }
    if (arg) mergeArgs.push(arg);
  };
  const pushRefVForMarker = () => {
    if (context.scopes.vFor > 0) {
      properties.push(
        createObjectProperty(
          createSimpleExpression("ref_for", true),
          createSimpleExpression("true")
        )
      );
    }
  };
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" && // omit v-model handlers
      name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (isEventHandler && value.type === 14) {
        value = value.arguments[0];
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, nameLoc, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        pushRefVForMarker();
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(name, true, nameLoc),
          createSimpleExpression(
            value ? value.content : "",
            isStatic,
            value ? value.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc, modifiers } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref")) {
        pushRefVForMarker();
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            pushRefVForMarker();
            pushMergeArg();
            {
              if (true) {
                const hasOverridableKeys = mergeArgs.some((arg2) => {
                  if (arg2.type === 15) {
                    return arg2.properties.some(({ key }) => {
                      if (key.type !== 4 || !key.isStatic) {
                        return true;
                      }
                      return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                    });
                  } else {
                    return true;
                  }
                });
                if (hasOverridableKeys) {
                  checkCompatEnabled(
                    "COMPILER_V_BIND_OBJECT_ORDER",
                    context,
                    loc
                  );
                }
              }
              if (isCompatEnabled(
                "COMPILER_V_BIND_OBJECT_ORDER",
                context
              )) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent2 ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      if (isVBind && modifiers.some((mod) => mod.content === "prop")) {
        patchFlag |= 32;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp) dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1) propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp) {
          slotName = p.exp;
        } else if (p.arg && p.arg.type === 4) {
          const name = camelize(p.arg.content);
          slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);
        }
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(
      node,
      context,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}
function createTransformProps(props = []) {
  return { props };
}
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object") continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92) inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92) inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92) inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92) inRegex = false;
    } else if (c === 124 && // pipe
    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ") break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    warnDeprecation(
      "COMPILER_FILTERS",
      context,
      node.loc
    );
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
    node.ast = void 0;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...true ? [transformExpression] : [],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel
    }
  ];
}
function baseCompile(source, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const resolvedOptions = extend({}, options, {
    prefixIdentifiers
  });
  const ast = isString(source) ? baseParse(source, resolvedOptions) : source;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    extend({}, resolvedOptions, {
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(ast, resolvedOptions);
}
var FRAGMENT, TELEPORT, SUSPENSE, KEEP_ALIVE, BASE_TRANSITION, OPEN_BLOCK, CREATE_BLOCK, CREATE_ELEMENT_BLOCK, CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC, RESOLVE_COMPONENT, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_FILTER, WITH_DIRECTIVES, RENDER_LIST, RENDER_SLOT, CREATE_SLOTS, TO_DISPLAY_STRING, MERGE_PROPS, NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS, TO_HANDLERS, CAMELIZE, CAPITALIZE, TO_HANDLER_KEY, SET_BLOCK_TRACKING, PUSH_SCOPE_ID, POP_SCOPE_ID, WITH_CTX, UNREF, IS_REF, WITH_MEMO, IS_MEMO_SAME, helperNameMap, Namespaces, NodeTypes, ElementTypes, ConstantTypes, locStub, defaultDelimitersOpen, defaultDelimitersClose, Sequences, Tokenizer, CompilerDeprecationTypes, deprecationData, ErrorCodes, errorMessages, isFunctionType, isStaticProperty, isStaticPropertyKey, TS_NODE_TYPES, isStaticExp, nonIdentifierRE, isSimpleIdentifier, validFirstIdentCharRE, validIdentCharRE, whitespaceRE, getExpSource, isMemberExpressionBrowser, isMemberExpressionNode, isMemberExpression, fnExpRE, isFnExpressionBrowser, isFnExpressionNode, isFnExpression, propsHelperSet, forAliasRE, defaultParserOptions, currentOptions, currentRoot, currentInput, currentOpenTag, currentProp, currentAttrValue, currentAttrStartIndex, currentAttrEndIndex, inPre, inVPre, currentVPreBoundary, stack, tokenizer, forIteratorRE, stripParensRE, specialTemplateDir, windowsNewlineRE, allowHoistedHelperSet, PURE_ANNOTATION, aliasHelper, prohibitedKeywordRE, stripStringRE, transformExpression, transformIf, transformBind, transformBindShorthand, injectPrefix, transformFor, defaultFallback, trackSlotScopes, trackVForSlotScopes, buildClientSlotFn, directiveImportMap, transformElement, transformSlotOutlet, transformOn, transformText, seen$1, transformOnce, transformModel, validDivisionCharRE, transformFilter, seen, transformMemo, BindingTypes, noopDirectiveTransform;
var init_compiler_core_esm_bundler = __esm({
  "node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js"() {
    init_shared_esm_bundler();
    init_shared_esm_bundler();
    FRAGMENT = Symbol(true ? `Fragment` : ``);
    TELEPORT = Symbol(true ? `Teleport` : ``);
    SUSPENSE = Symbol(true ? `Suspense` : ``);
    KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
    BASE_TRANSITION = Symbol(
      true ? `BaseTransition` : ``
    );
    OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
    CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
    CREATE_ELEMENT_BLOCK = Symbol(
      true ? `createElementBlock` : ``
    );
    CREATE_VNODE = Symbol(true ? `createVNode` : ``);
    CREATE_ELEMENT_VNODE = Symbol(
      true ? `createElementVNode` : ``
    );
    CREATE_COMMENT = Symbol(
      true ? `createCommentVNode` : ``
    );
    CREATE_TEXT = Symbol(
      true ? `createTextVNode` : ``
    );
    CREATE_STATIC = Symbol(
      true ? `createStaticVNode` : ``
    );
    RESOLVE_COMPONENT = Symbol(
      true ? `resolveComponent` : ``
    );
    RESOLVE_DYNAMIC_COMPONENT = Symbol(
      true ? `resolveDynamicComponent` : ``
    );
    RESOLVE_DIRECTIVE = Symbol(
      true ? `resolveDirective` : ``
    );
    RESOLVE_FILTER = Symbol(
      true ? `resolveFilter` : ``
    );
    WITH_DIRECTIVES = Symbol(
      true ? `withDirectives` : ``
    );
    RENDER_LIST = Symbol(true ? `renderList` : ``);
    RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
    CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
    TO_DISPLAY_STRING = Symbol(
      true ? `toDisplayString` : ``
    );
    MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
    NORMALIZE_CLASS = Symbol(
      true ? `normalizeClass` : ``
    );
    NORMALIZE_STYLE = Symbol(
      true ? `normalizeStyle` : ``
    );
    NORMALIZE_PROPS = Symbol(
      true ? `normalizeProps` : ``
    );
    GUARD_REACTIVE_PROPS = Symbol(
      true ? `guardReactiveProps` : ``
    );
    TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
    CAMELIZE = Symbol(true ? `camelize` : ``);
    CAPITALIZE = Symbol(true ? `capitalize` : ``);
    TO_HANDLER_KEY = Symbol(
      true ? `toHandlerKey` : ``
    );
    SET_BLOCK_TRACKING = Symbol(
      true ? `setBlockTracking` : ``
    );
    PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
    POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
    WITH_CTX = Symbol(true ? `withCtx` : ``);
    UNREF = Symbol(true ? `unref` : ``);
    IS_REF = Symbol(true ? `isRef` : ``);
    WITH_MEMO = Symbol(true ? `withMemo` : ``);
    IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
    helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    Namespaces = {
      "HTML": 0,
      "0": "HTML",
      "SVG": 1,
      "1": "SVG",
      "MATH_ML": 2,
      "2": "MATH_ML"
    };
    NodeTypes = {
      "ROOT": 0,
      "0": "ROOT",
      "ELEMENT": 1,
      "1": "ELEMENT",
      "TEXT": 2,
      "2": "TEXT",
      "COMMENT": 3,
      "3": "COMMENT",
      "SIMPLE_EXPRESSION": 4,
      "4": "SIMPLE_EXPRESSION",
      "INTERPOLATION": 5,
      "5": "INTERPOLATION",
      "ATTRIBUTE": 6,
      "6": "ATTRIBUTE",
      "DIRECTIVE": 7,
      "7": "DIRECTIVE",
      "COMPOUND_EXPRESSION": 8,
      "8": "COMPOUND_EXPRESSION",
      "IF": 9,
      "9": "IF",
      "IF_BRANCH": 10,
      "10": "IF_BRANCH",
      "FOR": 11,
      "11": "FOR",
      "TEXT_CALL": 12,
      "12": "TEXT_CALL",
      "VNODE_CALL": 13,
      "13": "VNODE_CALL",
      "JS_CALL_EXPRESSION": 14,
      "14": "JS_CALL_EXPRESSION",
      "JS_OBJECT_EXPRESSION": 15,
      "15": "JS_OBJECT_EXPRESSION",
      "JS_PROPERTY": 16,
      "16": "JS_PROPERTY",
      "JS_ARRAY_EXPRESSION": 17,
      "17": "JS_ARRAY_EXPRESSION",
      "JS_FUNCTION_EXPRESSION": 18,
      "18": "JS_FUNCTION_EXPRESSION",
      "JS_CONDITIONAL_EXPRESSION": 19,
      "19": "JS_CONDITIONAL_EXPRESSION",
      "JS_CACHE_EXPRESSION": 20,
      "20": "JS_CACHE_EXPRESSION",
      "JS_BLOCK_STATEMENT": 21,
      "21": "JS_BLOCK_STATEMENT",
      "JS_TEMPLATE_LITERAL": 22,
      "22": "JS_TEMPLATE_LITERAL",
      "JS_IF_STATEMENT": 23,
      "23": "JS_IF_STATEMENT",
      "JS_ASSIGNMENT_EXPRESSION": 24,
      "24": "JS_ASSIGNMENT_EXPRESSION",
      "JS_SEQUENCE_EXPRESSION": 25,
      "25": "JS_SEQUENCE_EXPRESSION",
      "JS_RETURN_STATEMENT": 26,
      "26": "JS_RETURN_STATEMENT"
    };
    ElementTypes = {
      "ELEMENT": 0,
      "0": "ELEMENT",
      "COMPONENT": 1,
      "1": "COMPONENT",
      "SLOT": 2,
      "2": "SLOT",
      "TEMPLATE": 3,
      "3": "TEMPLATE"
    };
    ConstantTypes = {
      "NOT_CONSTANT": 0,
      "0": "NOT_CONSTANT",
      "CAN_SKIP_PATCH": 1,
      "1": "CAN_SKIP_PATCH",
      "CAN_CACHE": 2,
      "2": "CAN_CACHE",
      "CAN_STRINGIFY": 3,
      "3": "CAN_STRINGIFY"
    };
    locStub = {
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 },
      source: ""
    };
    defaultDelimitersOpen = new Uint8Array([123, 123]);
    defaultDelimitersClose = new Uint8Array([125, 125]);
    Sequences = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      // CDATA[
      CdataEnd: new Uint8Array([93, 93, 62]),
      // ]]>
      CommentEnd: new Uint8Array([45, 45, 62]),
      // `-->`
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      // `<\/script`
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      // `</style`
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
      // `</title`
      TextareaEnd: new Uint8Array([
        60,
        47,
        116,
        101,
        120,
        116,
        97,
        114,
        101,
        97
      ])
      // `</textarea
    };
    Tokenizer = class {
      constructor(stack2, cbs) {
        this.stack = stack2;
        this.cbs = cbs;
        this.state = 1;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.entityStart = 0;
        this.baseState = 1;
        this.inRCDATA = false;
        this.inXML = false;
        this.inVPre = false;
        this.newlines = [];
        this.mode = 0;
        this.delimiterOpen = defaultDelimitersOpen;
        this.delimiterClose = defaultDelimitersClose;
        this.delimiterIndex = -1;
        this.currentSequence = void 0;
        this.sequenceIndex = 0;
      }
      get inSFCRoot() {
        return this.mode === 2 && this.stack.length === 0;
      }
      reset() {
        this.state = 1;
        this.mode = 0;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = 1;
        this.inRCDATA = false;
        this.currentSequence = void 0;
        this.newlines.length = 0;
        this.delimiterOpen = defaultDelimitersOpen;
        this.delimiterClose = defaultDelimitersClose;
      }
      /**
       * Generate Position object with line / column information using recorded
       * newline positions. We know the index is always going to be an already
       * processed index, so all the newlines up to this index should have been
       * recorded.
       */
      getPos(index) {
        let line = 1;
        let column = index + 1;
        for (let i = this.newlines.length - 1; i >= 0; i--) {
          const newlineIndex = this.newlines[i];
          if (index > newlineIndex) {
            line = i + 2;
            column = index - newlineIndex;
            break;
          }
        }
        return {
          column,
          line,
          offset: index
        };
      }
      peek() {
        return this.buffer.charCodeAt(this.index + 1);
      }
      stateText(c) {
        if (c === 60) {
          if (this.index > this.sectionStart) {
            this.cbs.ontext(this.sectionStart, this.index);
          }
          this.state = 5;
          this.sectionStart = this.index;
        } else if (!this.inVPre && c === this.delimiterOpen[0]) {
          this.state = 2;
          this.delimiterIndex = 0;
          this.stateInterpolationOpen(c);
        }
      }
      stateInterpolationOpen(c) {
        if (c === this.delimiterOpen[this.delimiterIndex]) {
          if (this.delimiterIndex === this.delimiterOpen.length - 1) {
            const start = this.index + 1 - this.delimiterOpen.length;
            if (start > this.sectionStart) {
              this.cbs.ontext(this.sectionStart, start);
            }
            this.state = 3;
            this.sectionStart = start;
          } else {
            this.delimiterIndex++;
          }
        } else if (this.inRCDATA) {
          this.state = 32;
          this.stateInRCDATA(c);
        } else {
          this.state = 1;
          this.stateText(c);
        }
      }
      stateInterpolation(c) {
        if (c === this.delimiterClose[0]) {
          this.state = 4;
          this.delimiterIndex = 0;
          this.stateInterpolationClose(c);
        }
      }
      stateInterpolationClose(c) {
        if (c === this.delimiterClose[this.delimiterIndex]) {
          if (this.delimiterIndex === this.delimiterClose.length - 1) {
            this.cbs.oninterpolation(this.sectionStart, this.index + 1);
            if (this.inRCDATA) {
              this.state = 32;
            } else {
              this.state = 1;
            }
            this.sectionStart = this.index + 1;
          } else {
            this.delimiterIndex++;
          }
        } else {
          this.state = 3;
          this.stateInterpolation(c);
        }
      }
      stateSpecialStartSequence(c) {
        const isEnd = this.sequenceIndex === this.currentSequence.length;
        const isMatch = isEnd ? (
          // If we are at the end of the sequence, make sure the tag name has ended
          isEndOfTagSection(c)
        ) : (
          // Otherwise, do a case-insensitive comparison
          (c | 32) === this.currentSequence[this.sequenceIndex]
        );
        if (!isMatch) {
          this.inRCDATA = false;
        } else if (!isEnd) {
          this.sequenceIndex++;
          return;
        }
        this.sequenceIndex = 0;
        this.state = 6;
        this.stateInTagName(c);
      }
      /** Look for an end tag. For <title> and <textarea>, also decode entities. */
      stateInRCDATA(c) {
        if (this.sequenceIndex === this.currentSequence.length) {
          if (c === 62 || isWhitespace(c)) {
            const endOfText = this.index - this.currentSequence.length;
            if (this.sectionStart < endOfText) {
              const actualIndex = this.index;
              this.index = endOfText;
              this.cbs.ontext(this.sectionStart, endOfText);
              this.index = actualIndex;
            }
            this.sectionStart = endOfText + 2;
            this.stateInClosingTagName(c);
            this.inRCDATA = false;
            return;
          }
          this.sequenceIndex = 0;
        }
        if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
          this.sequenceIndex += 1;
        } else if (this.sequenceIndex === 0) {
          if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
            if (!this.inVPre && c === this.delimiterOpen[0]) {
              this.state = 2;
              this.delimiterIndex = 0;
              this.stateInterpolationOpen(c);
            }
          } else if (this.fastForwardTo(60)) {
            this.sequenceIndex = 1;
          }
        } else {
          this.sequenceIndex = Number(c === 60);
        }
      }
      stateCDATASequence(c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
          if (++this.sequenceIndex === Sequences.Cdata.length) {
            this.state = 28;
            this.currentSequence = Sequences.CdataEnd;
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
          }
        } else {
          this.sequenceIndex = 0;
          this.state = 23;
          this.stateInDeclaration(c);
        }
      }
      /**
       * When we wait for one specific character, we can speed things up
       * by skipping through the buffer until we find it.
       *
       * @returns Whether the character was found.
       */
      fastForwardTo(c) {
        while (++this.index < this.buffer.length) {
          const cc = this.buffer.charCodeAt(this.index);
          if (cc === 10) {
            this.newlines.push(this.index);
          }
          if (cc === c) {
            return true;
          }
        }
        this.index = this.buffer.length - 1;
        return false;
      }
      /**
       * Comments and CDATA end with `-->` and `]]>`.
       *
       * Their common qualities are:
       * - Their end sequences have a distinct character they start with.
       * - That character is then repeated, so we have to check multiple repeats.
       * - All characters but the start character of the sequence can be skipped.
       */
      stateInCommentLike(c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
          if (++this.sequenceIndex === this.currentSequence.length) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, this.index - 2);
            } else {
              this.cbs.oncomment(this.sectionStart, this.index - 2);
            }
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
            this.state = 1;
          }
        } else if (this.sequenceIndex === 0) {
          if (this.fastForwardTo(this.currentSequence[0])) {
            this.sequenceIndex = 1;
          }
        } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
          this.sequenceIndex = 0;
        }
      }
      startSpecial(sequence, offset) {
        this.enterRCDATA(sequence, offset);
        this.state = 31;
      }
      enterRCDATA(sequence, offset) {
        this.inRCDATA = true;
        this.currentSequence = sequence;
        this.sequenceIndex = offset;
      }
      stateBeforeTagName(c) {
        if (c === 33) {
          this.state = 22;
          this.sectionStart = this.index + 1;
        } else if (c === 63) {
          this.state = 24;
          this.sectionStart = this.index + 1;
        } else if (isTagStartChar(c)) {
          this.sectionStart = this.index;
          if (this.mode === 0) {
            this.state = 6;
          } else if (this.inSFCRoot) {
            this.state = 34;
          } else if (!this.inXML) {
            if (c === 116) {
              this.state = 30;
            } else {
              this.state = c === 115 ? 29 : 6;
            }
          } else {
            this.state = 6;
          }
        } else if (c === 47) {
          this.state = 8;
        } else {
          this.state = 1;
          this.stateText(c);
        }
      }
      stateInTagName(c) {
        if (isEndOfTagSection(c)) {
          this.handleTagName(c);
        }
      }
      stateInSFCRootTagName(c) {
        if (isEndOfTagSection(c)) {
          const tag = this.buffer.slice(this.sectionStart, this.index);
          if (tag !== "template") {
            this.enterRCDATA(toCharCodes(`</` + tag), 0);
          }
          this.handleTagName(c);
        }
      }
      handleTagName(c) {
        this.cbs.onopentagname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = 11;
        this.stateBeforeAttrName(c);
      }
      stateBeforeClosingTagName(c) {
        if (isWhitespace(c)) ;
        else if (c === 62) {
          if (true) {
            this.cbs.onerr(14, this.index);
          }
          this.state = 1;
          this.sectionStart = this.index + 1;
        } else {
          this.state = isTagStartChar(c) ? 9 : 27;
          this.sectionStart = this.index;
        }
      }
      stateInClosingTagName(c) {
        if (c === 62 || isWhitespace(c)) {
          this.cbs.onclosetag(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = 10;
          this.stateAfterClosingTagName(c);
        }
      }
      stateAfterClosingTagName(c) {
        if (c === 62) {
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeAttrName(c) {
        if (c === 62) {
          this.cbs.onopentagend(this.index);
          if (this.inRCDATA) {
            this.state = 32;
          } else {
            this.state = 1;
          }
          this.sectionStart = this.index + 1;
        } else if (c === 47) {
          this.state = 7;
          if (this.peek() !== 62) {
            this.cbs.onerr(22, this.index);
          }
        } else if (c === 60 && this.peek() === 47) {
          this.cbs.onopentagend(this.index);
          this.state = 5;
          this.sectionStart = this.index;
        } else if (!isWhitespace(c)) {
          if (c === 61) {
            this.cbs.onerr(
              19,
              this.index
            );
          }
          this.handleAttrStart(c);
        }
      }
      handleAttrStart(c) {
        if (c === 118 && this.peek() === 45) {
          this.state = 13;
          this.sectionStart = this.index;
        } else if (c === 46 || c === 58 || c === 64 || c === 35) {
          this.cbs.ondirname(this.index, this.index + 1);
          this.state = 14;
          this.sectionStart = this.index + 1;
        } else {
          this.state = 12;
          this.sectionStart = this.index;
        }
      }
      stateInSelfClosingTag(c) {
        if (c === 62) {
          this.cbs.onselfclosingtag(this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
          this.inRCDATA = false;
        } else if (!isWhitespace(c)) {
          this.state = 11;
          this.stateBeforeAttrName(c);
        }
      }
      stateInAttrName(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.onattribname(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 34 || c === 39 || c === 60) {
          this.cbs.onerr(
            17,
            this.index
          );
        }
      }
      stateInDirName(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 58) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.state = 14;
          this.sectionStart = this.index + 1;
        } else if (c === 46) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.state = 16;
          this.sectionStart = this.index + 1;
        }
      }
      stateInDirArg(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirarg(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 91) {
          this.state = 15;
        } else if (c === 46) {
          this.cbs.ondirarg(this.sectionStart, this.index);
          this.state = 16;
          this.sectionStart = this.index + 1;
        }
      }
      stateInDynamicDirArg(c) {
        if (c === 93) {
          this.state = 14;
        } else if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirarg(this.sectionStart, this.index + 1);
          this.handleAttrNameEnd(c);
          if (true) {
            this.cbs.onerr(
              27,
              this.index
            );
          }
        }
      }
      stateInDirModifier(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirmodifier(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 46) {
          this.cbs.ondirmodifier(this.sectionStart, this.index);
          this.sectionStart = this.index + 1;
        }
      }
      handleAttrNameEnd(c) {
        this.sectionStart = this.index;
        this.state = 17;
        this.cbs.onattribnameend(this.index);
        this.stateAfterAttrName(c);
      }
      stateAfterAttrName(c) {
        if (c === 61) {
          this.state = 18;
        } else if (c === 47 || c === 62) {
          this.cbs.onattribend(0, this.sectionStart);
          this.sectionStart = -1;
          this.state = 11;
          this.stateBeforeAttrName(c);
        } else if (!isWhitespace(c)) {
          this.cbs.onattribend(0, this.sectionStart);
          this.handleAttrStart(c);
        }
      }
      stateBeforeAttrValue(c) {
        if (c === 34) {
          this.state = 19;
          this.sectionStart = this.index + 1;
        } else if (c === 39) {
          this.state = 20;
          this.sectionStart = this.index + 1;
        } else if (!isWhitespace(c)) {
          this.sectionStart = this.index;
          this.state = 21;
          this.stateInAttrValueNoQuotes(c);
        }
      }
      handleInAttrValue(c, quote) {
        if (c === quote || this.fastForwardTo(quote)) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(
            quote === 34 ? 3 : 2,
            this.index + 1
          );
          this.state = 11;
        }
      }
      stateInAttrValueDoubleQuotes(c) {
        this.handleInAttrValue(c, 34);
      }
      stateInAttrValueSingleQuotes(c) {
        this.handleInAttrValue(c, 39);
      }
      stateInAttrValueNoQuotes(c) {
        if (isWhitespace(c) || c === 62) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(1, this.index);
          this.state = 11;
          this.stateBeforeAttrName(c);
        } else if (c === 34 || c === 39 || c === 60 || c === 61 || c === 96) {
          this.cbs.onerr(
            18,
            this.index
          );
        } else ;
      }
      stateBeforeDeclaration(c) {
        if (c === 91) {
          this.state = 26;
          this.sequenceIndex = 0;
        } else {
          this.state = c === 45 ? 25 : 23;
        }
      }
      stateInDeclaration(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateInProcessingInstruction(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.cbs.onprocessinginstruction(this.sectionStart, this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeComment(c) {
        if (c === 45) {
          this.state = 28;
          this.currentSequence = Sequences.CommentEnd;
          this.sequenceIndex = 2;
          this.sectionStart = this.index + 1;
        } else {
          this.state = 23;
        }
      }
      stateInSpecialComment(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.cbs.oncomment(this.sectionStart, this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeSpecialS(c) {
        if (c === Sequences.ScriptEnd[3]) {
          this.startSpecial(Sequences.ScriptEnd, 4);
        } else if (c === Sequences.StyleEnd[3]) {
          this.startSpecial(Sequences.StyleEnd, 4);
        } else {
          this.state = 6;
          this.stateInTagName(c);
        }
      }
      stateBeforeSpecialT(c) {
        if (c === Sequences.TitleEnd[3]) {
          this.startSpecial(Sequences.TitleEnd, 4);
        } else if (c === Sequences.TextareaEnd[3]) {
          this.startSpecial(Sequences.TextareaEnd, 4);
        } else {
          this.state = 6;
          this.stateInTagName(c);
        }
      }
      startEntity() {
      }
      stateInEntity() {
      }
      /**
       * Iterates through the buffer, calling the function corresponding to the current state.
       *
       * States that are more likely to be hit are higher up, as a performance improvement.
       */
      parse(input) {
        this.buffer = input;
        while (this.index < this.buffer.length) {
          const c = this.buffer.charCodeAt(this.index);
          if (c === 10) {
            this.newlines.push(this.index);
          }
          switch (this.state) {
            case 1: {
              this.stateText(c);
              break;
            }
            case 2: {
              this.stateInterpolationOpen(c);
              break;
            }
            case 3: {
              this.stateInterpolation(c);
              break;
            }
            case 4: {
              this.stateInterpolationClose(c);
              break;
            }
            case 31: {
              this.stateSpecialStartSequence(c);
              break;
            }
            case 32: {
              this.stateInRCDATA(c);
              break;
            }
            case 26: {
              this.stateCDATASequence(c);
              break;
            }
            case 19: {
              this.stateInAttrValueDoubleQuotes(c);
              break;
            }
            case 12: {
              this.stateInAttrName(c);
              break;
            }
            case 13: {
              this.stateInDirName(c);
              break;
            }
            case 14: {
              this.stateInDirArg(c);
              break;
            }
            case 15: {
              this.stateInDynamicDirArg(c);
              break;
            }
            case 16: {
              this.stateInDirModifier(c);
              break;
            }
            case 28: {
              this.stateInCommentLike(c);
              break;
            }
            case 27: {
              this.stateInSpecialComment(c);
              break;
            }
            case 11: {
              this.stateBeforeAttrName(c);
              break;
            }
            case 6: {
              this.stateInTagName(c);
              break;
            }
            case 34: {
              this.stateInSFCRootTagName(c);
              break;
            }
            case 9: {
              this.stateInClosingTagName(c);
              break;
            }
            case 5: {
              this.stateBeforeTagName(c);
              break;
            }
            case 17: {
              this.stateAfterAttrName(c);
              break;
            }
            case 20: {
              this.stateInAttrValueSingleQuotes(c);
              break;
            }
            case 18: {
              this.stateBeforeAttrValue(c);
              break;
            }
            case 8: {
              this.stateBeforeClosingTagName(c);
              break;
            }
            case 10: {
              this.stateAfterClosingTagName(c);
              break;
            }
            case 29: {
              this.stateBeforeSpecialS(c);
              break;
            }
            case 30: {
              this.stateBeforeSpecialT(c);
              break;
            }
            case 21: {
              this.stateInAttrValueNoQuotes(c);
              break;
            }
            case 7: {
              this.stateInSelfClosingTag(c);
              break;
            }
            case 23: {
              this.stateInDeclaration(c);
              break;
            }
            case 22: {
              this.stateBeforeDeclaration(c);
              break;
            }
            case 25: {
              this.stateBeforeComment(c);
              break;
            }
            case 24: {
              this.stateInProcessingInstruction(c);
              break;
            }
            case 33: {
              this.stateInEntity();
              break;
            }
          }
          this.index++;
        }
        this.cleanup();
        this.finish();
      }
      /**
       * Remove data that has already been consumed from the buffer.
       */
      cleanup() {
        if (this.sectionStart !== this.index) {
          if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
            this.cbs.ontext(this.sectionStart, this.index);
            this.sectionStart = this.index;
          } else if (this.state === 19 || this.state === 20 || this.state === 21) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = this.index;
          }
        }
      }
      finish() {
        this.handleTrailingData();
        this.cbs.onend();
      }
      /** Handle any trailing data. */
      handleTrailingData() {
        const endIndex = this.buffer.length;
        if (this.sectionStart >= endIndex) {
          return;
        }
        if (this.state === 28) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, endIndex);
          } else {
            this.cbs.oncomment(this.sectionStart, endIndex);
          }
        } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) ;
        else {
          this.cbs.ontext(this.sectionStart, endIndex);
        }
      }
      emitCodePoint(cp, consumed) {
      }
    };
    CompilerDeprecationTypes = {
      "COMPILER_IS_ON_ELEMENT": "COMPILER_IS_ON_ELEMENT",
      "COMPILER_V_BIND_SYNC": "COMPILER_V_BIND_SYNC",
      "COMPILER_V_BIND_OBJECT_ORDER": "COMPILER_V_BIND_OBJECT_ORDER",
      "COMPILER_V_ON_NATIVE": "COMPILER_V_ON_NATIVE",
      "COMPILER_V_IF_V_FOR_PRECEDENCE": "COMPILER_V_IF_V_FOR_PRECEDENCE",
      "COMPILER_NATIVE_TEMPLATE": "COMPILER_NATIVE_TEMPLATE",
      "COMPILER_INLINE_TEMPLATE": "COMPILER_INLINE_TEMPLATE",
      "COMPILER_FILTERS": "COMPILER_FILTERS"
    };
    deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
      },
      ["COMPILER_FILTERS"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
      }
    };
    ErrorCodes = {
      "ABRUPT_CLOSING_OF_EMPTY_COMMENT": 0,
      "0": "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
      "CDATA_IN_HTML_CONTENT": 1,
      "1": "CDATA_IN_HTML_CONTENT",
      "DUPLICATE_ATTRIBUTE": 2,
      "2": "DUPLICATE_ATTRIBUTE",
      "END_TAG_WITH_ATTRIBUTES": 3,
      "3": "END_TAG_WITH_ATTRIBUTES",
      "END_TAG_WITH_TRAILING_SOLIDUS": 4,
      "4": "END_TAG_WITH_TRAILING_SOLIDUS",
      "EOF_BEFORE_TAG_NAME": 5,
      "5": "EOF_BEFORE_TAG_NAME",
      "EOF_IN_CDATA": 6,
      "6": "EOF_IN_CDATA",
      "EOF_IN_COMMENT": 7,
      "7": "EOF_IN_COMMENT",
      "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT": 8,
      "8": "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
      "EOF_IN_TAG": 9,
      "9": "EOF_IN_TAG",
      "INCORRECTLY_CLOSED_COMMENT": 10,
      "10": "INCORRECTLY_CLOSED_COMMENT",
      "INCORRECTLY_OPENED_COMMENT": 11,
      "11": "INCORRECTLY_OPENED_COMMENT",
      "INVALID_FIRST_CHARACTER_OF_TAG_NAME": 12,
      "12": "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
      "MISSING_ATTRIBUTE_VALUE": 13,
      "13": "MISSING_ATTRIBUTE_VALUE",
      "MISSING_END_TAG_NAME": 14,
      "14": "MISSING_END_TAG_NAME",
      "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES": 15,
      "15": "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
      "NESTED_COMMENT": 16,
      "16": "NESTED_COMMENT",
      "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME": 17,
      "17": "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
      "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE": 18,
      "18": "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
      "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME": 19,
      "19": "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
      "UNEXPECTED_NULL_CHARACTER": 20,
      "20": "UNEXPECTED_NULL_CHARACTER",
      "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME": 21,
      "21": "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
      "UNEXPECTED_SOLIDUS_IN_TAG": 22,
      "22": "UNEXPECTED_SOLIDUS_IN_TAG",
      "X_INVALID_END_TAG": 23,
      "23": "X_INVALID_END_TAG",
      "X_MISSING_END_TAG": 24,
      "24": "X_MISSING_END_TAG",
      "X_MISSING_INTERPOLATION_END": 25,
      "25": "X_MISSING_INTERPOLATION_END",
      "X_MISSING_DIRECTIVE_NAME": 26,
      "26": "X_MISSING_DIRECTIVE_NAME",
      "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END": 27,
      "27": "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
      "X_V_IF_NO_EXPRESSION": 28,
      "28": "X_V_IF_NO_EXPRESSION",
      "X_V_IF_SAME_KEY": 29,
      "29": "X_V_IF_SAME_KEY",
      "X_V_ELSE_NO_ADJACENT_IF": 30,
      "30": "X_V_ELSE_NO_ADJACENT_IF",
      "X_V_FOR_NO_EXPRESSION": 31,
      "31": "X_V_FOR_NO_EXPRESSION",
      "X_V_FOR_MALFORMED_EXPRESSION": 32,
      "32": "X_V_FOR_MALFORMED_EXPRESSION",
      "X_V_FOR_TEMPLATE_KEY_PLACEMENT": 33,
      "33": "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
      "X_V_BIND_NO_EXPRESSION": 34,
      "34": "X_V_BIND_NO_EXPRESSION",
      "X_V_ON_NO_EXPRESSION": 35,
      "35": "X_V_ON_NO_EXPRESSION",
      "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET": 36,
      "36": "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
      "X_V_SLOT_MIXED_SLOT_USAGE": 37,
      "37": "X_V_SLOT_MIXED_SLOT_USAGE",
      "X_V_SLOT_DUPLICATE_SLOT_NAMES": 38,
      "38": "X_V_SLOT_DUPLICATE_SLOT_NAMES",
      "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN": 39,
      "39": "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
      "X_V_SLOT_MISPLACED": 40,
      "40": "X_V_SLOT_MISPLACED",
      "X_V_MODEL_NO_EXPRESSION": 41,
      "41": "X_V_MODEL_NO_EXPRESSION",
      "X_V_MODEL_MALFORMED_EXPRESSION": 42,
      "42": "X_V_MODEL_MALFORMED_EXPRESSION",
      "X_V_MODEL_ON_SCOPE_VARIABLE": 43,
      "43": "X_V_MODEL_ON_SCOPE_VARIABLE",
      "X_V_MODEL_ON_PROPS": 44,
      "44": "X_V_MODEL_ON_PROPS",
      "X_INVALID_EXPRESSION": 45,
      "45": "X_INVALID_EXPRESSION",
      "X_KEEP_ALIVE_INVALID_CHILDREN": 46,
      "46": "X_KEEP_ALIVE_INVALID_CHILDREN",
      "X_PREFIX_ID_NOT_SUPPORTED": 47,
      "47": "X_PREFIX_ID_NOT_SUPPORTED",
      "X_MODULE_MODE_NOT_SUPPORTED": 48,
      "48": "X_MODULE_MODE_NOT_SUPPORTED",
      "X_CACHE_HANDLER_NOT_SUPPORTED": 49,
      "49": "X_CACHE_HANDLER_NOT_SUPPORTED",
      "X_SCOPE_ID_NOT_SUPPORTED": 50,
      "50": "X_SCOPE_ID_NOT_SUPPORTED",
      "X_VNODE_HOOKS": 51,
      "51": "X_VNODE_HOOKS",
      "X_V_BIND_INVALID_SAME_NAME_ARGUMENT": 52,
      "52": "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
      "__EXTEND_POINT__": 53,
      "53": "__EXTEND_POINT__"
    };
    errorMessages = {
      // parse errors
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null character.`,
      [22]: "Illegal '/' in tags.",
      // Vue-specific parse errors
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [26]: "Legal directive name was expected.",
      // transform errors
      [28]: `v-if/v-else-if is missing expression.`,
      [29]: `v-if/else branches must use unique keys.`,
      [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31]: `v-for is missing expression.`,
      [32]: `v-for has invalid expression.`,
      [33]: `<template v-for> key should be placed on the <template> tag.`,
      [34]: `v-bind is missing expression.`,
      [52]: `v-bind with same-name shorthand only allows static argument.`,
      [35]: `v-on is missing expression.`,
      [36]: `Unexpected custom directive on <slot> outlet.`,
      [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [38]: `Duplicate slot names found. `,
      [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [40]: `v-slot can only be used on components or <template> tags.`,
      [41]: `v-model is missing expression.`,
      [42]: `v-model value must be a valid JavaScript member expression.`,
      [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
      [45]: `Error parsing JavaScript expression: `,
      [46]: `<KeepAlive> expects exactly one child component.`,
      [51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
      // generic errors
      [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [48]: `ES module mode is not supported in this build of compiler.`,
      [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [50]: `"scopeId" option is only supported in module mode.`,
      // just to fulfill types
      [53]: ``
    };
    isFunctionType = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
    };
    isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
    isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
    TS_NODE_TYPES = [
      "TSAsExpression",
      // foo as number
      "TSTypeAssertion",
      // (<number>foo)
      "TSNonNullExpression",
      // foo!
      "TSInstantiationExpression",
      // foo<string>
      "TSSatisfiesExpression"
      // foo satisfies T
    ];
    isStaticExp = (p) => p.type === 4 && p.isStatic;
    nonIdentifierRE = /^\d|[^\$\w\xA0-\uFFFF]/;
    isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    getExpSource = (exp) => exp.type === 4 ? exp.content : exp.loc.source;
    isMemberExpressionBrowser = (exp) => {
      const path = getExpSource(exp).trim().replace(whitespaceRE, (s) => s.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i === path.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    isMemberExpressionNode = NOOP;
    isMemberExpression = isMemberExpressionBrowser;
    fnExpRE = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    isFnExpressionBrowser = (exp) => fnExpRE.test(getExpSource(exp));
    isFnExpressionNode = NOOP;
    isFnExpression = isFnExpressionBrowser;
    propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
    defaultParserOptions = {
      parseMode: "base",
      ns: 0,
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      isVoidTag: NO,
      isPreTag: NO,
      isIgnoreNewlineTag: NO,
      isCustomElement: NO,
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true,
      prefixIdentifiers: false
    };
    currentOptions = defaultParserOptions;
    currentRoot = null;
    currentInput = "";
    currentOpenTag = null;
    currentProp = null;
    currentAttrValue = "";
    currentAttrStartIndex = -1;
    currentAttrEndIndex = -1;
    inPre = 0;
    inVPre = false;
    currentVPreBoundary = null;
    stack = [];
    tokenizer = new Tokenizer(stack, {
      onerr: emitError,
      ontext(start, end) {
        onText(getSlice(start, end), start, end);
      },
      ontextentity(char, start, end) {
        onText(char, start, end);
      },
      oninterpolation(start, end) {
        if (inVPre) {
          return onText(getSlice(start, end), start, end);
        }
        let innerStart = start + tokenizer.delimiterOpen.length;
        let innerEnd = end - tokenizer.delimiterClose.length;
        while (isWhitespace(currentInput.charCodeAt(innerStart))) {
          innerStart++;
        }
        while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
          innerEnd--;
        }
        let exp = getSlice(innerStart, innerEnd);
        if (exp.includes("&")) {
          {
            exp = currentOptions.decodeEntities(exp, false);
          }
        }
        addNode({
          type: 5,
          content: createExp(exp, false, getLoc(innerStart, innerEnd)),
          loc: getLoc(start, end)
        });
      },
      onopentagname(start, end) {
        const name = getSlice(start, end);
        currentOpenTag = {
          type: 1,
          tag: name,
          ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
          tagType: 0,
          // will be refined on tag close
          props: [],
          children: [],
          loc: getLoc(start - 1, end),
          codegenNode: void 0
        };
      },
      onopentagend(end) {
        endOpenTag(end);
      },
      onclosetag(start, end) {
        const name = getSlice(start, end);
        if (!currentOptions.isVoidTag(name)) {
          let found = false;
          for (let i = 0; i < stack.length; i++) {
            const e = stack[i];
            if (e.tag.toLowerCase() === name.toLowerCase()) {
              found = true;
              if (i > 0) {
                emitError(24, stack[0].loc.start.offset);
              }
              for (let j = 0; j <= i; j++) {
                const el = stack.shift();
                onCloseTag(el, end, j < i);
              }
              break;
            }
          }
          if (!found) {
            emitError(23, backTrack(start, 60));
          }
        }
      },
      onselfclosingtag(end) {
        const name = currentOpenTag.tag;
        currentOpenTag.isSelfClosing = true;
        endOpenTag(end);
        if (stack[0] && stack[0].tag === name) {
          onCloseTag(stack.shift(), end);
        }
      },
      onattribname(start, end) {
        currentProp = {
          type: 6,
          name: getSlice(start, end),
          nameLoc: getLoc(start, end),
          value: void 0,
          loc: getLoc(start)
        };
      },
      ondirname(start, end) {
        const raw = getSlice(start, end);
        const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
        if (!inVPre && name === "") {
          emitError(26, start);
        }
        if (inVPre || name === "") {
          currentProp = {
            type: 6,
            name: raw,
            nameLoc: getLoc(start, end),
            value: void 0,
            loc: getLoc(start)
          };
        } else {
          currentProp = {
            type: 7,
            name,
            rawName: raw,
            exp: void 0,
            arg: void 0,
            modifiers: raw === "." ? [createSimpleExpression("prop")] : [],
            loc: getLoc(start)
          };
          if (name === "pre") {
            inVPre = tokenizer.inVPre = true;
            currentVPreBoundary = currentOpenTag;
            const props = currentOpenTag.props;
            for (let i = 0; i < props.length; i++) {
              if (props[i].type === 7) {
                props[i] = dirToAttr(props[i]);
              }
            }
          }
        }
      },
      ondirarg(start, end) {
        if (start === end) return;
        const arg = getSlice(start, end);
        if (inVPre) {
          currentProp.name += arg;
          setLocEnd(currentProp.nameLoc, end);
        } else {
          const isStatic = arg[0] !== `[`;
          currentProp.arg = createExp(
            isStatic ? arg : arg.slice(1, -1),
            isStatic,
            getLoc(start, end),
            isStatic ? 3 : 0
          );
        }
      },
      ondirmodifier(start, end) {
        const mod = getSlice(start, end);
        if (inVPre) {
          currentProp.name += "." + mod;
          setLocEnd(currentProp.nameLoc, end);
        } else if (currentProp.name === "slot") {
          const arg = currentProp.arg;
          if (arg) {
            arg.content += "." + mod;
            setLocEnd(arg.loc, end);
          }
        } else {
          const exp = createSimpleExpression(mod, true, getLoc(start, end));
          currentProp.modifiers.push(exp);
        }
      },
      onattribdata(start, end) {
        currentAttrValue += getSlice(start, end);
        if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
        currentAttrEndIndex = end;
      },
      onattribentity(char, start, end) {
        currentAttrValue += char;
        if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
        currentAttrEndIndex = end;
      },
      onattribnameend(end) {
        const start = currentProp.loc.start.offset;
        const name = getSlice(start, end);
        if (currentProp.type === 7) {
          currentProp.rawName = name;
        }
        if (currentOpenTag.props.some(
          (p) => (p.type === 7 ? p.rawName : p.name) === name
        )) {
          emitError(2, start);
        }
      },
      onattribend(quote, end) {
        if (currentOpenTag && currentProp) {
          setLocEnd(currentProp.loc, end);
          if (quote !== 0) {
            if (currentAttrValue.includes("&")) {
              currentAttrValue = currentOptions.decodeEntities(
                currentAttrValue,
                true
              );
            }
            if (currentProp.type === 6) {
              if (currentProp.name === "class") {
                currentAttrValue = condense(currentAttrValue).trim();
              }
              if (quote === 1 && !currentAttrValue) {
                emitError(13, end);
              }
              currentProp.value = {
                type: 2,
                content: currentAttrValue,
                loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
              };
              if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
                tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
              }
            } else {
              let expParseMode = 0;
              currentProp.exp = createExp(
                currentAttrValue,
                false,
                getLoc(currentAttrStartIndex, currentAttrEndIndex),
                0,
                expParseMode
              );
              if (currentProp.name === "for") {
                currentProp.forParseResult = parseForExpression(currentProp.exp);
              }
              let syncIndex = -1;
              if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.findIndex(
                (mod) => mod.content === "sync"
              )) > -1 && checkCompatEnabled(
                "COMPILER_V_BIND_SYNC",
                currentOptions,
                currentProp.loc,
                currentProp.arg.loc.source
              )) {
                currentProp.name = "model";
                currentProp.modifiers.splice(syncIndex, 1);
              }
            }
          }
          if (currentProp.type !== 7 || currentProp.name !== "pre") {
            currentOpenTag.props.push(currentProp);
          }
        }
        currentAttrValue = "";
        currentAttrStartIndex = currentAttrEndIndex = -1;
      },
      oncomment(start, end) {
        if (currentOptions.comments) {
          addNode({
            type: 3,
            content: getSlice(start, end),
            loc: getLoc(start - 4, end + 3)
          });
        }
      },
      onend() {
        const end = currentInput.length;
        if (tokenizer.state !== 1) {
          switch (tokenizer.state) {
            case 5:
            case 8:
              emitError(5, end);
              break;
            case 3:
            case 4:
              emitError(
                25,
                tokenizer.sectionStart
              );
              break;
            case 28:
              if (tokenizer.currentSequence === Sequences.CdataEnd) {
                emitError(6, end);
              } else {
                emitError(7, end);
              }
              break;
            case 6:
            case 7:
            case 9:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
              emitError(9, end);
              break;
          }
        }
        for (let index = 0; index < stack.length; index++) {
          onCloseTag(stack[index], end - 1);
          emitError(24, stack[index].loc.start.offset);
        }
      },
      oncdata(start, end) {
        if (stack[0].ns !== 0) {
          onText(getSlice(start, end), start, end);
        } else {
          emitError(1, start - 9);
        }
      },
      onprocessinginstruction(start) {
        if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
          emitError(
            21,
            start - 1
          );
        }
      }
    });
    forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    stripParensRE = /^\(|\)$/g;
    specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
    windowsNewlineRE = /\r\n/g;
    allowHoistedHelperSet = /* @__PURE__ */ new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    PURE_ANNOTATION = `/*@__PURE__*/`;
    aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
    prohibitedKeywordRE = new RegExp(
      "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
    );
    stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
    transformExpression = (node, context) => {
      if (node.type === 5) {
        node.content = processExpression(
          node.content,
          context
        );
      } else if (node.type === 1) {
        const memo = findDir(node, "memo");
        for (let i = 0; i < node.props.length; i++) {
          const dir = node.props[i];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg) && // key has been processed in transformFor(vMemo + vFor)
            !(memo && arg && arg.type === 4 && arg.content === "key")) {
              dir.exp = processExpression(
                exp,
                context,
                // slot args must be processed as function params
                dir.name === "slot"
              );
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context);
            }
          }
        }
      }
    };
    transformIf = createStructuralDirectiveTransform(
      /^(if|else|else-if)$/,
      (node, dir, context) => {
        return processIf(node, dir, context, (ifNode, branch, isRoot) => {
          const siblings = context.parent.children;
          let i = siblings.indexOf(ifNode);
          let key = 0;
          while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9) {
              key += sibling.branches.length;
            }
          }
          return () => {
            if (isRoot) {
              ifNode.codegenNode = createCodegenNodeForBranch(
                branch,
                key,
                context
              );
            } else {
              const parentCondition = getParentCondition(ifNode.codegenNode);
              parentCondition.alternate = createCodegenNodeForBranch(
                branch,
                key + ifNode.branches.length - 1,
                context
              );
            }
          };
        });
      }
    );
    transformBind = (dir, _node, context) => {
      const { modifiers, loc } = dir;
      const arg = dir.arg;
      let { exp } = dir;
      if (exp && exp.type === 4 && !exp.content.trim()) {
        {
          exp = void 0;
        }
      }
      if (!exp) {
        if (arg.type !== 4 || !arg.isStatic) {
          context.onError(
            createCompilerError(
              52,
              arg.loc
            )
          );
          return {
            props: [
              createObjectProperty(arg, createSimpleExpression("", true, loc))
            ]
          };
        }
        transformBindShorthand(dir);
        exp = dir.exp;
      }
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.some((mod) => mod.content === "camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = camelize(arg.content);
          } else {
            arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context.inSSR) {
        if (modifiers.some((mod) => mod.content === "prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.some((mod) => mod.content === "attr")) {
          injectPrefix(arg, "^");
        }
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    transformBindShorthand = (dir, context) => {
      const arg = dir.arg;
      const propName = camelize(arg.content);
      dir.exp = createSimpleExpression(propName, false, arg.loc);
    };
    injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    transformFor = createStructuralDirectiveTransform(
      "for",
      (node, dir, context) => {
        const { helper, removeHelper } = context;
        return processFor(node, dir, context, (forNode) => {
          const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
          ]);
          const isTemplate = isTemplateNode(node);
          const memo = findDir(node, "memo");
          const keyProp = findProp(node, `key`, false, true);
          const isDirKey = keyProp && keyProp.type === 7;
          if (isDirKey && !keyProp.exp) {
            transformBindShorthand(keyProp);
          }
          let keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
          const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
          const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
          const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
          forNode.codegenNode = createVNodeCall(
            context,
            helper(FRAGMENT),
            void 0,
            renderExp,
            fragmentFlag,
            void 0,
            void 0,
            true,
            !isStableFragment,
            false,
            node.loc
          );
          return () => {
            let childBlock;
            const { children } = forNode;
            if (isTemplate) {
              node.children.some((c) => {
                if (c.type === 1) {
                  const key = findProp(c, "key");
                  if (key) {
                    context.onError(
                      createCompilerError(
                        33,
                        key.loc
                      )
                    );
                    return true;
                  }
                }
              });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
            const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
            if (slotOutlet) {
              childBlock = slotOutlet.codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
            } else if (needFragmentWrapper) {
              childBlock = createVNodeCall(
                context,
                helper(FRAGMENT),
                keyProperty ? createObjectExpression([keyProperty]) : void 0,
                node.children,
                64,
                void 0,
                void 0,
                true,
                void 0,
                false
              );
            } else {
              childBlock = children[0].codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
              if (childBlock.isBlock !== !isStableFragment) {
                if (childBlock.isBlock) {
                  removeHelper(OPEN_BLOCK);
                  removeHelper(
                    getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                  );
                } else {
                  removeHelper(
                    getVNodeHelper(context.inSSR, childBlock.isComponent)
                  );
                }
              }
              childBlock.isBlock = !isStableFragment;
              if (childBlock.isBlock) {
                helper(OPEN_BLOCK);
                helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
              } else {
                helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
              }
            }
            if (memo) {
              const loop = createFunctionExpression(
                createForLoopParams(forNode.parseResult, [
                  createSimpleExpression(`_cached`)
                ])
              );
              loop.body = createBlockStatement([
                createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                createCompoundExpression([
                  `if (_cached`,
                  ...keyExp ? [` && _cached.key === `, keyExp] : [],
                  ` && ${context.helperString(
                    IS_MEMO_SAME
                  )}(_cached, _memo)) return _cached`
                ]),
                createCompoundExpression([`const _item = `, childBlock]),
                createSimpleExpression(`_item.memo = _memo`),
                createSimpleExpression(`return _item`)
              ]);
              renderExp.arguments.push(
                loop,
                createSimpleExpression(`_cache`),
                createSimpleExpression(String(context.cached.length))
              );
              context.cached.push(null);
            } else {
              renderExp.arguments.push(
                createFunctionExpression(
                  createForLoopParams(forNode.parseResult),
                  childBlock,
                  true
                )
              );
            }
          };
        });
      }
    );
    defaultFallback = createSimpleExpression(`undefined`, false);
    trackSlotScopes = (node, context) => {
      if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
        const vSlot = findDir(node, "slot");
        if (vSlot) {
          vSlot.exp;
          context.scopes.vSlot++;
          return () => {
            context.scopes.vSlot--;
          };
        }
      }
    };
    trackVForSlotScopes = (node, context) => {
      let vFor;
      if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
        const result = vFor.forParseResult;
        if (result) {
          finalizeForParseResult(result, context);
          const { value, key, index } = result;
          const { addIdentifiers, removeIdentifiers } = context;
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index && addIdentifiers(index);
          return () => {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index && removeIdentifiers(index);
          };
        }
      }
    };
    buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
      props,
      children,
      false,
      true,
      children.length ? children[0].loc : loc
    );
    directiveImportMap = /* @__PURE__ */ new WeakMap();
    transformElement = (node, context) => {
      return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
          return;
        }
        const { tag, props } = node;
        const isComponent2 = node.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
        const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = (
          // dynamic component may resolve to plain elements
          isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
          // updates inside get proper isSVG flag at runtime. (#639, #643)
          // This is technically web-specific, but splitting the logic out of core
          // leads to too much unnecessary complexity.
          (tag === "svg" || tag === "foreignObject" || tag === "math")
        );
        if (props.length > 0) {
          const propsBuildResult = buildProps(
            node,
            context,
            void 0,
            isComponent2,
            isDynamicComponent
          );
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(
            directives.map((dir) => buildDirectiveArgs(dir, context))
          ) : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
            if (node.children.length > 1) {
              context.onError(
                createCompilerError(46, {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                })
              );
            }
          }
          const shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
          vnodeTag !== TELEPORT && // explained above.
          vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node, context);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node.children;
            }
          } else {
            vnodeChildren = node.children;
          }
        }
        if (dynamicPropNames && dynamicPropNames.length) {
          vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
        }
        node.codegenNode = createVNodeCall(
          context,
          vnodeTag,
          vnodeProps,
          vnodeChildren,
          patchFlag === 0 ? void 0 : patchFlag,
          vnodeDynamicProps,
          vnodeDirectives,
          !!shouldUseBlock,
          false,
          isComponent2,
          node.loc
        );
      };
    };
    transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
          context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true"
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression([], children, false, false, loc);
          expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node.codegenNode = createCallExpression(
          context.helper(RENDER_SLOT),
          slotArgs,
          loc
        );
      }
    };
    transformOn = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vnode")) {
            context.onError(createCompilerError(51, arg.loc));
          }
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
            // for non-element and vnode lifecycle event listeners, auto convert
            // it to camelCase. See issue #2249
            toHandlerKey(camelize(rawName))
          ) : (
            // preserve case for plain element listeners that have uppercase
            // letters, as these may be custom elements' custom events
            `on:${rawName}`
          );
          eventName = createSimpleExpression(eventString, true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp);
        const isInlineStatement = !(isMemberExp || isFnExpression(exp));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
          validateBrowserExpression(
            exp,
            context,
            false,
            hasMultipleStatements
          );
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(
            eventName,
            exp || createSimpleExpression(`() => {}`, false, loc)
          )
        ]
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context.cache(ret.props[0].value);
      }
      ret.props.forEach((p) => p.key.isHandlerKey = true);
      return ret;
    };
    transformText = (node, context) => {
      if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
        return () => {
          const children = node.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child)) {
              hasText = true;
              for (let j = i + 1; j < children.length; j++) {
                const next = children[j];
                if (isText$1(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i] = createCompoundExpression(
                      [child],
                      child.loc
                    );
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j, 1);
                  j--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || // if this is a plain element with a single text child, leave it
          // as-is since the runtime has dedicated fast path for this by directly
          // setting textContent of the element.
          // for component root it's always normalized anyway.
          children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
          // custom directives can potentially add DOM elements arbitrarily,
          // we need to avoid setting textContent of the element at runtime
          // to avoid accidentally overwriting the DOM elements added
          // by the user through custom directives.
          !node.props.find(
            (p) => p.type === 7 && !context.directiveTransforms[p.name]
          ) && // in compat mode, <template> tags with no special directives
          // will be rendered as a fragment so its children must be
          // converted into vnodes.
          !(node.tag === "template"))) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context.ssr && getConstantType(child, context) === 0) {
                callArgs.push(
                  1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``)
                );
              }
              children[i] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(
                  context.helper(CREATE_TEXT),
                  callArgs
                )
              };
            }
          }
        };
      }
    };
    seen$1 = /* @__PURE__ */ new WeakSet();
    transformOnce = (node, context) => {
      if (node.type === 1 && findDir(node, "once", true)) {
        if (seen$1.has(node) || context.inVOnce || context.inSSR) {
          return;
        }
        seen$1.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
          context.inVOnce = false;
          const cur = context.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context.cache(
              cur.codegenNode,
              true,
              true
            );
          }
        };
      }
    };
    transformModel = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
        context.onError(
          createCompilerError(41, dir.loc)
        );
        return createTransformProps();
      }
      const rawExp = exp.loc.source.trim();
      const expString = exp.type === 4 ? exp.content : rawExp;
      const bindingType = context.bindingMetadata[rawExp];
      if (bindingType === "props" || bindingType === "props-aliased") {
        context.onError(createCompilerError(44, exp.loc));
        return createTransformProps();
      }
      if (!expString.trim() || !isMemberExpression(exp) && true) {
        context.onError(
          createCompilerError(42, exp.loc)
        );
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`
        ]);
      }
      const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, assignmentExp)
      ];
      if (dir.modifiers.length && node.tagType === 1) {
        const modifiers = dir.modifiers.map((m) => m.content).map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(
          createObjectProperty(
            modifiersKey,
            createSimpleExpression(
              `{ ${modifiers} }`,
              false,
              dir.loc,
              2
            )
          )
        );
      }
      return createTransformProps(props);
    };
    validDivisionCharRE = /[\w).+\-_$\]]/;
    transformFilter = (node, context) => {
      if (!isCompatEnabled("COMPILER_FILTERS", context)) {
        return;
      }
      if (node.type === 5) {
        rewriteFilter(node.content, context);
      } else if (node.type === 1) {
        node.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context);
          }
        });
      }
    };
    seen = /* @__PURE__ */ new WeakSet();
    transformMemo = (node, context) => {
      if (node.type === 1) {
        const dir = findDir(node, "memo");
        if (!dir || seen.has(node)) {
          return;
        }
        seen.add(node);
        return () => {
          const codegenNode = node.codegenNode || context.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node.tagType !== 1) {
              convertToBlock(codegenNode, context);
            }
            node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context.cached.length)
            ]);
            context.cached.push(null);
          }
        };
      }
    };
    BindingTypes = {
      "DATA": "data",
      "PROPS": "props",
      "PROPS_ALIASED": "props-aliased",
      "SETUP_LET": "setup-let",
      "SETUP_CONST": "setup-const",
      "SETUP_REACTIVE_CONST": "setup-reactive-const",
      "SETUP_MAYBE_REF": "setup-maybe-ref",
      "SETUP_REF": "setup-ref",
      "OPTIONS": "options",
      "LITERAL_CONST": "literal-const"
    };
    noopDirectiveTransform = () => ({ props: [] });
  }
});

// node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
var compiler_dom_esm_bundler_exports = {};
__export(compiler_dom_esm_bundler_exports, {
  BASE_TRANSITION: () => BASE_TRANSITION,
  BindingTypes: () => BindingTypes,
  CAMELIZE: () => CAMELIZE,
  CAPITALIZE: () => CAPITALIZE,
  CREATE_BLOCK: () => CREATE_BLOCK,
  CREATE_COMMENT: () => CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK: () => CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE: () => CREATE_ELEMENT_VNODE,
  CREATE_SLOTS: () => CREATE_SLOTS,
  CREATE_STATIC: () => CREATE_STATIC,
  CREATE_TEXT: () => CREATE_TEXT,
  CREATE_VNODE: () => CREATE_VNODE,
  CompilerDeprecationTypes: () => CompilerDeprecationTypes,
  ConstantTypes: () => ConstantTypes,
  DOMDirectiveTransforms: () => DOMDirectiveTransforms,
  DOMErrorCodes: () => DOMErrorCodes,
  DOMErrorMessages: () => DOMErrorMessages,
  DOMNodeTransforms: () => DOMNodeTransforms,
  ElementTypes: () => ElementTypes,
  ErrorCodes: () => ErrorCodes,
  FRAGMENT: () => FRAGMENT,
  GUARD_REACTIVE_PROPS: () => GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME: () => IS_MEMO_SAME,
  IS_REF: () => IS_REF,
  KEEP_ALIVE: () => KEEP_ALIVE,
  MERGE_PROPS: () => MERGE_PROPS,
  NORMALIZE_CLASS: () => NORMALIZE_CLASS,
  NORMALIZE_PROPS: () => NORMALIZE_PROPS,
  NORMALIZE_STYLE: () => NORMALIZE_STYLE,
  Namespaces: () => Namespaces,
  NodeTypes: () => NodeTypes,
  OPEN_BLOCK: () => OPEN_BLOCK,
  POP_SCOPE_ID: () => POP_SCOPE_ID,
  PUSH_SCOPE_ID: () => PUSH_SCOPE_ID,
  RENDER_LIST: () => RENDER_LIST,
  RENDER_SLOT: () => RENDER_SLOT,
  RESOLVE_COMPONENT: () => RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE: () => RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT: () => RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER: () => RESOLVE_FILTER,
  SET_BLOCK_TRACKING: () => SET_BLOCK_TRACKING,
  SUSPENSE: () => SUSPENSE,
  TELEPORT: () => TELEPORT,
  TO_DISPLAY_STRING: () => TO_DISPLAY_STRING,
  TO_HANDLERS: () => TO_HANDLERS,
  TO_HANDLER_KEY: () => TO_HANDLER_KEY,
  TRANSITION: () => TRANSITION,
  TRANSITION_GROUP: () => TRANSITION_GROUP,
  TS_NODE_TYPES: () => TS_NODE_TYPES,
  UNREF: () => UNREF,
  V_MODEL_CHECKBOX: () => V_MODEL_CHECKBOX,
  V_MODEL_DYNAMIC: () => V_MODEL_DYNAMIC,
  V_MODEL_RADIO: () => V_MODEL_RADIO,
  V_MODEL_SELECT: () => V_MODEL_SELECT,
  V_MODEL_TEXT: () => V_MODEL_TEXT,
  V_ON_WITH_KEYS: () => V_ON_WITH_KEYS,
  V_ON_WITH_MODIFIERS: () => V_ON_WITH_MODIFIERS,
  V_SHOW: () => V_SHOW,
  WITH_CTX: () => WITH_CTX,
  WITH_DIRECTIVES: () => WITH_DIRECTIVES,
  WITH_MEMO: () => WITH_MEMO,
  advancePositionWithClone: () => advancePositionWithClone,
  advancePositionWithMutation: () => advancePositionWithMutation,
  assert: () => assert,
  baseCompile: () => baseCompile,
  baseParse: () => baseParse,
  buildDirectiveArgs: () => buildDirectiveArgs,
  buildProps: () => buildProps,
  buildSlots: () => buildSlots,
  checkCompatEnabled: () => checkCompatEnabled,
  compile: () => compile,
  convertToBlock: () => convertToBlock,
  createArrayExpression: () => createArrayExpression,
  createAssignmentExpression: () => createAssignmentExpression,
  createBlockStatement: () => createBlockStatement,
  createCacheExpression: () => createCacheExpression,
  createCallExpression: () => createCallExpression,
  createCompilerError: () => createCompilerError,
  createCompoundExpression: () => createCompoundExpression,
  createConditionalExpression: () => createConditionalExpression,
  createDOMCompilerError: () => createDOMCompilerError,
  createForLoopParams: () => createForLoopParams,
  createFunctionExpression: () => createFunctionExpression,
  createIfStatement: () => createIfStatement,
  createInterpolation: () => createInterpolation,
  createObjectExpression: () => createObjectExpression,
  createObjectProperty: () => createObjectProperty,
  createReturnStatement: () => createReturnStatement,
  createRoot: () => createRoot,
  createSequenceExpression: () => createSequenceExpression,
  createSimpleExpression: () => createSimpleExpression,
  createStructuralDirectiveTransform: () => createStructuralDirectiveTransform,
  createTemplateLiteral: () => createTemplateLiteral,
  createTransformContext: () => createTransformContext,
  createVNodeCall: () => createVNodeCall,
  errorMessages: () => errorMessages,
  extractIdentifiers: () => extractIdentifiers,
  findDir: () => findDir,
  findProp: () => findProp,
  forAliasRE: () => forAliasRE,
  generate: () => generate,
  generateCodeFrame: () => generateCodeFrame,
  getBaseTransformPreset: () => getBaseTransformPreset,
  getConstantType: () => getConstantType,
  getMemoedVNodeCall: () => getMemoedVNodeCall,
  getVNodeBlockHelper: () => getVNodeBlockHelper,
  getVNodeHelper: () => getVNodeHelper,
  hasDynamicKeyVBind: () => hasDynamicKeyVBind,
  hasScopeRef: () => hasScopeRef,
  helperNameMap: () => helperNameMap,
  injectProp: () => injectProp,
  isCoreComponent: () => isCoreComponent,
  isFnExpression: () => isFnExpression,
  isFnExpressionBrowser: () => isFnExpressionBrowser,
  isFnExpressionNode: () => isFnExpressionNode,
  isFunctionType: () => isFunctionType,
  isInDestructureAssignment: () => isInDestructureAssignment,
  isInNewExpression: () => isInNewExpression,
  isMemberExpression: () => isMemberExpression,
  isMemberExpressionBrowser: () => isMemberExpressionBrowser,
  isMemberExpressionNode: () => isMemberExpressionNode,
  isReferencedIdentifier: () => isReferencedIdentifier,
  isSimpleIdentifier: () => isSimpleIdentifier,
  isSlotOutlet: () => isSlotOutlet,
  isStaticArgOf: () => isStaticArgOf,
  isStaticExp: () => isStaticExp,
  isStaticProperty: () => isStaticProperty,
  isStaticPropertyKey: () => isStaticPropertyKey,
  isTemplateNode: () => isTemplateNode,
  isText: () => isText$1,
  isVSlot: () => isVSlot,
  locStub: () => locStub,
  noopDirectiveTransform: () => noopDirectiveTransform,
  parse: () => parse,
  parserOptions: () => parserOptions,
  processExpression: () => processExpression,
  processFor: () => processFor,
  processIf: () => processIf,
  processSlotOutlet: () => processSlotOutlet,
  registerRuntimeHelpers: () => registerRuntimeHelpers,
  resolveComponentType: () => resolveComponentType,
  stringifyExpression: () => stringifyExpression,
  toValidAssetId: () => toValidAssetId,
  trackSlotScopes: () => trackSlotScopes,
  trackVForSlotScopes: () => trackVForSlotScopes,
  transform: () => transform,
  transformBind: () => transformBind,
  transformElement: () => transformElement,
  transformExpression: () => transformExpression,
  transformModel: () => transformModel,
  transformOn: () => transformOn,
  transformStyle: () => transformStyle,
  traverseNode: () => traverseNode,
  unwrapTSNode: () => unwrapTSNode,
  walkBlockDeclarations: () => walkBlockDeclarations,
  walkFunctionParams: () => walkFunctionParams,
  walkIdentifiers: () => walkIdentifiers,
  warnDeprecation: () => warnDeprecation
});
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
function createDOMCompilerError(code, loc) {
  return createCompilerError(
    code,
    loc,
    true ? DOMErrorMessages : void 0
  );
}
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter(
    (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())
  );
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}
function isValidHTMLNesting(parent, child) {
  if (parent in onlyValidChildren) {
    return onlyValidChildren[parent].has(child);
  }
  if (child in onlyValidParents) {
    return onlyValidParents[child].has(parent);
  }
  if (parent in knownInvalidChildren) {
    if (knownInvalidChildren[parent].has(child)) return false;
  }
  if (child in knownInvalidParents) {
    if (knownInvalidParents[child].has(parent)) return false;
  }
  return true;
}
function compile(src, options = {}) {
  return baseCompile(
    src,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
function parse(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options));
}
var V_MODEL_RADIO, V_MODEL_CHECKBOX, V_MODEL_TEXT, V_MODEL_SELECT, V_MODEL_DYNAMIC, V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS, V_SHOW, TRANSITION, TRANSITION_GROUP, decoder, parserOptions, transformStyle, parseInlineCSS, DOMErrorCodes, DOMErrorMessages, transformVHtml, transformVText, transformModel2, isEventOptionModifier, isNonKeyModifier, maybeKeyModifier, isKeyboardEvent, resolveModifiers, transformClick, transformOn2, transformShow, transformTransition, ignoreSideEffectTags, headings, emptySet, onlyValidChildren, onlyValidParents, knownInvalidChildren, knownInvalidParents, validateHtmlNesting, DOMNodeTransforms, DOMDirectiveTransforms;
var init_compiler_dom_esm_bundler = __esm({
  "node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"() {
    init_compiler_core_esm_bundler();
    init_compiler_core_esm_bundler();
    init_shared_esm_bundler();
    V_MODEL_RADIO = Symbol(true ? `vModelRadio` : ``);
    V_MODEL_CHECKBOX = Symbol(
      true ? `vModelCheckbox` : ``
    );
    V_MODEL_TEXT = Symbol(true ? `vModelText` : ``);
    V_MODEL_SELECT = Symbol(
      true ? `vModelSelect` : ``
    );
    V_MODEL_DYNAMIC = Symbol(
      true ? `vModelDynamic` : ``
    );
    V_ON_WITH_MODIFIERS = Symbol(
      true ? `vOnModifiersGuard` : ``
    );
    V_ON_WITH_KEYS = Symbol(
      true ? `vOnKeysGuard` : ``
    );
    V_SHOW = Symbol(true ? `vShow` : ``);
    TRANSITION = Symbol(true ? `Transition` : ``);
    TRANSITION_GROUP = Symbol(
      true ? `TransitionGroup` : ``
    );
    registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
    });
    parserOptions = {
      parseMode: "html",
      isVoidTag,
      isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
      isPreTag: (tag) => tag === "pre",
      isIgnoreNewlineTag: (tag) => tag === "pre" || tag === "textarea",
      decodeEntities: decodeHtmlBrowser,
      isBuiltInComponent: (tag) => {
        if (tag === "Transition" || tag === "transition") {
          return TRANSITION;
        } else if (tag === "TransitionGroup" || tag === "transition-group") {
          return TRANSITION_GROUP;
        }
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
      getNamespace(tag, parent, rootNamespace) {
        let ns = parent ? parent.ns : rootNamespace;
        if (parent && ns === 2) {
          if (parent.tag === "annotation-xml") {
            if (tag === "svg") {
              return 1;
            }
            if (parent.props.some(
              (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
            )) {
              ns = 0;
            }
          } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
            ns = 0;
          }
        } else if (parent && ns === 1) {
          if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
            ns = 0;
          }
        }
        if (ns === 0) {
          if (tag === "svg") {
            return 1;
          }
          if (tag === "math") {
            return 2;
          }
        }
        return ns;
      }
    };
    transformStyle = (node) => {
      if (node.type === 1) {
        node.props.forEach((p, i) => {
          if (p.type === 6 && p.name === "style" && p.value) {
            node.props[i] = {
              type: 7,
              name: `bind`,
              arg: createSimpleExpression(`style`, true, p.loc),
              exp: parseInlineCSS(p.value.content, p.loc),
              modifiers: [],
              loc: p.loc
            };
          }
        });
      }
    };
    parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(
        JSON.stringify(normalized),
        false,
        loc,
        3
      );
    };
    DOMErrorCodes = {
      "X_V_HTML_NO_EXPRESSION": 53,
      "53": "X_V_HTML_NO_EXPRESSION",
      "X_V_HTML_WITH_CHILDREN": 54,
      "54": "X_V_HTML_WITH_CHILDREN",
      "X_V_TEXT_NO_EXPRESSION": 55,
      "55": "X_V_TEXT_NO_EXPRESSION",
      "X_V_TEXT_WITH_CHILDREN": 56,
      "56": "X_V_TEXT_WITH_CHILDREN",
      "X_V_MODEL_ON_INVALID_ELEMENT": 57,
      "57": "X_V_MODEL_ON_INVALID_ELEMENT",
      "X_V_MODEL_ARG_ON_ELEMENT": 58,
      "58": "X_V_MODEL_ARG_ON_ELEMENT",
      "X_V_MODEL_ON_FILE_INPUT_ELEMENT": 59,
      "59": "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
      "X_V_MODEL_UNNECESSARY_VALUE": 60,
      "60": "X_V_MODEL_UNNECESSARY_VALUE",
      "X_V_SHOW_NO_EXPRESSION": 61,
      "61": "X_V_SHOW_NO_EXPRESSION",
      "X_TRANSITION_INVALID_CHILDREN": 62,
      "62": "X_TRANSITION_INVALID_CHILDREN",
      "X_IGNORED_SIDE_EFFECT_TAG": 63,
      "63": "X_IGNORED_SIDE_EFFECT_TAG",
      "__EXTEND_POINT__": 64,
      "64": "__EXTEND_POINT__"
    };
    DOMErrorMessages = {
      [53]: `v-html is missing expression.`,
      [54]: `v-html will override element children.`,
      [55]: `v-text is missing expression.`,
      [56]: `v-text will override element children.`,
      [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [58]: `v-model argument is not supported on plain elements.`,
      [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [61]: `v-show is missing expression.`,
      [62]: `<Transition> expects exactly one child element or component.`,
      [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
    };
    transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(53, loc)
        );
      }
      if (node.children.length) {
        context.onError(
          createDOMCompilerError(54, loc)
        );
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`innerHTML`, true, loc),
            exp || createSimpleExpression("", true)
          )
        ]
      };
    };
    transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(55, loc)
        );
      }
      if (node.children.length) {
        context.onError(
          createDOMCompilerError(56, loc)
        );
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`textContent`, true),
            exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
              context.helperString(TO_DISPLAY_STRING),
              [exp],
              loc
            ) : createSimpleExpression("", true)
          )
        ]
      };
    };
    transformModel2 = (dir, node, context) => {
      const baseResult = transformModel(dir, node, context);
      if (!baseResult.props.length || node.tagType === 1) {
        return baseResult;
      }
      if (dir.arg) {
        context.onError(
          createDOMCompilerError(
            58,
            dir.arg.loc
          )
        );
      }
      function checkDuplicatedValue() {
        const value = findDir(node, "bind");
        if (value && isStaticArgOf(value.arg, "value")) {
          context.onError(
            createDOMCompilerError(
              60,
              value.loc
            )
          );
        }
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === "input" || isCustomElement) {
          const type = findProp(node, `type`);
          if (type) {
            if (type.type === 7) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else if (type.value) {
              switch (type.value.content) {
                case "radio":
                  directiveToUse = V_MODEL_RADIO;
                  break;
                case "checkbox":
                  directiveToUse = V_MODEL_CHECKBOX;
                  break;
                case "file":
                  isInvalidType = true;
                  context.onError(
                    createDOMCompilerError(
                      59,
                      dir.loc
                    )
                  );
                  break;
                default:
                  checkDuplicatedValue();
                  break;
              }
            }
          } else if (hasDynamicKeyVBind(node)) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else {
            checkDuplicatedValue();
          }
        } else if (tag === "select") {
          directiveToUse = V_MODEL_SELECT;
        } else {
          checkDuplicatedValue();
        }
        if (!isInvalidType) {
          baseResult.needRuntime = context.helper(directiveToUse);
        }
      } else {
        context.onError(
          createDOMCompilerError(
            57,
            dir.loc
          )
        );
      }
      baseResult.props = baseResult.props.filter(
        (p) => !(p.key.type === 4 && p.key.content === "modelValue")
      );
      return baseResult;
    };
    isEventOptionModifier = makeMap(`passive,once,capture`);
    isNonKeyModifier = makeMap(
      // event propagation management
      `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
    );
    maybeKeyModifier = makeMap("left,right");
    isKeyboardEvent = makeMap(`onkeyup,onkeydown,onkeypress`);
    resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i].content;
        if (modifier === "native" && checkCompatEnabled(
          "COMPILER_V_ON_NATIVE",
          context,
          loc
        )) {
          eventOptionModifiers.push(modifier);
        } else if (isEventOptionModifier(modifier)) {
          eventOptionModifiers.push(modifier);
        } else {
          if (maybeKeyModifier(modifier)) {
            if (isStaticExp(key)) {
              if (isKeyboardEvent(key.content.toLowerCase())) {
                keyModifiers.push(modifier);
              } else {
                nonKeyModifiers.push(modifier);
              }
            } else {
              keyModifiers.push(modifier);
              nonKeyModifiers.push(modifier);
            }
          } else {
            if (isNonKeyModifier(modifier)) {
              nonKeyModifiers.push(modifier);
            } else {
              keyModifiers.push(modifier);
            }
          }
        }
      }
      return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
      };
    };
    transformClick = (key, event) => {
      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
      return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ]) : key;
    };
    transformOn2 = (dir, node, context) => {
      return transformOn(dir, node, context, (baseResult) => {
        const { modifiers } = dir;
        if (!modifiers.length) return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        if (nonKeyModifiers.includes("right")) {
          key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes("middle")) {
          key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
            handlerExp,
            JSON.stringify(nonKeyModifiers)
          ]);
        }
        if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
        (!isStaticExp(key) || isKeyboardEvent(key.content.toLowerCase()))) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
            handlerExp,
            JSON.stringify(keyModifiers)
          ]);
        }
        if (eventOptionModifiers.length) {
          const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
          key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
          props: [createObjectProperty(key, handlerExp)]
        };
      });
    };
    transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(61, loc)
        );
      }
      return {
        props: [],
        needRuntime: context.helper(V_SHOW)
      };
    };
    transformTransition = (node, context) => {
      if (node.type === 1 && node.tagType === 1) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
          return () => {
            if (!node.children.length) {
              return;
            }
            if (hasMultipleChildren(node)) {
              context.onError(
                createDOMCompilerError(
                  62,
                  {
                    start: node.children[0].loc.start,
                    end: node.children[node.children.length - 1].loc.end,
                    source: ""
                  }
                )
              );
            }
            const child = node.children[0];
            if (child.type === 1) {
              for (const p of child.props) {
                if (p.type === 7 && p.name === "show") {
                  node.props.push({
                    type: 6,
                    name: "persisted",
                    nameLoc: node.loc,
                    value: void 0,
                    loc: node.loc
                  });
                }
              }
            }
          };
        }
      }
    };
    ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
        context.onError(
          createDOMCompilerError(
            63,
            node.loc
          )
        );
        context.removeNode();
      }
    };
    headings = /* @__PURE__ */ new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
    emptySet = /* @__PURE__ */ new Set([]);
    onlyValidChildren = {
      head: /* @__PURE__ */ new Set([
        "base",
        "basefront",
        "bgsound",
        "link",
        "meta",
        "title",
        "noscript",
        "noframes",
        "style",
        "script",
        "template"
      ]),
      optgroup: /* @__PURE__ */ new Set(["option"]),
      select: /* @__PURE__ */ new Set(["optgroup", "option", "hr"]),
      // table
      table: /* @__PURE__ */ new Set(["caption", "colgroup", "tbody", "tfoot", "thead"]),
      tr: /* @__PURE__ */ new Set(["td", "th"]),
      colgroup: /* @__PURE__ */ new Set(["col"]),
      tbody: /* @__PURE__ */ new Set(["tr"]),
      thead: /* @__PURE__ */ new Set(["tr"]),
      tfoot: /* @__PURE__ */ new Set(["tr"]),
      // these elements can not have any children elements
      script: emptySet,
      iframe: emptySet,
      option: emptySet,
      textarea: emptySet,
      style: emptySet,
      title: emptySet
    };
    onlyValidParents = {
      // sections
      html: emptySet,
      body: /* @__PURE__ */ new Set(["html"]),
      head: /* @__PURE__ */ new Set(["html"]),
      // table
      td: /* @__PURE__ */ new Set(["tr"]),
      colgroup: /* @__PURE__ */ new Set(["table"]),
      caption: /* @__PURE__ */ new Set(["table"]),
      tbody: /* @__PURE__ */ new Set(["table"]),
      tfoot: /* @__PURE__ */ new Set(["table"]),
      col: /* @__PURE__ */ new Set(["colgroup"]),
      th: /* @__PURE__ */ new Set(["tr"]),
      thead: /* @__PURE__ */ new Set(["table"]),
      tr: /* @__PURE__ */ new Set(["tbody", "thead", "tfoot"]),
      // data list
      dd: /* @__PURE__ */ new Set(["dl", "div"]),
      dt: /* @__PURE__ */ new Set(["dl", "div"]),
      // other
      figcaption: /* @__PURE__ */ new Set(["figure"]),
      // li: new Set(["ul", "ol"]),
      summary: /* @__PURE__ */ new Set(["details"]),
      area: /* @__PURE__ */ new Set(["map"])
    };
    knownInvalidChildren = {
      p: /* @__PURE__ */ new Set([
        "address",
        "article",
        "aside",
        "blockquote",
        "center",
        "details",
        "dialog",
        "dir",
        "div",
        "dl",
        "fieldset",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "hr",
        "li",
        "main",
        "nav",
        "menu",
        "ol",
        "p",
        "pre",
        "section",
        "table",
        "ul"
      ]),
      svg: /* @__PURE__ */ new Set([
        "b",
        "blockquote",
        "br",
        "code",
        "dd",
        "div",
        "dl",
        "dt",
        "em",
        "embed",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hr",
        "i",
        "img",
        "li",
        "menu",
        "meta",
        "ol",
        "p",
        "pre",
        "ruby",
        "s",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "table",
        "u",
        "ul",
        "var"
      ])
    };
    knownInvalidParents = {
      a: /* @__PURE__ */ new Set(["a"]),
      button: /* @__PURE__ */ new Set(["button"]),
      dd: /* @__PURE__ */ new Set(["dd", "dt"]),
      dt: /* @__PURE__ */ new Set(["dd", "dt"]),
      form: /* @__PURE__ */ new Set(["form"]),
      li: /* @__PURE__ */ new Set(["li"]),
      h1: headings,
      h2: headings,
      h3: headings,
      h4: headings,
      h5: headings,
      h6: headings
    };
    validateHtmlNesting = (node, context) => {
      if (node.type === 1 && node.tagType === 0 && context.parent && context.parent.type === 1 && context.parent.tagType === 0 && !isValidHTMLNesting(context.parent.tag, node.tag)) {
        const error = new SyntaxError(
          `<${node.tag}> cannot be child of <${context.parent.tag}>, according to HTML specifications. This can cause hydration errors or potentially disrupt future functionality.`
        );
        error.loc = node.loc;
        context.onWarn(error);
      }
    };
    DOMNodeTransforms = [
      transformStyle,
      ...true ? [transformTransition, validateHtmlNesting] : []
    ];
    DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel2,
      // override compiler-core
      on: transformOn2,
      // override compiler-core
      show: transformShow
    };
  }
});

// node_modules/vue/dist/vue.cjs.js
var require_vue_cjs = __commonJS({
  "node_modules/vue/dist/vue.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var compilerDom = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var runtimeDom = (init_runtime_dom_esm_bundler(), __toCommonJS(runtime_dom_esm_bundler_exports));
    var shared = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        for (var k in e) {
          n[k] = e[k];
        }
      }
      n.default = e;
      return Object.freeze(n);
    }
    var runtimeDom__namespace = _interopNamespaceDefault(runtimeDom);
    var compileCache = /* @__PURE__ */ Object.create(null);
    function compileToFunction(template, options) {
      if (!shared.isString(template)) {
        if (template.nodeType) {
          template = template.innerHTML;
        } else {
          runtimeDom.warn(`invalid template option: `, template);
          return shared.NOOP;
        }
      }
      const key = shared.genCacheKey(template, options);
      const cached = compileCache[key];
      if (cached) {
        return cached;
      }
      if (template[0] === "#") {
        const el = document.querySelector(template);
        if (!el) {
          runtimeDom.warn(`Template element not found or is empty: ${template}`);
        }
        template = el ? el.innerHTML : ``;
      }
      const opts = shared.extend(
        {
          hoistStatic: true,
          onError,
          onWarn: (e) => onError(e, true)
        },
        options
      );
      if (!opts.isCustomElement && typeof customElements !== "undefined") {
        opts.isCustomElement = (tag) => !!customElements.get(tag);
      }
      const { code } = compilerDom.compile(template, opts);
      function onError(err, asWarning = false) {
        const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
        const codeFrame = err.loc && shared.generateCodeFrame(
          template,
          err.loc.start.offset,
          err.loc.end.offset
        );
        runtimeDom.warn(codeFrame ? `${message}
${codeFrame}` : message);
      }
      const render = new Function("Vue", code)(runtimeDom__namespace);
      render._rc = true;
      return compileCache[key] = render;
    }
    runtimeDom.registerRuntimeCompiler(compileToFunction);
    exports.compile = compileToFunction;
    Object.keys(runtimeDom).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = runtimeDom[k];
    });
  }
});

// node_modules/vue/index.js
var require_vue = __commonJS({
  "node_modules/vue/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_vue_cjs();
    }
  }
});

// node_modules/vue-demi/lib/index.cjs
var require_lib = __commonJS({
  "node_modules/vue-demi/lib/index.cjs"(exports) {
    var Vue = require_vue();
    Object.keys(Vue).forEach(function(key) {
      exports[key] = Vue[key];
    });
    exports.set = function(target, key, val) {
      if (Array.isArray(target)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        return val;
      }
      target[key] = val;
      return val;
    };
    exports.del = function(target, key) {
      if (Array.isArray(target)) {
        target.splice(key, 1);
        return;
      }
      delete target[key];
    };
    exports.Vue = Vue;
    exports.Vue2 = void 0;
    exports.isVue2 = false;
    exports.isVue3 = true;
    exports.install = function() {
    };
  }
});

// node_modules/@vue-office/docx/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@vue-office/docx/lib/index.js"(exports, module) {
    (function(dt, ft) {
      typeof exports == "object" && typeof module != "undefined" ? module.exports = ft(require_lib(), require_vue()) : typeof define == "function" && define.amd ? define(["vue-demi", "vue"], ft) : (dt = typeof globalThis != "undefined" ? globalThis : dt || self, dt["vue-office-docx"] = ft(dt.VueDemi, dt.Vue));
    })(exports, function(dt, ft) {
      "use strict";
      var gn = Object.defineProperty, bn = Object.defineProperties;
      var vn = Object.getOwnPropertyDescriptors;
      var Re = Object.getOwnPropertySymbols;
      var kn = Object.prototype.hasOwnProperty, yn = Object.prototype.propertyIsEnumerable;
      var Me = (dt2, ft2, vt2) => ft2 in dt2 ? gn(dt2, ft2, { enumerable: true, configurable: true, writable: true, value: vt2 }) : dt2[ft2] = vt2, _t = (dt2, ft2) => {
        for (var vt2 in ft2 || (ft2 = {})) kn.call(ft2, vt2) && Me(dt2, vt2, ft2[vt2]);
        if (Re) for (var vt2 of Re(ft2)) yn.call(ft2, vt2) && Me(dt2, vt2, ft2[vt2]);
        return dt2;
      }, Wt = (dt2, ft2) => bn(dt2, vn(ft2));
      var wt = (dt2, ft2, vt2) => new Promise((Jt2, Bt2) => {
        var Ht2 = (ot2) => {
          try {
            It2(vt2.next(ot2));
          } catch (Ot2) {
            Bt2(Ot2);
          }
        }, Qt2 = (ot2) => {
          try {
            It2(vt2.throw(ot2));
          } catch (Ot2) {
            Bt2(Ot2);
          }
        }, It2 = (ot2) => ot2.done ? Jt2(ot2.value) : Promise.resolve(ot2.value).then(Ht2, Qt2);
        It2((vt2 = vt2.apply(dt2, ft2)).next());
      });
      typeof window.setImmediate == "undefined" && (window.setImmediate = function(i, ...e) {
        setTimeout(() => i(e));
      });
      var vt = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
      function Jt(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
      }
      function Bt(i) {
        throw new Error('Could not dynamically require "' + i + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
      }
      var Ht = { exports: {} };
      (function(i, e) {
        (function(t) {
          i.exports = t();
        })(function() {
          return function t(r, n, a) {
            function l(b, y) {
              if (!n[b]) {
                if (!r[b]) {
                  var _ = typeof Bt == "function" && Bt;
                  if (!y && _) return _(b, true);
                  if (o) return o(b, true);
                  var w = new Error("Cannot find module '" + b + "'");
                  throw w.code = "MODULE_NOT_FOUND", w;
                }
                var d = n[b] = { exports: {} };
                r[b][0].call(d.exports, function(k) {
                  var h = r[b][1][k];
                  return l(h || k);
                }, d, d.exports, t, r, n, a);
              }
              return n[b].exports;
            }
            for (var o = typeof Bt == "function" && Bt, u = 0; u < a.length; u++) l(a[u]);
            return l;
          }({ 1: [function(t, r, n) {
            var a = t("./utils"), l = t("./support"), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            n.encode = function(u) {
              for (var b, y, _, w, d, k, h, m = [], f = 0, v = u.length, C = v, A = a.getTypeOf(u) !== "string"; f < u.length; ) C = v - f, _ = A ? (b = u[f++], y = f < v ? u[f++] : 0, f < v ? u[f++] : 0) : (b = u.charCodeAt(f++), y = f < v ? u.charCodeAt(f++) : 0, f < v ? u.charCodeAt(f++) : 0), w = b >> 2, d = (3 & b) << 4 | y >> 4, k = 1 < C ? (15 & y) << 2 | _ >> 6 : 64, h = 2 < C ? 63 & _ : 64, m.push(o.charAt(w) + o.charAt(d) + o.charAt(k) + o.charAt(h));
              return m.join("");
            }, n.decode = function(u) {
              var b, y, _, w, d, k, h = 0, m = 0, f = "data:";
              if (u.substr(0, f.length) === f) throw new Error("Invalid base64 input, it looks like a data url.");
              var v, C = 3 * (u = u.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
              if (u.charAt(u.length - 1) === o.charAt(64) && C--, u.charAt(u.length - 2) === o.charAt(64) && C--, C % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
              for (v = l.uint8array ? new Uint8Array(0 | C) : new Array(0 | C); h < u.length; ) b = o.indexOf(u.charAt(h++)) << 2 | (w = o.indexOf(u.charAt(h++))) >> 4, y = (15 & w) << 4 | (d = o.indexOf(u.charAt(h++))) >> 2, _ = (3 & d) << 6 | (k = o.indexOf(u.charAt(h++))), v[m++] = b, d !== 64 && (v[m++] = y), k !== 64 && (v[m++] = _);
              return v;
            };
          }, { "./support": 30, "./utils": 32 }], 2: [function(t, r, n) {
            var a = t("./external"), l = t("./stream/DataWorker"), o = t("./stream/Crc32Probe"), u = t("./stream/DataLengthProbe");
            function b(y, _, w, d, k) {
              this.compressedSize = y, this.uncompressedSize = _, this.crc32 = w, this.compression = d, this.compressedContent = k;
            }
            b.prototype = { getContentWorker: function() {
              var y = new l(a.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new u("data_length")), _ = this;
              return y.on("end", function() {
                if (this.streamInfo.data_length !== _.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
              }), y;
            }, getCompressedWorker: function() {
              return new l(a.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
            } }, b.createWorkerFrom = function(y, _, w) {
              return y.pipe(new o()).pipe(new u("uncompressedSize")).pipe(_.compressWorker(w)).pipe(new u("compressedSize")).withStreamInfo("compression", _);
            }, r.exports = b;
          }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(t, r, n) {
            var a = t("./stream/GenericWorker");
            n.STORE = { magic: "\0\0", compressWorker: function() {
              return new a("STORE compression");
            }, uncompressWorker: function() {
              return new a("STORE decompression");
            } }, n.DEFLATE = t("./flate");
          }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(t, r, n) {
            var a = t("./utils"), l = function() {
              for (var o, u = [], b = 0; b < 256; b++) {
                o = b;
                for (var y = 0; y < 8; y++) o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
                u[b] = o;
              }
              return u;
            }();
            r.exports = function(o, u) {
              return o !== void 0 && o.length ? a.getTypeOf(o) !== "string" ? function(b, y, _, w) {
                var d = l, k = w + _;
                b ^= -1;
                for (var h = w; h < k; h++) b = b >>> 8 ^ d[255 & (b ^ y[h])];
                return -1 ^ b;
              }(0 | u, o, o.length, 0) : function(b, y, _, w) {
                var d = l, k = w + _;
                b ^= -1;
                for (var h = w; h < k; h++) b = b >>> 8 ^ d[255 & (b ^ y.charCodeAt(h))];
                return -1 ^ b;
              }(0 | u, o, o.length, 0) : 0;
            };
          }, { "./utils": 32 }], 5: [function(t, r, n) {
            n.base64 = false, n.binary = false, n.dir = false, n.createFolders = true, n.date = null, n.compression = null, n.compressionOptions = null, n.comment = null, n.unixPermissions = null, n.dosPermissions = null;
          }, {}], 6: [function(t, r, n) {
            var a = null;
            a = typeof Promise != "undefined" ? Promise : t("lie"), r.exports = { Promise: a };
          }, { lie: 37 }], 7: [function(t, r, n) {
            var a = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Uint32Array != "undefined", l = t("pako"), o = t("./utils"), u = t("./stream/GenericWorker"), b = a ? "uint8array" : "array";
            function y(_, w) {
              u.call(this, "FlateWorker/" + _), this._pako = null, this._pakoAction = _, this._pakoOptions = w, this.meta = {};
            }
            n.magic = "\b\0", o.inherits(y, u), y.prototype.processChunk = function(_) {
              this.meta = _.meta, this._pako === null && this._createPako(), this._pako.push(o.transformTo(b, _.data), false);
            }, y.prototype.flush = function() {
              u.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true);
            }, y.prototype.cleanUp = function() {
              u.prototype.cleanUp.call(this), this._pako = null;
            }, y.prototype._createPako = function() {
              this._pako = new l[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
              var _ = this;
              this._pako.onData = function(w) {
                _.push({ data: w, meta: _.meta });
              };
            }, n.compressWorker = function(_) {
              return new y("Deflate", _);
            }, n.uncompressWorker = function() {
              return new y("Inflate", {});
            };
          }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(t, r, n) {
            function a(d, k) {
              var h, m = "";
              for (h = 0; h < k; h++) m += String.fromCharCode(255 & d), d >>>= 8;
              return m;
            }
            function l(d, k, h, m, f, v) {
              var C, A, E = d.file, D = d.compression, I = v !== b.utf8encode, W = o.transformTo("string", v(E.name)), T = o.transformTo("string", b.utf8encode(E.name)), X = E.comment, Q = o.transformTo("string", v(X)), S = o.transformTo("string", b.utf8encode(X)), O = T.length !== E.name.length, c = S.length !== X.length, L = "", et = "", $ = "", rt = E.dir, H = E.date, tt = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
              k && !h || (tt.crc32 = d.crc32, tt.compressedSize = d.compressedSize, tt.uncompressedSize = d.uncompressedSize);
              var R = 0;
              k && (R |= 8), I || !O && !c || (R |= 2048);
              var B = 0, J = 0;
              rt && (B |= 16), f === "UNIX" ? (J = 798, B |= function(G, mt) {
                var yt = G;
                return G || (yt = mt ? 16893 : 33204), (65535 & yt) << 16;
              }(E.unixPermissions, rt)) : (J = 20, B |= function(G) {
                return 63 & (G || 0);
              }(E.dosPermissions)), C = H.getUTCHours(), C <<= 6, C |= H.getUTCMinutes(), C <<= 5, C |= H.getUTCSeconds() / 2, A = H.getUTCFullYear() - 1980, A <<= 4, A |= H.getUTCMonth() + 1, A <<= 5, A |= H.getUTCDate(), O && (et = a(1, 1) + a(y(W), 4) + T, L += "up" + a(et.length, 2) + et), c && ($ = a(1, 1) + a(y(Q), 4) + S, L += "uc" + a($.length, 2) + $);
              var q = "";
              return q += `
\0`, q += a(R, 2), q += D.magic, q += a(C, 2), q += a(A, 2), q += a(tt.crc32, 4), q += a(tt.compressedSize, 4), q += a(tt.uncompressedSize, 4), q += a(W.length, 2), q += a(L.length, 2), { fileRecord: _.LOCAL_FILE_HEADER + q + W + L, dirRecord: _.CENTRAL_FILE_HEADER + a(J, 2) + q + a(Q.length, 2) + "\0\0\0\0" + a(B, 4) + a(m, 4) + W + L + Q };
            }
            var o = t("../utils"), u = t("../stream/GenericWorker"), b = t("../utf8"), y = t("../crc32"), _ = t("../signature");
            function w(d, k, h, m) {
              u.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = k, this.zipPlatform = h, this.encodeFileName = m, this.streamFiles = d, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
            }
            o.inherits(w, u), w.prototype.push = function(d) {
              var k = d.meta.percent || 0, h = this.entriesCount, m = this._sources.length;
              this.accumulate ? this.contentBuffer.push(d) : (this.bytesWritten += d.data.length, u.prototype.push.call(this, { data: d.data, meta: { currentFile: this.currentFile, percent: h ? (k + 100 * (h - m - 1)) / h : 100 } }));
            }, w.prototype.openedSource = function(d) {
              this.currentSourceOffset = this.bytesWritten, this.currentFile = d.file.name;
              var k = this.streamFiles && !d.file.dir;
              if (k) {
                var h = l(d, k, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                this.push({ data: h.fileRecord, meta: { percent: 0 } });
              } else this.accumulate = true;
            }, w.prototype.closedSource = function(d) {
              this.accumulate = false;
              var k = this.streamFiles && !d.file.dir, h = l(d, k, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
              if (this.dirRecords.push(h.dirRecord), k) this.push({ data: function(m) {
                return _.DATA_DESCRIPTOR + a(m.crc32, 4) + a(m.compressedSize, 4) + a(m.uncompressedSize, 4);
              }(d), meta: { percent: 100 } });
              else for (this.push({ data: h.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
              this.currentFile = null;
            }, w.prototype.flush = function() {
              for (var d = this.bytesWritten, k = 0; k < this.dirRecords.length; k++) this.push({ data: this.dirRecords[k], meta: { percent: 100 } });
              var h = this.bytesWritten - d, m = function(f, v, C, A, E) {
                var D = o.transformTo("string", E(A));
                return _.CENTRAL_DIRECTORY_END + "\0\0\0\0" + a(f, 2) + a(f, 2) + a(v, 4) + a(C, 4) + a(D.length, 2) + D;
              }(this.dirRecords.length, h, d, this.zipComment, this.encodeFileName);
              this.push({ data: m, meta: { percent: 100 } });
            }, w.prototype.prepareNextSource = function() {
              this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
            }, w.prototype.registerPrevious = function(d) {
              this._sources.push(d);
              var k = this;
              return d.on("data", function(h) {
                k.processChunk(h);
              }), d.on("end", function() {
                k.closedSource(k.previous.streamInfo), k._sources.length ? k.prepareNextSource() : k.end();
              }), d.on("error", function(h) {
                k.error(h);
              }), this;
            }, w.prototype.resume = function() {
              return !!u.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
            }, w.prototype.error = function(d) {
              var k = this._sources;
              if (!u.prototype.error.call(this, d)) return false;
              for (var h = 0; h < k.length; h++) try {
                k[h].error(d);
              } catch (m) {
              }
              return true;
            }, w.prototype.lock = function() {
              u.prototype.lock.call(this);
              for (var d = this._sources, k = 0; k < d.length; k++) d[k].lock();
            }, r.exports = w;
          }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(t, r, n) {
            var a = t("../compressions"), l = t("./ZipFileWorker");
            n.generateWorker = function(o, u, b) {
              var y = new l(u.streamFiles, b, u.platform, u.encodeFileName), _ = 0;
              try {
                o.forEach(function(w, d) {
                  _++;
                  var k = function(v, C) {
                    var A = v || C, E = a[A];
                    if (!E) throw new Error(A + " is not a valid compression method !");
                    return E;
                  }(d.options.compression, u.compression), h = d.options.compressionOptions || u.compressionOptions || {}, m = d.dir, f = d.date;
                  d._compressWorker(k, h).withStreamInfo("file", { name: w, dir: m, date: f, comment: d.comment || "", unixPermissions: d.unixPermissions, dosPermissions: d.dosPermissions }).pipe(y);
                }), y.entriesCount = _;
              } catch (w) {
                y.error(w);
              }
              return y;
            };
          }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(t, r, n) {
            function a() {
              if (!(this instanceof a)) return new a();
              if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
              this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
                var l = new a();
                for (var o in this) typeof this[o] != "function" && (l[o] = this[o]);
                return l;
              };
            }
            (a.prototype = t("./object")).loadAsync = t("./load"), a.support = t("./support"), a.defaults = t("./defaults"), a.version = "3.10.1", a.loadAsync = function(l, o) {
              return new a().loadAsync(l, o);
            }, a.external = t("./external"), r.exports = a;
          }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(t, r, n) {
            var a = t("./utils"), l = t("./external"), o = t("./utf8"), u = t("./zipEntries"), b = t("./stream/Crc32Probe"), y = t("./nodejsUtils");
            function _(w) {
              return new l.Promise(function(d, k) {
                var h = w.decompressed.getContentWorker().pipe(new b());
                h.on("error", function(m) {
                  k(m);
                }).on("end", function() {
                  h.streamInfo.crc32 !== w.decompressed.crc32 ? k(new Error("Corrupted zip : CRC32 mismatch")) : d();
                }).resume();
              });
            }
            r.exports = function(w, d) {
              var k = this;
              return d = a.extend(d || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: o.utf8decode }), y.isNode && y.isStream(w) ? l.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : a.prepareContent("the loaded zip file", w, true, d.optimizedBinaryString, d.base64).then(function(h) {
                var m = new u(d);
                return m.load(h), m;
              }).then(function(h) {
                var m = [l.Promise.resolve(h)], f = h.files;
                if (d.checkCRC32) for (var v = 0; v < f.length; v++) m.push(_(f[v]));
                return l.Promise.all(m);
              }).then(function(h) {
                for (var m = h.shift(), f = m.files, v = 0; v < f.length; v++) {
                  var C = f[v], A = C.fileNameStr, E = a.resolve(C.fileNameStr);
                  k.file(E, C.decompressed, { binary: true, optimizedBinaryString: true, date: C.date, dir: C.dir, comment: C.fileCommentStr.length ? C.fileCommentStr : null, unixPermissions: C.unixPermissions, dosPermissions: C.dosPermissions, createFolders: d.createFolders }), C.dir || (k.file(E).unsafeOriginalName = A);
                }
                return m.zipComment.length && (k.comment = m.zipComment), k;
              });
            };
          }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(t, r, n) {
            var a = t("../utils"), l = t("../stream/GenericWorker");
            function o(u, b) {
              l.call(this, "Nodejs stream input adapter for " + u), this._upstreamEnded = false, this._bindStream(b);
            }
            a.inherits(o, l), o.prototype._bindStream = function(u) {
              var b = this;
              (this._stream = u).pause(), u.on("data", function(y) {
                b.push({ data: y, meta: { percent: 0 } });
              }).on("error", function(y) {
                b.isPaused ? this.generatedError = y : b.error(y);
              }).on("end", function() {
                b.isPaused ? b._upstreamEnded = true : b.end();
              });
            }, o.prototype.pause = function() {
              return !!l.prototype.pause.call(this) && (this._stream.pause(), true);
            }, o.prototype.resume = function() {
              return !!l.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
            }, r.exports = o;
          }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(t, r, n) {
            var a = t("readable-stream").Readable;
            function l(o, u, b) {
              a.call(this, u), this._helper = o;
              var y = this;
              o.on("data", function(_, w) {
                y.push(_) || y._helper.pause(), b && b(w);
              }).on("error", function(_) {
                y.emit("error", _);
              }).on("end", function() {
                y.push(null);
              });
            }
            t("../utils").inherits(l, a), l.prototype._read = function() {
              this._helper.resume();
            }, r.exports = l;
          }, { "../utils": 32, "readable-stream": 16 }], 14: [function(t, r, n) {
            r.exports = { isNode: typeof Buffer != "undefined", newBufferFrom: function(a, l) {
              if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(a, l);
              if (typeof a == "number") throw new Error('The "data" argument must not be a number');
              return new Buffer(a, l);
            }, allocBuffer: function(a) {
              if (Buffer.alloc) return Buffer.alloc(a);
              var l = new Buffer(a);
              return l.fill(0), l;
            }, isBuffer: function(a) {
              return Buffer.isBuffer(a);
            }, isStream: function(a) {
              return a && typeof a.on == "function" && typeof a.pause == "function" && typeof a.resume == "function";
            } };
          }, {}], 15: [function(t, r, n) {
            function a(E, D, I) {
              var W, T = o.getTypeOf(D), X = o.extend(I || {}, y);
              X.date = X.date || /* @__PURE__ */ new Date(), X.compression !== null && (X.compression = X.compression.toUpperCase()), typeof X.unixPermissions == "string" && (X.unixPermissions = parseInt(X.unixPermissions, 8)), X.unixPermissions && 16384 & X.unixPermissions && (X.dir = true), X.dosPermissions && 16 & X.dosPermissions && (X.dir = true), X.dir && (E = f(E)), X.createFolders && (W = m(E)) && v.call(this, W, true);
              var Q = T === "string" && X.binary === false && X.base64 === false;
              I && I.binary !== void 0 || (X.binary = !Q), (D instanceof _ && D.uncompressedSize === 0 || X.dir || !D || D.length === 0) && (X.base64 = false, X.binary = true, D = "", X.compression = "STORE", T = "string");
              var S = null;
              S = D instanceof _ || D instanceof u ? D : k.isNode && k.isStream(D) ? new h(E, D) : o.prepareContent(E, D, X.binary, X.optimizedBinaryString, X.base64);
              var O = new w(E, S, X);
              this.files[E] = O;
            }
            var l = t("./utf8"), o = t("./utils"), u = t("./stream/GenericWorker"), b = t("./stream/StreamHelper"), y = t("./defaults"), _ = t("./compressedObject"), w = t("./zipObject"), d = t("./generate"), k = t("./nodejsUtils"), h = t("./nodejs/NodejsStreamInputAdapter"), m = function(E) {
              E.slice(-1) === "/" && (E = E.substring(0, E.length - 1));
              var D = E.lastIndexOf("/");
              return 0 < D ? E.substring(0, D) : "";
            }, f = function(E) {
              return E.slice(-1) !== "/" && (E += "/"), E;
            }, v = function(E, D) {
              return D = D !== void 0 ? D : y.createFolders, E = f(E), this.files[E] || a.call(this, E, null, { dir: true, createFolders: D }), this.files[E];
            };
            function C(E) {
              return Object.prototype.toString.call(E) === "[object RegExp]";
            }
            var A = { load: function() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, forEach: function(E) {
              var D, I, W;
              for (D in this.files) W = this.files[D], (I = D.slice(this.root.length, D.length)) && D.slice(0, this.root.length) === this.root && E(I, W);
            }, filter: function(E) {
              var D = [];
              return this.forEach(function(I, W) {
                E(I, W) && D.push(W);
              }), D;
            }, file: function(E, D, I) {
              if (arguments.length !== 1) return E = this.root + E, a.call(this, E, D, I), this;
              if (C(E)) {
                var W = E;
                return this.filter(function(X, Q) {
                  return !Q.dir && W.test(X);
                });
              }
              var T = this.files[this.root + E];
              return T && !T.dir ? T : null;
            }, folder: function(E) {
              if (!E) return this;
              if (C(E)) return this.filter(function(T, X) {
                return X.dir && E.test(T);
              });
              var D = this.root + E, I = v.call(this, D), W = this.clone();
              return W.root = I.name, W;
            }, remove: function(E) {
              E = this.root + E;
              var D = this.files[E];
              if (D || (E.slice(-1) !== "/" && (E += "/"), D = this.files[E]), D && !D.dir) delete this.files[E];
              else for (var I = this.filter(function(T, X) {
                return X.name.slice(0, E.length) === E;
              }), W = 0; W < I.length; W++) delete this.files[I[W].name];
              return this;
            }, generate: function() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, generateInternalStream: function(E) {
              var D, I = {};
              try {
                if ((I = o.extend(E || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: l.utf8encode })).type = I.type.toLowerCase(), I.compression = I.compression.toUpperCase(), I.type === "binarystring" && (I.type = "string"), !I.type) throw new Error("No output type specified.");
                o.checkSupport(I.type), I.platform !== "darwin" && I.platform !== "freebsd" && I.platform !== "linux" && I.platform !== "sunos" || (I.platform = "UNIX"), I.platform === "win32" && (I.platform = "DOS");
                var W = I.comment || this.comment || "";
                D = d.generateWorker(this, I, W);
              } catch (T) {
                (D = new u("error")).error(T);
              }
              return new b(D, I.type || "string", I.mimeType);
            }, generateAsync: function(E, D) {
              return this.generateInternalStream(E).accumulate(D);
            }, generateNodeStream: function(E, D) {
              return (E = E || {}).type || (E.type = "nodebuffer"), this.generateInternalStream(E).toNodejsStream(D);
            } };
            r.exports = A;
          }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(t, r, n) {
            r.exports = t("stream");
          }, { stream: void 0 }], 17: [function(t, r, n) {
            var a = t("./DataReader");
            function l(o) {
              a.call(this, o);
              for (var u = 0; u < this.data.length; u++) o[u] = 255 & o[u];
            }
            t("../utils").inherits(l, a), l.prototype.byteAt = function(o) {
              return this.data[this.zero + o];
            }, l.prototype.lastIndexOfSignature = function(o) {
              for (var u = o.charCodeAt(0), b = o.charCodeAt(1), y = o.charCodeAt(2), _ = o.charCodeAt(3), w = this.length - 4; 0 <= w; --w) if (this.data[w] === u && this.data[w + 1] === b && this.data[w + 2] === y && this.data[w + 3] === _) return w - this.zero;
              return -1;
            }, l.prototype.readAndCheckSignature = function(o) {
              var u = o.charCodeAt(0), b = o.charCodeAt(1), y = o.charCodeAt(2), _ = o.charCodeAt(3), w = this.readData(4);
              return u === w[0] && b === w[1] && y === w[2] && _ === w[3];
            }, l.prototype.readData = function(o) {
              if (this.checkOffset(o), o === 0) return [];
              var u = this.data.slice(this.zero + this.index, this.zero + this.index + o);
              return this.index += o, u;
            }, r.exports = l;
          }, { "../utils": 32, "./DataReader": 18 }], 18: [function(t, r, n) {
            var a = t("../utils");
            function l(o) {
              this.data = o, this.length = o.length, this.index = 0, this.zero = 0;
            }
            l.prototype = { checkOffset: function(o) {
              this.checkIndex(this.index + o);
            }, checkIndex: function(o) {
              if (this.length < this.zero + o || o < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + o + "). Corrupted zip ?");
            }, setIndex: function(o) {
              this.checkIndex(o), this.index = o;
            }, skip: function(o) {
              this.setIndex(this.index + o);
            }, byteAt: function() {
            }, readInt: function(o) {
              var u, b = 0;
              for (this.checkOffset(o), u = this.index + o - 1; u >= this.index; u--) b = (b << 8) + this.byteAt(u);
              return this.index += o, b;
            }, readString: function(o) {
              return a.transformTo("string", this.readData(o));
            }, readData: function() {
            }, lastIndexOfSignature: function() {
            }, readAndCheckSignature: function() {
            }, readDate: function() {
              var o = this.readInt(4);
              return new Date(Date.UTC(1980 + (o >> 25 & 127), (o >> 21 & 15) - 1, o >> 16 & 31, o >> 11 & 31, o >> 5 & 63, (31 & o) << 1));
            } }, r.exports = l;
          }, { "../utils": 32 }], 19: [function(t, r, n) {
            var a = t("./Uint8ArrayReader");
            function l(o) {
              a.call(this, o);
            }
            t("../utils").inherits(l, a), l.prototype.readData = function(o) {
              this.checkOffset(o);
              var u = this.data.slice(this.zero + this.index, this.zero + this.index + o);
              return this.index += o, u;
            }, r.exports = l;
          }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(t, r, n) {
            var a = t("./DataReader");
            function l(o) {
              a.call(this, o);
            }
            t("../utils").inherits(l, a), l.prototype.byteAt = function(o) {
              return this.data.charCodeAt(this.zero + o);
            }, l.prototype.lastIndexOfSignature = function(o) {
              return this.data.lastIndexOf(o) - this.zero;
            }, l.prototype.readAndCheckSignature = function(o) {
              return o === this.readData(4);
            }, l.prototype.readData = function(o) {
              this.checkOffset(o);
              var u = this.data.slice(this.zero + this.index, this.zero + this.index + o);
              return this.index += o, u;
            }, r.exports = l;
          }, { "../utils": 32, "./DataReader": 18 }], 21: [function(t, r, n) {
            var a = t("./ArrayReader");
            function l(o) {
              a.call(this, o);
            }
            t("../utils").inherits(l, a), l.prototype.readData = function(o) {
              if (this.checkOffset(o), o === 0) return new Uint8Array(0);
              var u = this.data.subarray(this.zero + this.index, this.zero + this.index + o);
              return this.index += o, u;
            }, r.exports = l;
          }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(t, r, n) {
            var a = t("../utils"), l = t("../support"), o = t("./ArrayReader"), u = t("./StringReader"), b = t("./NodeBufferReader"), y = t("./Uint8ArrayReader");
            r.exports = function(_) {
              var w = a.getTypeOf(_);
              return a.checkSupport(w), w !== "string" || l.uint8array ? w === "nodebuffer" ? new b(_) : l.uint8array ? new y(a.transformTo("uint8array", _)) : new o(a.transformTo("array", _)) : new u(_);
            };
          }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(t, r, n) {
            n.LOCAL_FILE_HEADER = "PK", n.CENTRAL_FILE_HEADER = "PK", n.CENTRAL_DIRECTORY_END = "PK", n.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", n.ZIP64_CENTRAL_DIRECTORY_END = "PK", n.DATA_DESCRIPTOR = "PK\x07\b";
          }, {}], 24: [function(t, r, n) {
            var a = t("./GenericWorker"), l = t("../utils");
            function o(u) {
              a.call(this, "ConvertWorker to " + u), this.destType = u;
            }
            l.inherits(o, a), o.prototype.processChunk = function(u) {
              this.push({ data: l.transformTo(this.destType, u.data), meta: u.meta });
            }, r.exports = o;
          }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(t, r, n) {
            var a = t("./GenericWorker"), l = t("../crc32");
            function o() {
              a.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
            }
            t("../utils").inherits(o, a), o.prototype.processChunk = function(u) {
              this.streamInfo.crc32 = l(u.data, this.streamInfo.crc32 || 0), this.push(u);
            }, r.exports = o;
          }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(t, r, n) {
            var a = t("../utils"), l = t("./GenericWorker");
            function o(u) {
              l.call(this, "DataLengthProbe for " + u), this.propName = u, this.withStreamInfo(u, 0);
            }
            a.inherits(o, l), o.prototype.processChunk = function(u) {
              if (u) {
                var b = this.streamInfo[this.propName] || 0;
                this.streamInfo[this.propName] = b + u.data.length;
              }
              l.prototype.processChunk.call(this, u);
            }, r.exports = o;
          }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(t, r, n) {
            var a = t("../utils"), l = t("./GenericWorker");
            function o(u) {
              l.call(this, "DataWorker");
              var b = this;
              this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, u.then(function(y) {
                b.dataIsReady = true, b.data = y, b.max = y && y.length || 0, b.type = a.getTypeOf(y), b.isPaused || b._tickAndRepeat();
              }, function(y) {
                b.error(y);
              });
            }
            a.inherits(o, l), o.prototype.cleanUp = function() {
              l.prototype.cleanUp.call(this), this.data = null;
            }, o.prototype.resume = function() {
              return !!l.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, a.delay(this._tickAndRepeat, [], this)), true);
            }, o.prototype._tickAndRepeat = function() {
              this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (a.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
            }, o.prototype._tick = function() {
              if (this.isPaused || this.isFinished) return false;
              var u = null, b = Math.min(this.max, this.index + 16384);
              if (this.index >= this.max) return this.end();
              switch (this.type) {
                case "string":
                  u = this.data.substring(this.index, b);
                  break;
                case "uint8array":
                  u = this.data.subarray(this.index, b);
                  break;
                case "array":
                case "nodebuffer":
                  u = this.data.slice(this.index, b);
              }
              return this.index = b, this.push({ data: u, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
            }, r.exports = o;
          }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(t, r, n) {
            function a(l) {
              this.name = l || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
            }
            a.prototype = { push: function(l) {
              this.emit("data", l);
            }, end: function() {
              if (this.isFinished) return false;
              this.flush();
              try {
                this.emit("end"), this.cleanUp(), this.isFinished = true;
              } catch (l) {
                this.emit("error", l);
              }
              return true;
            }, error: function(l) {
              return !this.isFinished && (this.isPaused ? this.generatedError = l : (this.isFinished = true, this.emit("error", l), this.previous && this.previous.error(l), this.cleanUp()), true);
            }, on: function(l, o) {
              return this._listeners[l].push(o), this;
            }, cleanUp: function() {
              this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
            }, emit: function(l, o) {
              if (this._listeners[l]) for (var u = 0; u < this._listeners[l].length; u++) this._listeners[l][u].call(this, o);
            }, pipe: function(l) {
              return l.registerPrevious(this);
            }, registerPrevious: function(l) {
              if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
              this.streamInfo = l.streamInfo, this.mergeStreamInfo(), this.previous = l;
              var o = this;
              return l.on("data", function(u) {
                o.processChunk(u);
              }), l.on("end", function() {
                o.end();
              }), l.on("error", function(u) {
                o.error(u);
              }), this;
            }, pause: function() {
              return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
            }, resume: function() {
              if (!this.isPaused || this.isFinished) return false;
              var l = this.isPaused = false;
              return this.generatedError && (this.error(this.generatedError), l = true), this.previous && this.previous.resume(), !l;
            }, flush: function() {
            }, processChunk: function(l) {
              this.push(l);
            }, withStreamInfo: function(l, o) {
              return this.extraStreamInfo[l] = o, this.mergeStreamInfo(), this;
            }, mergeStreamInfo: function() {
              for (var l in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, l) && (this.streamInfo[l] = this.extraStreamInfo[l]);
            }, lock: function() {
              if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
              this.isLocked = true, this.previous && this.previous.lock();
            }, toString: function() {
              var l = "Worker " + this.name;
              return this.previous ? this.previous + " -> " + l : l;
            } }, r.exports = a;
          }, {}], 29: [function(t, r, n) {
            var a = t("../utils"), l = t("./ConvertWorker"), o = t("./GenericWorker"), u = t("../base64"), b = t("../support"), y = t("../external"), _ = null;
            if (b.nodestream) try {
              _ = t("../nodejs/NodejsStreamOutputAdapter");
            } catch (k) {
            }
            function w(k, h) {
              return new y.Promise(function(m, f) {
                var v = [], C = k._internalType, A = k._outputType, E = k._mimeType;
                k.on("data", function(D, I) {
                  v.push(D), h && h(I);
                }).on("error", function(D) {
                  v = [], f(D);
                }).on("end", function() {
                  try {
                    var D = function(I, W, T) {
                      switch (I) {
                        case "blob":
                          return a.newBlob(a.transformTo("arraybuffer", W), T);
                        case "base64":
                          return u.encode(W);
                        default:
                          return a.transformTo(I, W);
                      }
                    }(A, function(I, W) {
                      var T, X = 0, Q = null, S = 0;
                      for (T = 0; T < W.length; T++) S += W[T].length;
                      switch (I) {
                        case "string":
                          return W.join("");
                        case "array":
                          return Array.prototype.concat.apply([], W);
                        case "uint8array":
                          for (Q = new Uint8Array(S), T = 0; T < W.length; T++) Q.set(W[T], X), X += W[T].length;
                          return Q;
                        case "nodebuffer":
                          return Buffer.concat(W);
                        default:
                          throw new Error("concat : unsupported type '" + I + "'");
                      }
                    }(C, v), E);
                    m(D);
                  } catch (I) {
                    f(I);
                  }
                  v = [];
                }).resume();
              });
            }
            function d(k, h, m) {
              var f = h;
              switch (h) {
                case "blob":
                case "arraybuffer":
                  f = "uint8array";
                  break;
                case "base64":
                  f = "string";
              }
              try {
                this._internalType = f, this._outputType = h, this._mimeType = m, a.checkSupport(f), this._worker = k.pipe(new l(f)), k.lock();
              } catch (v) {
                this._worker = new o("error"), this._worker.error(v);
              }
            }
            d.prototype = { accumulate: function(k) {
              return w(this, k);
            }, on: function(k, h) {
              var m = this;
              return k === "data" ? this._worker.on(k, function(f) {
                h.call(m, f.data, f.meta);
              }) : this._worker.on(k, function() {
                a.delay(h, arguments, m);
              }), this;
            }, resume: function() {
              return a.delay(this._worker.resume, [], this._worker), this;
            }, pause: function() {
              return this._worker.pause(), this;
            }, toNodejsStream: function(k) {
              if (a.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
              return new _(this, { objectMode: this._outputType !== "nodebuffer" }, k);
            } }, r.exports = d;
          }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(t, r, n) {
            if (n.base64 = true, n.array = true, n.string = true, n.arraybuffer = typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined", n.nodebuffer = typeof Buffer != "undefined", n.uint8array = typeof Uint8Array != "undefined", typeof ArrayBuffer == "undefined") n.blob = false;
            else {
              var a = new ArrayBuffer(0);
              try {
                n.blob = new Blob([a], { type: "application/zip" }).size === 0;
              } catch (o) {
                try {
                  var l = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                  l.append(a), n.blob = l.getBlob("application/zip").size === 0;
                } catch (u) {
                  n.blob = false;
                }
              }
            }
            try {
              n.nodestream = !!t("readable-stream").Readable;
            } catch (o) {
              n.nodestream = false;
            }
          }, { "readable-stream": 16 }], 31: [function(t, r, n) {
            for (var a = t("./utils"), l = t("./support"), o = t("./nodejsUtils"), u = t("./stream/GenericWorker"), b = new Array(256), y = 0; y < 256; y++) b[y] = 252 <= y ? 6 : 248 <= y ? 5 : 240 <= y ? 4 : 224 <= y ? 3 : 192 <= y ? 2 : 1;
            b[254] = b[254] = 1;
            function _() {
              u.call(this, "utf-8 decode"), this.leftOver = null;
            }
            function w() {
              u.call(this, "utf-8 encode");
            }
            n.utf8encode = function(d) {
              return l.nodebuffer ? o.newBufferFrom(d, "utf-8") : function(k) {
                var h, m, f, v, C, A = k.length, E = 0;
                for (v = 0; v < A; v++) (64512 & (m = k.charCodeAt(v))) == 55296 && v + 1 < A && (64512 & (f = k.charCodeAt(v + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (f - 56320), v++), E += m < 128 ? 1 : m < 2048 ? 2 : m < 65536 ? 3 : 4;
                for (h = l.uint8array ? new Uint8Array(E) : new Array(E), v = C = 0; C < E; v++) (64512 & (m = k.charCodeAt(v))) == 55296 && v + 1 < A && (64512 & (f = k.charCodeAt(v + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (f - 56320), v++), m < 128 ? h[C++] = m : (m < 2048 ? h[C++] = 192 | m >>> 6 : (m < 65536 ? h[C++] = 224 | m >>> 12 : (h[C++] = 240 | m >>> 18, h[C++] = 128 | m >>> 12 & 63), h[C++] = 128 | m >>> 6 & 63), h[C++] = 128 | 63 & m);
                return h;
              }(d);
            }, n.utf8decode = function(d) {
              return l.nodebuffer ? a.transformTo("nodebuffer", d).toString("utf-8") : function(k) {
                var h, m, f, v, C = k.length, A = new Array(2 * C);
                for (h = m = 0; h < C; ) if ((f = k[h++]) < 128) A[m++] = f;
                else if (4 < (v = b[f])) A[m++] = 65533, h += v - 1;
                else {
                  for (f &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && h < C; ) f = f << 6 | 63 & k[h++], v--;
                  1 < v ? A[m++] = 65533 : f < 65536 ? A[m++] = f : (f -= 65536, A[m++] = 55296 | f >> 10 & 1023, A[m++] = 56320 | 1023 & f);
                }
                return A.length !== m && (A.subarray ? A = A.subarray(0, m) : A.length = m), a.applyFromCharCode(A);
              }(d = a.transformTo(l.uint8array ? "uint8array" : "array", d));
            }, a.inherits(_, u), _.prototype.processChunk = function(d) {
              var k = a.transformTo(l.uint8array ? "uint8array" : "array", d.data);
              if (this.leftOver && this.leftOver.length) {
                if (l.uint8array) {
                  var h = k;
                  (k = new Uint8Array(h.length + this.leftOver.length)).set(this.leftOver, 0), k.set(h, this.leftOver.length);
                } else k = this.leftOver.concat(k);
                this.leftOver = null;
              }
              var m = function(v, C) {
                var A;
                for ((C = C || v.length) > v.length && (C = v.length), A = C - 1; 0 <= A && (192 & v[A]) == 128; ) A--;
                return A < 0 || A === 0 ? C : A + b[v[A]] > C ? A : C;
              }(k), f = k;
              m !== k.length && (l.uint8array ? (f = k.subarray(0, m), this.leftOver = k.subarray(m, k.length)) : (f = k.slice(0, m), this.leftOver = k.slice(m, k.length))), this.push({ data: n.utf8decode(f), meta: d.meta });
            }, _.prototype.flush = function() {
              this.leftOver && this.leftOver.length && (this.push({ data: n.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
            }, n.Utf8DecodeWorker = _, a.inherits(w, u), w.prototype.processChunk = function(d) {
              this.push({ data: n.utf8encode(d.data), meta: d.meta });
            }, n.Utf8EncodeWorker = w;
          }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(t, r, n) {
            var a = t("./support"), l = t("./base64"), o = t("./nodejsUtils"), u = t("./external");
            function b(h) {
              return h;
            }
            function y(h, m) {
              for (var f = 0; f < h.length; ++f) m[f] = 255 & h.charCodeAt(f);
              return m;
            }
            t("setimmediate"), n.newBlob = function(h, m) {
              n.checkSupport("blob");
              try {
                return new Blob([h], { type: m });
              } catch (v) {
                try {
                  var f = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                  return f.append(h), f.getBlob(m);
                } catch (C) {
                  throw new Error("Bug : can't construct the Blob.");
                }
              }
            };
            var _ = { stringifyByChunk: function(h, m, f) {
              var v = [], C = 0, A = h.length;
              if (A <= f) return String.fromCharCode.apply(null, h);
              for (; C < A; ) m === "array" || m === "nodebuffer" ? v.push(String.fromCharCode.apply(null, h.slice(C, Math.min(C + f, A)))) : v.push(String.fromCharCode.apply(null, h.subarray(C, Math.min(C + f, A)))), C += f;
              return v.join("");
            }, stringifyByChar: function(h) {
              for (var m = "", f = 0; f < h.length; f++) m += String.fromCharCode(h[f]);
              return m;
            }, applyCanBeUsed: { uint8array: function() {
              try {
                return a.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
              } catch (h) {
                return false;
              }
            }(), nodebuffer: function() {
              try {
                return a.nodebuffer && String.fromCharCode.apply(null, o.allocBuffer(1)).length === 1;
              } catch (h) {
                return false;
              }
            }() } };
            function w(h) {
              var m = 65536, f = n.getTypeOf(h), v = true;
              if (f === "uint8array" ? v = _.applyCanBeUsed.uint8array : f === "nodebuffer" && (v = _.applyCanBeUsed.nodebuffer), v) for (; 1 < m; ) try {
                return _.stringifyByChunk(h, f, m);
              } catch (C) {
                m = Math.floor(m / 2);
              }
              return _.stringifyByChar(h);
            }
            function d(h, m) {
              for (var f = 0; f < h.length; f++) m[f] = h[f];
              return m;
            }
            n.applyFromCharCode = w;
            var k = {};
            k.string = { string: b, array: function(h) {
              return y(h, new Array(h.length));
            }, arraybuffer: function(h) {
              return k.string.uint8array(h).buffer;
            }, uint8array: function(h) {
              return y(h, new Uint8Array(h.length));
            }, nodebuffer: function(h) {
              return y(h, o.allocBuffer(h.length));
            } }, k.array = { string: w, array: b, arraybuffer: function(h) {
              return new Uint8Array(h).buffer;
            }, uint8array: function(h) {
              return new Uint8Array(h);
            }, nodebuffer: function(h) {
              return o.newBufferFrom(h);
            } }, k.arraybuffer = { string: function(h) {
              return w(new Uint8Array(h));
            }, array: function(h) {
              return d(new Uint8Array(h), new Array(h.byteLength));
            }, arraybuffer: b, uint8array: function(h) {
              return new Uint8Array(h);
            }, nodebuffer: function(h) {
              return o.newBufferFrom(new Uint8Array(h));
            } }, k.uint8array = { string: w, array: function(h) {
              return d(h, new Array(h.length));
            }, arraybuffer: function(h) {
              return h.buffer;
            }, uint8array: b, nodebuffer: function(h) {
              return o.newBufferFrom(h);
            } }, k.nodebuffer = { string: w, array: function(h) {
              return d(h, new Array(h.length));
            }, arraybuffer: function(h) {
              return k.nodebuffer.uint8array(h).buffer;
            }, uint8array: function(h) {
              return d(h, new Uint8Array(h.length));
            }, nodebuffer: b }, n.transformTo = function(h, m) {
              if (m = m || "", !h) return m;
              n.checkSupport(h);
              var f = n.getTypeOf(m);
              return k[f][h](m);
            }, n.resolve = function(h) {
              for (var m = h.split("/"), f = [], v = 0; v < m.length; v++) {
                var C = m[v];
                C === "." || C === "" && v !== 0 && v !== m.length - 1 || (C === ".." ? f.pop() : f.push(C));
              }
              return f.join("/");
            }, n.getTypeOf = function(h) {
              return typeof h == "string" ? "string" : Object.prototype.toString.call(h) === "[object Array]" ? "array" : a.nodebuffer && o.isBuffer(h) ? "nodebuffer" : a.uint8array && h instanceof Uint8Array ? "uint8array" : a.arraybuffer && h instanceof ArrayBuffer ? "arraybuffer" : void 0;
            }, n.checkSupport = function(h) {
              if (!a[h.toLowerCase()]) throw new Error(h + " is not supported by this platform");
            }, n.MAX_VALUE_16BITS = 65535, n.MAX_VALUE_32BITS = -1, n.pretty = function(h) {
              var m, f, v = "";
              for (f = 0; f < (h || "").length; f++) v += "\\x" + ((m = h.charCodeAt(f)) < 16 ? "0" : "") + m.toString(16).toUpperCase();
              return v;
            }, n.delay = function(h, m, f) {
              setImmediate(function() {
                h.apply(f || null, m || []);
              });
            }, n.inherits = function(h, m) {
              function f() {
              }
              f.prototype = m.prototype, h.prototype = new f();
            }, n.extend = function() {
              var h, m, f = {};
              for (h = 0; h < arguments.length; h++) for (m in arguments[h]) Object.prototype.hasOwnProperty.call(arguments[h], m) && f[m] === void 0 && (f[m] = arguments[h][m]);
              return f;
            }, n.prepareContent = function(h, m, f, v, C) {
              return u.Promise.resolve(m).then(function(A) {
                return a.blob && (A instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(A)) !== -1) && typeof FileReader != "undefined" ? new u.Promise(function(E, D) {
                  var I = new FileReader();
                  I.onload = function(W) {
                    E(W.target.result);
                  }, I.onerror = function(W) {
                    D(W.target.error);
                  }, I.readAsArrayBuffer(A);
                }) : A;
              }).then(function(A) {
                var E = n.getTypeOf(A);
                return E ? (E === "arraybuffer" ? A = n.transformTo("uint8array", A) : E === "string" && (C ? A = l.decode(A) : f && v !== true && (A = function(D) {
                  return y(D, a.uint8array ? new Uint8Array(D.length) : new Array(D.length));
                }(A))), A) : u.Promise.reject(new Error("Can't read the data of '" + h + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
              });
            };
          }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(t, r, n) {
            var a = t("./reader/readerFor"), l = t("./utils"), o = t("./signature"), u = t("./zipEntry"), b = t("./support");
            function y(_) {
              this.files = [], this.loadOptions = _;
            }
            y.prototype = { checkSignature: function(_) {
              if (!this.reader.readAndCheckSignature(_)) {
                this.reader.index -= 4;
                var w = this.reader.readString(4);
                throw new Error("Corrupted zip or bug: unexpected signature (" + l.pretty(w) + ", expected " + l.pretty(_) + ")");
              }
            }, isSignature: function(_, w) {
              var d = this.reader.index;
              this.reader.setIndex(_);
              var k = this.reader.readString(4) === w;
              return this.reader.setIndex(d), k;
            }, readBlockEndOfCentral: function() {
              this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
              var _ = this.reader.readData(this.zipCommentLength), w = b.uint8array ? "uint8array" : "array", d = l.transformTo(w, _);
              this.zipComment = this.loadOptions.decodeFileName(d);
            }, readBlockZip64EndOfCentral: function() {
              this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
              for (var _, w, d, k = this.zip64EndOfCentralSize - 44; 0 < k; ) _ = this.reader.readInt(2), w = this.reader.readInt(4), d = this.reader.readData(w), this.zip64ExtensibleData[_] = { id: _, length: w, value: d };
            }, readBlockZip64EndOfCentralLocator: function() {
              if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
            }, readLocalFiles: function() {
              var _, w;
              for (_ = 0; _ < this.files.length; _++) w = this.files[_], this.reader.setIndex(w.localHeaderOffset), this.checkSignature(o.LOCAL_FILE_HEADER), w.readLocalPart(this.reader), w.handleUTF8(), w.processAttributes();
            }, readCentralDir: function() {
              var _;
              for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(o.CENTRAL_FILE_HEADER); ) (_ = new u({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(_);
              if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            }, readEndOfCentral: function() {
              var _ = this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END);
              if (_ < 0) throw this.isSignature(0, o.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
              this.reader.setIndex(_);
              var w = _;
              if (this.checkSignature(o.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === l.MAX_VALUE_16BITS || this.diskWithCentralDirStart === l.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === l.MAX_VALUE_16BITS || this.centralDirRecords === l.MAX_VALUE_16BITS || this.centralDirSize === l.MAX_VALUE_32BITS || this.centralDirOffset === l.MAX_VALUE_32BITS) {
                if (this.zip64 = true, (_ = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                if (this.reader.setIndex(_), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, o.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
              }
              var d = this.centralDirOffset + this.centralDirSize;
              this.zip64 && (d += 20, d += 12 + this.zip64EndOfCentralSize);
              var k = w - d;
              if (0 < k) this.isSignature(w, o.CENTRAL_FILE_HEADER) || (this.reader.zero = k);
              else if (k < 0) throw new Error("Corrupted zip: missing " + Math.abs(k) + " bytes.");
            }, prepareReader: function(_) {
              this.reader = a(_);
            }, load: function(_) {
              this.prepareReader(_), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
            } }, r.exports = y;
          }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(t, r, n) {
            var a = t("./reader/readerFor"), l = t("./utils"), o = t("./compressedObject"), u = t("./crc32"), b = t("./utf8"), y = t("./compressions"), _ = t("./support");
            function w(d, k) {
              this.options = d, this.loadOptions = k;
            }
            w.prototype = { isEncrypted: function() {
              return (1 & this.bitFlag) == 1;
            }, useUTF8: function() {
              return (2048 & this.bitFlag) == 2048;
            }, readLocalPart: function(d) {
              var k, h;
              if (d.skip(22), this.fileNameLength = d.readInt(2), h = d.readInt(2), this.fileName = d.readData(this.fileNameLength), d.skip(h), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
              if ((k = function(m) {
                for (var f in y) if (Object.prototype.hasOwnProperty.call(y, f) && y[f].magic === m) return y[f];
                return null;
              }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + l.pretty(this.compressionMethod) + " unknown (inner file : " + l.transformTo("string", this.fileName) + ")");
              this.decompressed = new o(this.compressedSize, this.uncompressedSize, this.crc32, k, d.readData(this.compressedSize));
            }, readCentralPart: function(d) {
              this.versionMadeBy = d.readInt(2), d.skip(2), this.bitFlag = d.readInt(2), this.compressionMethod = d.readString(2), this.date = d.readDate(), this.crc32 = d.readInt(4), this.compressedSize = d.readInt(4), this.uncompressedSize = d.readInt(4);
              var k = d.readInt(2);
              if (this.extraFieldsLength = d.readInt(2), this.fileCommentLength = d.readInt(2), this.diskNumberStart = d.readInt(2), this.internalFileAttributes = d.readInt(2), this.externalFileAttributes = d.readInt(4), this.localHeaderOffset = d.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
              d.skip(k), this.readExtraFields(d), this.parseZIP64ExtraField(d), this.fileComment = d.readData(this.fileCommentLength);
            }, processAttributes: function() {
              this.unixPermissions = null, this.dosPermissions = null;
              var d = this.versionMadeBy >> 8;
              this.dir = !!(16 & this.externalFileAttributes), d == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), d == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = true);
            }, parseZIP64ExtraField: function() {
              if (this.extraFields[1]) {
                var d = a(this.extraFields[1].value);
                this.uncompressedSize === l.MAX_VALUE_32BITS && (this.uncompressedSize = d.readInt(8)), this.compressedSize === l.MAX_VALUE_32BITS && (this.compressedSize = d.readInt(8)), this.localHeaderOffset === l.MAX_VALUE_32BITS && (this.localHeaderOffset = d.readInt(8)), this.diskNumberStart === l.MAX_VALUE_32BITS && (this.diskNumberStart = d.readInt(4));
              }
            }, readExtraFields: function(d) {
              var k, h, m, f = d.index + this.extraFieldsLength;
              for (this.extraFields || (this.extraFields = {}); d.index + 4 < f; ) k = d.readInt(2), h = d.readInt(2), m = d.readData(h), this.extraFields[k] = { id: k, length: h, value: m };
              d.setIndex(f);
            }, handleUTF8: function() {
              var d = _.uint8array ? "uint8array" : "array";
              if (this.useUTF8()) this.fileNameStr = b.utf8decode(this.fileName), this.fileCommentStr = b.utf8decode(this.fileComment);
              else {
                var k = this.findExtraFieldUnicodePath();
                if (k !== null) this.fileNameStr = k;
                else {
                  var h = l.transformTo(d, this.fileName);
                  this.fileNameStr = this.loadOptions.decodeFileName(h);
                }
                var m = this.findExtraFieldUnicodeComment();
                if (m !== null) this.fileCommentStr = m;
                else {
                  var f = l.transformTo(d, this.fileComment);
                  this.fileCommentStr = this.loadOptions.decodeFileName(f);
                }
              }
            }, findExtraFieldUnicodePath: function() {
              var d = this.extraFields[28789];
              if (d) {
                var k = a(d.value);
                return k.readInt(1) !== 1 || u(this.fileName) !== k.readInt(4) ? null : b.utf8decode(k.readData(d.length - 5));
              }
              return null;
            }, findExtraFieldUnicodeComment: function() {
              var d = this.extraFields[25461];
              if (d) {
                var k = a(d.value);
                return k.readInt(1) !== 1 || u(this.fileComment) !== k.readInt(4) ? null : b.utf8decode(k.readData(d.length - 5));
              }
              return null;
            } }, r.exports = w;
          }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(t, r, n) {
            function a(k, h, m) {
              this.name = k, this.dir = m.dir, this.date = m.date, this.comment = m.comment, this.unixPermissions = m.unixPermissions, this.dosPermissions = m.dosPermissions, this._data = h, this._dataBinary = m.binary, this.options = { compression: m.compression, compressionOptions: m.compressionOptions };
            }
            var l = t("./stream/StreamHelper"), o = t("./stream/DataWorker"), u = t("./utf8"), b = t("./compressedObject"), y = t("./stream/GenericWorker");
            a.prototype = { internalStream: function(k) {
              var h = null, m = "string";
              try {
                if (!k) throw new Error("No output type specified.");
                var f = (m = k.toLowerCase()) === "string" || m === "text";
                m !== "binarystring" && m !== "text" || (m = "string"), h = this._decompressWorker();
                var v = !this._dataBinary;
                v && !f && (h = h.pipe(new u.Utf8EncodeWorker())), !v && f && (h = h.pipe(new u.Utf8DecodeWorker()));
              } catch (C) {
                (h = new y("error")).error(C);
              }
              return new l(h, m, "");
            }, async: function(k, h) {
              return this.internalStream(k).accumulate(h);
            }, nodeStream: function(k, h) {
              return this.internalStream(k || "nodebuffer").toNodejsStream(h);
            }, _compressWorker: function(k, h) {
              if (this._data instanceof b && this._data.compression.magic === k.magic) return this._data.getCompressedWorker();
              var m = this._decompressWorker();
              return this._dataBinary || (m = m.pipe(new u.Utf8EncodeWorker())), b.createWorkerFrom(m, k, h);
            }, _decompressWorker: function() {
              return this._data instanceof b ? this._data.getContentWorker() : this._data instanceof y ? this._data : new o(this._data);
            } };
            for (var _ = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], w = function() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, d = 0; d < _.length; d++) a.prototype[_[d]] = w;
            r.exports = a;
          }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(t, r, n) {
            (function(a) {
              var l, o, u = a.MutationObserver || a.WebKitMutationObserver;
              if (u) {
                var b = 0, y = new u(k), _ = a.document.createTextNode("");
                y.observe(_, { characterData: true }), l = function() {
                  _.data = b = ++b % 2;
                };
              } else if (a.setImmediate || a.MessageChannel === void 0) l = "document" in a && "onreadystatechange" in a.document.createElement("script") ? function() {
                var h = a.document.createElement("script");
                h.onreadystatechange = function() {
                  k(), h.onreadystatechange = null, h.parentNode.removeChild(h), h = null;
                }, a.document.documentElement.appendChild(h);
              } : function() {
                setTimeout(k, 0);
              };
              else {
                var w = new a.MessageChannel();
                w.port1.onmessage = k, l = function() {
                  w.port2.postMessage(0);
                };
              }
              var d = [];
              function k() {
                var h, m;
                o = true;
                for (var f = d.length; f; ) {
                  for (m = d, d = [], h = -1; ++h < f; ) m[h]();
                  f = d.length;
                }
                o = false;
              }
              r.exports = function(h) {
                d.push(h) !== 1 || o || l();
              };
            }).call(this, typeof vt != "undefined" ? vt : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
          }, {}], 37: [function(t, r, n) {
            var a = t("immediate");
            function l() {
            }
            var o = {}, u = ["REJECTED"], b = ["FULFILLED"], y = ["PENDING"];
            function _(f) {
              if (typeof f != "function") throw new TypeError("resolver must be a function");
              this.state = y, this.queue = [], this.outcome = void 0, f !== l && h(this, f);
            }
            function w(f, v, C) {
              this.promise = f, typeof v == "function" && (this.onFulfilled = v, this.callFulfilled = this.otherCallFulfilled), typeof C == "function" && (this.onRejected = C, this.callRejected = this.otherCallRejected);
            }
            function d(f, v, C) {
              a(function() {
                var A;
                try {
                  A = v(C);
                } catch (E) {
                  return o.reject(f, E);
                }
                A === f ? o.reject(f, new TypeError("Cannot resolve promise with itself")) : o.resolve(f, A);
              });
            }
            function k(f) {
              var v = f && f.then;
              if (f && (typeof f == "object" || typeof f == "function") && typeof v == "function") return function() {
                v.apply(f, arguments);
              };
            }
            function h(f, v) {
              var C = false;
              function A(I) {
                C || (C = true, o.reject(f, I));
              }
              function E(I) {
                C || (C = true, o.resolve(f, I));
              }
              var D = m(function() {
                v(E, A);
              });
              D.status === "error" && A(D.value);
            }
            function m(f, v) {
              var C = {};
              try {
                C.value = f(v), C.status = "success";
              } catch (A) {
                C.status = "error", C.value = A;
              }
              return C;
            }
            (r.exports = _).prototype.finally = function(f) {
              if (typeof f != "function") return this;
              var v = this.constructor;
              return this.then(function(C) {
                return v.resolve(f()).then(function() {
                  return C;
                });
              }, function(C) {
                return v.resolve(f()).then(function() {
                  throw C;
                });
              });
            }, _.prototype.catch = function(f) {
              return this.then(null, f);
            }, _.prototype.then = function(f, v) {
              if (typeof f != "function" && this.state === b || typeof v != "function" && this.state === u) return this;
              var C = new this.constructor(l);
              return this.state !== y ? d(C, this.state === b ? f : v, this.outcome) : this.queue.push(new w(C, f, v)), C;
            }, w.prototype.callFulfilled = function(f) {
              o.resolve(this.promise, f);
            }, w.prototype.otherCallFulfilled = function(f) {
              d(this.promise, this.onFulfilled, f);
            }, w.prototype.callRejected = function(f) {
              o.reject(this.promise, f);
            }, w.prototype.otherCallRejected = function(f) {
              d(this.promise, this.onRejected, f);
            }, o.resolve = function(f, v) {
              var C = m(k, v);
              if (C.status === "error") return o.reject(f, C.value);
              var A = C.value;
              if (A) h(f, A);
              else {
                f.state = b, f.outcome = v;
                for (var E = -1, D = f.queue.length; ++E < D; ) f.queue[E].callFulfilled(v);
              }
              return f;
            }, o.reject = function(f, v) {
              f.state = u, f.outcome = v;
              for (var C = -1, A = f.queue.length; ++C < A; ) f.queue[C].callRejected(v);
              return f;
            }, _.resolve = function(f) {
              return f instanceof this ? f : o.resolve(new this(l), f);
            }, _.reject = function(f) {
              var v = new this(l);
              return o.reject(v, f);
            }, _.all = function(f) {
              var v = this;
              if (Object.prototype.toString.call(f) !== "[object Array]") return this.reject(new TypeError("must be an array"));
              var C = f.length, A = false;
              if (!C) return this.resolve([]);
              for (var E = new Array(C), D = 0, I = -1, W = new this(l); ++I < C; ) T(f[I], I);
              return W;
              function T(X, Q) {
                v.resolve(X).then(function(S) {
                  E[Q] = S, ++D !== C || A || (A = true, o.resolve(W, E));
                }, function(S) {
                  A || (A = true, o.reject(W, S));
                });
              }
            }, _.race = function(f) {
              var v = this;
              if (Object.prototype.toString.call(f) !== "[object Array]") return this.reject(new TypeError("must be an array"));
              var C = f.length, A = false;
              if (!C) return this.resolve([]);
              for (var E = -1, D = new this(l); ++E < C; ) I = f[E], v.resolve(I).then(function(W) {
                A || (A = true, o.resolve(D, W));
              }, function(W) {
                A || (A = true, o.reject(D, W));
              });
              var I;
              return D;
            };
          }, { immediate: 36 }], 38: [function(t, r, n) {
            var a = {};
            (0, t("./lib/utils/common").assign)(a, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), r.exports = a;
          }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(t, r, n) {
            var a = t("./zlib/deflate"), l = t("./utils/common"), o = t("./utils/strings"), u = t("./zlib/messages"), b = t("./zlib/zstream"), y = Object.prototype.toString, _ = 0, w = -1, d = 0, k = 8;
            function h(f) {
              if (!(this instanceof h)) return new h(f);
              this.options = l.assign({ level: w, method: k, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: "" }, f || {});
              var v = this.options;
              v.raw && 0 < v.windowBits ? v.windowBits = -v.windowBits : v.gzip && 0 < v.windowBits && v.windowBits < 16 && (v.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new b(), this.strm.avail_out = 0;
              var C = a.deflateInit2(this.strm, v.level, v.method, v.windowBits, v.memLevel, v.strategy);
              if (C !== _) throw new Error(u[C]);
              if (v.header && a.deflateSetHeader(this.strm, v.header), v.dictionary) {
                var A;
                if (A = typeof v.dictionary == "string" ? o.string2buf(v.dictionary) : y.call(v.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(v.dictionary) : v.dictionary, (C = a.deflateSetDictionary(this.strm, A)) !== _) throw new Error(u[C]);
                this._dict_set = true;
              }
            }
            function m(f, v) {
              var C = new h(v);
              if (C.push(f, true), C.err) throw C.msg || u[C.err];
              return C.result;
            }
            h.prototype.push = function(f, v) {
              var C, A, E = this.strm, D = this.options.chunkSize;
              if (this.ended) return false;
              A = v === ~~v ? v : v === true ? 4 : 0, typeof f == "string" ? E.input = o.string2buf(f) : y.call(f) === "[object ArrayBuffer]" ? E.input = new Uint8Array(f) : E.input = f, E.next_in = 0, E.avail_in = E.input.length;
              do {
                if (E.avail_out === 0 && (E.output = new l.Buf8(D), E.next_out = 0, E.avail_out = D), (C = a.deflate(E, A)) !== 1 && C !== _) return this.onEnd(C), !(this.ended = true);
                E.avail_out !== 0 && (E.avail_in !== 0 || A !== 4 && A !== 2) || (this.options.to === "string" ? this.onData(o.buf2binstring(l.shrinkBuf(E.output, E.next_out))) : this.onData(l.shrinkBuf(E.output, E.next_out)));
              } while ((0 < E.avail_in || E.avail_out === 0) && C !== 1);
              return A === 4 ? (C = a.deflateEnd(this.strm), this.onEnd(C), this.ended = true, C === _) : A !== 2 || (this.onEnd(_), !(E.avail_out = 0));
            }, h.prototype.onData = function(f) {
              this.chunks.push(f);
            }, h.prototype.onEnd = function(f) {
              f === _ && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = f, this.msg = this.strm.msg;
            }, n.Deflate = h, n.deflate = m, n.deflateRaw = function(f, v) {
              return (v = v || {}).raw = true, m(f, v);
            }, n.gzip = function(f, v) {
              return (v = v || {}).gzip = true, m(f, v);
            };
          }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(t, r, n) {
            var a = t("./zlib/inflate"), l = t("./utils/common"), o = t("./utils/strings"), u = t("./zlib/constants"), b = t("./zlib/messages"), y = t("./zlib/zstream"), _ = t("./zlib/gzheader"), w = Object.prototype.toString;
            function d(h) {
              if (!(this instanceof d)) return new d(h);
              this.options = l.assign({ chunkSize: 16384, windowBits: 0, to: "" }, h || {});
              var m = this.options;
              m.raw && 0 <= m.windowBits && m.windowBits < 16 && (m.windowBits = -m.windowBits, m.windowBits === 0 && (m.windowBits = -15)), !(0 <= m.windowBits && m.windowBits < 16) || h && h.windowBits || (m.windowBits += 32), 15 < m.windowBits && m.windowBits < 48 && !(15 & m.windowBits) && (m.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new y(), this.strm.avail_out = 0;
              var f = a.inflateInit2(this.strm, m.windowBits);
              if (f !== u.Z_OK) throw new Error(b[f]);
              this.header = new _(), a.inflateGetHeader(this.strm, this.header);
            }
            function k(h, m) {
              var f = new d(m);
              if (f.push(h, true), f.err) throw f.msg || b[f.err];
              return f.result;
            }
            d.prototype.push = function(h, m) {
              var f, v, C, A, E, D, I = this.strm, W = this.options.chunkSize, T = this.options.dictionary, X = false;
              if (this.ended) return false;
              v = m === ~~m ? m : m === true ? u.Z_FINISH : u.Z_NO_FLUSH, typeof h == "string" ? I.input = o.binstring2buf(h) : w.call(h) === "[object ArrayBuffer]" ? I.input = new Uint8Array(h) : I.input = h, I.next_in = 0, I.avail_in = I.input.length;
              do {
                if (I.avail_out === 0 && (I.output = new l.Buf8(W), I.next_out = 0, I.avail_out = W), (f = a.inflate(I, u.Z_NO_FLUSH)) === u.Z_NEED_DICT && T && (D = typeof T == "string" ? o.string2buf(T) : w.call(T) === "[object ArrayBuffer]" ? new Uint8Array(T) : T, f = a.inflateSetDictionary(this.strm, D)), f === u.Z_BUF_ERROR && X === true && (f = u.Z_OK, X = false), f !== u.Z_STREAM_END && f !== u.Z_OK) return this.onEnd(f), !(this.ended = true);
                I.next_out && (I.avail_out !== 0 && f !== u.Z_STREAM_END && (I.avail_in !== 0 || v !== u.Z_FINISH && v !== u.Z_SYNC_FLUSH) || (this.options.to === "string" ? (C = o.utf8border(I.output, I.next_out), A = I.next_out - C, E = o.buf2string(I.output, C), I.next_out = A, I.avail_out = W - A, A && l.arraySet(I.output, I.output, C, A, 0), this.onData(E)) : this.onData(l.shrinkBuf(I.output, I.next_out)))), I.avail_in === 0 && I.avail_out === 0 && (X = true);
              } while ((0 < I.avail_in || I.avail_out === 0) && f !== u.Z_STREAM_END);
              return f === u.Z_STREAM_END && (v = u.Z_FINISH), v === u.Z_FINISH ? (f = a.inflateEnd(this.strm), this.onEnd(f), this.ended = true, f === u.Z_OK) : v !== u.Z_SYNC_FLUSH || (this.onEnd(u.Z_OK), !(I.avail_out = 0));
            }, d.prototype.onData = function(h) {
              this.chunks.push(h);
            }, d.prototype.onEnd = function(h) {
              h === u.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = h, this.msg = this.strm.msg;
            }, n.Inflate = d, n.inflate = k, n.inflateRaw = function(h, m) {
              return (m = m || {}).raw = true, k(h, m);
            }, n.ungzip = k;
          }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(t, r, n) {
            var a = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
            n.assign = function(u) {
              for (var b = Array.prototype.slice.call(arguments, 1); b.length; ) {
                var y = b.shift();
                if (y) {
                  if (typeof y != "object") throw new TypeError(y + "must be non-object");
                  for (var _ in y) y.hasOwnProperty(_) && (u[_] = y[_]);
                }
              }
              return u;
            }, n.shrinkBuf = function(u, b) {
              return u.length === b ? u : u.subarray ? u.subarray(0, b) : (u.length = b, u);
            };
            var l = { arraySet: function(u, b, y, _, w) {
              if (b.subarray && u.subarray) u.set(b.subarray(y, y + _), w);
              else for (var d = 0; d < _; d++) u[w + d] = b[y + d];
            }, flattenChunks: function(u) {
              var b, y, _, w, d, k;
              for (b = _ = 0, y = u.length; b < y; b++) _ += u[b].length;
              for (k = new Uint8Array(_), b = w = 0, y = u.length; b < y; b++) d = u[b], k.set(d, w), w += d.length;
              return k;
            } }, o = { arraySet: function(u, b, y, _, w) {
              for (var d = 0; d < _; d++) u[w + d] = b[y + d];
            }, flattenChunks: function(u) {
              return [].concat.apply([], u);
            } };
            n.setTyped = function(u) {
              u ? (n.Buf8 = Uint8Array, n.Buf16 = Uint16Array, n.Buf32 = Int32Array, n.assign(n, l)) : (n.Buf8 = Array, n.Buf16 = Array, n.Buf32 = Array, n.assign(n, o));
            }, n.setTyped(a);
          }, {}], 42: [function(t, r, n) {
            var a = t("./common"), l = true, o = true;
            try {
              String.fromCharCode.apply(null, [0]);
            } catch (_) {
              l = false;
            }
            try {
              String.fromCharCode.apply(null, new Uint8Array(1));
            } catch (_) {
              o = false;
            }
            for (var u = new a.Buf8(256), b = 0; b < 256; b++) u[b] = 252 <= b ? 6 : 248 <= b ? 5 : 240 <= b ? 4 : 224 <= b ? 3 : 192 <= b ? 2 : 1;
            function y(_, w) {
              if (w < 65537 && (_.subarray && o || !_.subarray && l)) return String.fromCharCode.apply(null, a.shrinkBuf(_, w));
              for (var d = "", k = 0; k < w; k++) d += String.fromCharCode(_[k]);
              return d;
            }
            u[254] = u[254] = 1, n.string2buf = function(_) {
              var w, d, k, h, m, f = _.length, v = 0;
              for (h = 0; h < f; h++) (64512 & (d = _.charCodeAt(h))) == 55296 && h + 1 < f && (64512 & (k = _.charCodeAt(h + 1))) == 56320 && (d = 65536 + (d - 55296 << 10) + (k - 56320), h++), v += d < 128 ? 1 : d < 2048 ? 2 : d < 65536 ? 3 : 4;
              for (w = new a.Buf8(v), h = m = 0; m < v; h++) (64512 & (d = _.charCodeAt(h))) == 55296 && h + 1 < f && (64512 & (k = _.charCodeAt(h + 1))) == 56320 && (d = 65536 + (d - 55296 << 10) + (k - 56320), h++), d < 128 ? w[m++] = d : (d < 2048 ? w[m++] = 192 | d >>> 6 : (d < 65536 ? w[m++] = 224 | d >>> 12 : (w[m++] = 240 | d >>> 18, w[m++] = 128 | d >>> 12 & 63), w[m++] = 128 | d >>> 6 & 63), w[m++] = 128 | 63 & d);
              return w;
            }, n.buf2binstring = function(_) {
              return y(_, _.length);
            }, n.binstring2buf = function(_) {
              for (var w = new a.Buf8(_.length), d = 0, k = w.length; d < k; d++) w[d] = _.charCodeAt(d);
              return w;
            }, n.buf2string = function(_, w) {
              var d, k, h, m, f = w || _.length, v = new Array(2 * f);
              for (d = k = 0; d < f; ) if ((h = _[d++]) < 128) v[k++] = h;
              else if (4 < (m = u[h])) v[k++] = 65533, d += m - 1;
              else {
                for (h &= m === 2 ? 31 : m === 3 ? 15 : 7; 1 < m && d < f; ) h = h << 6 | 63 & _[d++], m--;
                1 < m ? v[k++] = 65533 : h < 65536 ? v[k++] = h : (h -= 65536, v[k++] = 55296 | h >> 10 & 1023, v[k++] = 56320 | 1023 & h);
              }
              return y(v, k);
            }, n.utf8border = function(_, w) {
              var d;
              for ((w = w || _.length) > _.length && (w = _.length), d = w - 1; 0 <= d && (192 & _[d]) == 128; ) d--;
              return d < 0 || d === 0 ? w : d + u[_[d]] > w ? d : w;
            };
          }, { "./common": 41 }], 43: [function(t, r, n) {
            r.exports = function(a, l, o, u) {
              for (var b = 65535 & a | 0, y = a >>> 16 & 65535 | 0, _ = 0; o !== 0; ) {
                for (o -= _ = 2e3 < o ? 2e3 : o; y = y + (b = b + l[u++] | 0) | 0, --_; ) ;
                b %= 65521, y %= 65521;
              }
              return b | y << 16 | 0;
            };
          }, {}], 44: [function(t, r, n) {
            r.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
          }, {}], 45: [function(t, r, n) {
            var a = function() {
              for (var l, o = [], u = 0; u < 256; u++) {
                l = u;
                for (var b = 0; b < 8; b++) l = 1 & l ? 3988292384 ^ l >>> 1 : l >>> 1;
                o[u] = l;
              }
              return o;
            }();
            r.exports = function(l, o, u, b) {
              var y = a, _ = b + u;
              l ^= -1;
              for (var w = b; w < _; w++) l = l >>> 8 ^ y[255 & (l ^ o[w])];
              return -1 ^ l;
            };
          }, {}], 46: [function(t, r, n) {
            var a, l = t("../utils/common"), o = t("./trees"), u = t("./adler32"), b = t("./crc32"), y = t("./messages"), _ = 0, w = 4, d = 0, k = -2, h = -1, m = 4, f = 2, v = 8, C = 9, A = 286, E = 30, D = 19, I = 2 * A + 1, W = 15, T = 3, X = 258, Q = X + T + 1, S = 42, O = 113, c = 1, L = 2, et = 3, $ = 4;
            function rt(s, F) {
              return s.msg = y[F], F;
            }
            function H(s) {
              return (s << 1) - (4 < s ? 9 : 0);
            }
            function tt(s) {
              for (var F = s.length; 0 <= --F; ) s[F] = 0;
            }
            function R(s) {
              var F = s.state, M = F.pending;
              M > s.avail_out && (M = s.avail_out), M !== 0 && (l.arraySet(s.output, F.pending_buf, F.pending_out, M, s.next_out), s.next_out += M, F.pending_out += M, s.total_out += M, s.avail_out -= M, F.pending -= M, F.pending === 0 && (F.pending_out = 0));
            }
            function B(s, F) {
              o._tr_flush_block(s, 0 <= s.block_start ? s.block_start : -1, s.strstart - s.block_start, F), s.block_start = s.strstart, R(s.strm);
            }
            function J(s, F) {
              s.pending_buf[s.pending++] = F;
            }
            function q(s, F) {
              s.pending_buf[s.pending++] = F >>> 8 & 255, s.pending_buf[s.pending++] = 255 & F;
            }
            function G(s, F) {
              var M, g, p = s.max_chain_length, x = s.strstart, j = s.prev_length, U = s.nice_match, N = s.strstart > s.w_size - Q ? s.strstart - (s.w_size - Q) : 0, Z = s.window, K = s.w_mask, V = s.prev, Y = s.strstart + X, lt = Z[x + j - 1], st = Z[x + j];
              s.prev_length >= s.good_match && (p >>= 2), U > s.lookahead && (U = s.lookahead);
              do
                if (Z[(M = F) + j] === st && Z[M + j - 1] === lt && Z[M] === Z[x] && Z[++M] === Z[x + 1]) {
                  x += 2, M++;
                  do
                    ;
                  while (Z[++x] === Z[++M] && Z[++x] === Z[++M] && Z[++x] === Z[++M] && Z[++x] === Z[++M] && Z[++x] === Z[++M] && Z[++x] === Z[++M] && Z[++x] === Z[++M] && Z[++x] === Z[++M] && x < Y);
                  if (g = X - (Y - x), x = Y - X, j < g) {
                    if (s.match_start = F, U <= (j = g)) break;
                    lt = Z[x + j - 1], st = Z[x + j];
                  }
                }
              while ((F = V[F & K]) > N && --p != 0);
              return j <= s.lookahead ? j : s.lookahead;
            }
            function mt(s) {
              var F, M, g, p, x, j, U, N, Z, K, V = s.w_size;
              do {
                if (p = s.window_size - s.lookahead - s.strstart, s.strstart >= V + (V - Q)) {
                  for (l.arraySet(s.window, s.window, V, V, 0), s.match_start -= V, s.strstart -= V, s.block_start -= V, F = M = s.hash_size; g = s.head[--F], s.head[F] = V <= g ? g - V : 0, --M; ) ;
                  for (F = M = V; g = s.prev[--F], s.prev[F] = V <= g ? g - V : 0, --M; ) ;
                  p += V;
                }
                if (s.strm.avail_in === 0) break;
                if (j = s.strm, U = s.window, N = s.strstart + s.lookahead, Z = p, K = void 0, K = j.avail_in, Z < K && (K = Z), M = K === 0 ? 0 : (j.avail_in -= K, l.arraySet(U, j.input, j.next_in, K, N), j.state.wrap === 1 ? j.adler = u(j.adler, U, K, N) : j.state.wrap === 2 && (j.adler = b(j.adler, U, K, N)), j.next_in += K, j.total_in += K, K), s.lookahead += M, s.lookahead + s.insert >= T) for (x = s.strstart - s.insert, s.ins_h = s.window[x], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[x + 1]) & s.hash_mask; s.insert && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[x + T - 1]) & s.hash_mask, s.prev[x & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = x, x++, s.insert--, !(s.lookahead + s.insert < T)); ) ;
              } while (s.lookahead < Q && s.strm.avail_in !== 0);
            }
            function yt(s, F) {
              for (var M, g; ; ) {
                if (s.lookahead < Q) {
                  if (mt(s), s.lookahead < Q && F === _) return c;
                  if (s.lookahead === 0) break;
                }
                if (M = 0, s.lookahead >= T && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + T - 1]) & s.hash_mask, M = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), M !== 0 && s.strstart - M <= s.w_size - Q && (s.match_length = G(s, M)), s.match_length >= T) if (g = o._tr_tally(s, s.strstart - s.match_start, s.match_length - T), s.lookahead -= s.match_length, s.match_length <= s.max_lazy_match && s.lookahead >= T) {
                  for (s.match_length--; s.strstart++, s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + T - 1]) & s.hash_mask, M = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart, --s.match_length != 0; ) ;
                  s.strstart++;
                } else s.strstart += s.match_length, s.match_length = 0, s.ins_h = s.window[s.strstart], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
                else g = o._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++;
                if (g && (B(s, false), s.strm.avail_out === 0)) return c;
              }
              return s.insert = s.strstart < T - 1 ? s.strstart : T - 1, F === w ? (B(s, true), s.strm.avail_out === 0 ? et : $) : s.last_lit && (B(s, false), s.strm.avail_out === 0) ? c : L;
            }
            function at(s, F) {
              for (var M, g, p; ; ) {
                if (s.lookahead < Q) {
                  if (mt(s), s.lookahead < Q && F === _) return c;
                  if (s.lookahead === 0) break;
                }
                if (M = 0, s.lookahead >= T && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + T - 1]) & s.hash_mask, M = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), s.prev_length = s.match_length, s.prev_match = s.match_start, s.match_length = T - 1, M !== 0 && s.prev_length < s.max_lazy_match && s.strstart - M <= s.w_size - Q && (s.match_length = G(s, M), s.match_length <= 5 && (s.strategy === 1 || s.match_length === T && 4096 < s.strstart - s.match_start) && (s.match_length = T - 1)), s.prev_length >= T && s.match_length <= s.prev_length) {
                  for (p = s.strstart + s.lookahead - T, g = o._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - T), s.lookahead -= s.prev_length - 1, s.prev_length -= 2; ++s.strstart <= p && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + T - 1]) & s.hash_mask, M = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), --s.prev_length != 0; ) ;
                  if (s.match_available = 0, s.match_length = T - 1, s.strstart++, g && (B(s, false), s.strm.avail_out === 0)) return c;
                } else if (s.match_available) {
                  if ((g = o._tr_tally(s, 0, s.window[s.strstart - 1])) && B(s, false), s.strstart++, s.lookahead--, s.strm.avail_out === 0) return c;
                } else s.match_available = 1, s.strstart++, s.lookahead--;
              }
              return s.match_available && (g = o._tr_tally(s, 0, s.window[s.strstart - 1]), s.match_available = 0), s.insert = s.strstart < T - 1 ? s.strstart : T - 1, F === w ? (B(s, true), s.strm.avail_out === 0 ? et : $) : s.last_lit && (B(s, false), s.strm.avail_out === 0) ? c : L;
            }
            function it(s, F, M, g, p) {
              this.good_length = s, this.max_lazy = F, this.nice_length = M, this.max_chain = g, this.func = p;
            }
            function kt() {
              this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new l.Buf16(2 * I), this.dyn_dtree = new l.Buf16(2 * (2 * E + 1)), this.bl_tree = new l.Buf16(2 * (2 * D + 1)), tt(this.dyn_ltree), tt(this.dyn_dtree), tt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new l.Buf16(W + 1), this.heap = new l.Buf16(2 * A + 1), tt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new l.Buf16(2 * A + 1), tt(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
            }
            function gt(s) {
              var F;
              return s && s.state ? (s.total_in = s.total_out = 0, s.data_type = f, (F = s.state).pending = 0, F.pending_out = 0, F.wrap < 0 && (F.wrap = -F.wrap), F.status = F.wrap ? S : O, s.adler = F.wrap === 2 ? 0 : 1, F.last_flush = _, o._tr_init(F), d) : rt(s, k);
            }
            function Pt(s) {
              var F = gt(s);
              return F === d && function(M) {
                M.window_size = 2 * M.w_size, tt(M.head), M.max_lazy_match = a[M.level].max_lazy, M.good_match = a[M.level].good_length, M.nice_match = a[M.level].nice_length, M.max_chain_length = a[M.level].max_chain, M.strstart = 0, M.block_start = 0, M.lookahead = 0, M.insert = 0, M.match_length = M.prev_length = T - 1, M.match_available = 0, M.ins_h = 0;
              }(s.state), F;
            }
            function xt(s, F, M, g, p, x) {
              if (!s) return k;
              var j = 1;
              if (F === h && (F = 6), g < 0 ? (j = 0, g = -g) : 15 < g && (j = 2, g -= 16), p < 1 || C < p || M !== v || g < 8 || 15 < g || F < 0 || 9 < F || x < 0 || m < x) return rt(s, k);
              g === 8 && (g = 9);
              var U = new kt();
              return (s.state = U).strm = s, U.wrap = j, U.gzhead = null, U.w_bits = g, U.w_size = 1 << U.w_bits, U.w_mask = U.w_size - 1, U.hash_bits = p + 7, U.hash_size = 1 << U.hash_bits, U.hash_mask = U.hash_size - 1, U.hash_shift = ~~((U.hash_bits + T - 1) / T), U.window = new l.Buf8(2 * U.w_size), U.head = new l.Buf16(U.hash_size), U.prev = new l.Buf16(U.w_size), U.lit_bufsize = 1 << p + 6, U.pending_buf_size = 4 * U.lit_bufsize, U.pending_buf = new l.Buf8(U.pending_buf_size), U.d_buf = 1 * U.lit_bufsize, U.l_buf = 3 * U.lit_bufsize, U.level = F, U.strategy = x, U.method = M, Pt(s);
            }
            a = [new it(0, 0, 0, 0, function(s, F) {
              var M = 65535;
              for (M > s.pending_buf_size - 5 && (M = s.pending_buf_size - 5); ; ) {
                if (s.lookahead <= 1) {
                  if (mt(s), s.lookahead === 0 && F === _) return c;
                  if (s.lookahead === 0) break;
                }
                s.strstart += s.lookahead, s.lookahead = 0;
                var g = s.block_start + M;
                if ((s.strstart === 0 || s.strstart >= g) && (s.lookahead = s.strstart - g, s.strstart = g, B(s, false), s.strm.avail_out === 0) || s.strstart - s.block_start >= s.w_size - Q && (B(s, false), s.strm.avail_out === 0)) return c;
              }
              return s.insert = 0, F === w ? (B(s, true), s.strm.avail_out === 0 ? et : $) : (s.strstart > s.block_start && (B(s, false), s.strm.avail_out), c);
            }), new it(4, 4, 8, 4, yt), new it(4, 5, 16, 8, yt), new it(4, 6, 32, 32, yt), new it(4, 4, 16, 16, at), new it(8, 16, 32, 32, at), new it(8, 16, 128, 128, at), new it(8, 32, 128, 256, at), new it(32, 128, 258, 1024, at), new it(32, 258, 258, 4096, at)], n.deflateInit = function(s, F) {
              return xt(s, F, v, 15, 8, 0);
            }, n.deflateInit2 = xt, n.deflateReset = Pt, n.deflateResetKeep = gt, n.deflateSetHeader = function(s, F) {
              return s && s.state ? s.state.wrap !== 2 ? k : (s.state.gzhead = F, d) : k;
            }, n.deflate = function(s, F) {
              var M, g, p, x;
              if (!s || !s.state || 5 < F || F < 0) return s ? rt(s, k) : k;
              if (g = s.state, !s.output || !s.input && s.avail_in !== 0 || g.status === 666 && F !== w) return rt(s, s.avail_out === 0 ? -5 : k);
              if (g.strm = s, M = g.last_flush, g.last_flush = F, g.status === S) if (g.wrap === 2) s.adler = 0, J(g, 31), J(g, 139), J(g, 8), g.gzhead ? (J(g, (g.gzhead.text ? 1 : 0) + (g.gzhead.hcrc ? 2 : 0) + (g.gzhead.extra ? 4 : 0) + (g.gzhead.name ? 8 : 0) + (g.gzhead.comment ? 16 : 0)), J(g, 255 & g.gzhead.time), J(g, g.gzhead.time >> 8 & 255), J(g, g.gzhead.time >> 16 & 255), J(g, g.gzhead.time >> 24 & 255), J(g, g.level === 9 ? 2 : 2 <= g.strategy || g.level < 2 ? 4 : 0), J(g, 255 & g.gzhead.os), g.gzhead.extra && g.gzhead.extra.length && (J(g, 255 & g.gzhead.extra.length), J(g, g.gzhead.extra.length >> 8 & 255)), g.gzhead.hcrc && (s.adler = b(s.adler, g.pending_buf, g.pending, 0)), g.gzindex = 0, g.status = 69) : (J(g, 0), J(g, 0), J(g, 0), J(g, 0), J(g, 0), J(g, g.level === 9 ? 2 : 2 <= g.strategy || g.level < 2 ? 4 : 0), J(g, 3), g.status = O);
              else {
                var j = v + (g.w_bits - 8 << 4) << 8;
                j |= (2 <= g.strategy || g.level < 2 ? 0 : g.level < 6 ? 1 : g.level === 6 ? 2 : 3) << 6, g.strstart !== 0 && (j |= 32), j += 31 - j % 31, g.status = O, q(g, j), g.strstart !== 0 && (q(g, s.adler >>> 16), q(g, 65535 & s.adler)), s.adler = 1;
              }
              if (g.status === 69) if (g.gzhead.extra) {
                for (p = g.pending; g.gzindex < (65535 & g.gzhead.extra.length) && (g.pending !== g.pending_buf_size || (g.gzhead.hcrc && g.pending > p && (s.adler = b(s.adler, g.pending_buf, g.pending - p, p)), R(s), p = g.pending, g.pending !== g.pending_buf_size)); ) J(g, 255 & g.gzhead.extra[g.gzindex]), g.gzindex++;
                g.gzhead.hcrc && g.pending > p && (s.adler = b(s.adler, g.pending_buf, g.pending - p, p)), g.gzindex === g.gzhead.extra.length && (g.gzindex = 0, g.status = 73);
              } else g.status = 73;
              if (g.status === 73) if (g.gzhead.name) {
                p = g.pending;
                do {
                  if (g.pending === g.pending_buf_size && (g.gzhead.hcrc && g.pending > p && (s.adler = b(s.adler, g.pending_buf, g.pending - p, p)), R(s), p = g.pending, g.pending === g.pending_buf_size)) {
                    x = 1;
                    break;
                  }
                  x = g.gzindex < g.gzhead.name.length ? 255 & g.gzhead.name.charCodeAt(g.gzindex++) : 0, J(g, x);
                } while (x !== 0);
                g.gzhead.hcrc && g.pending > p && (s.adler = b(s.adler, g.pending_buf, g.pending - p, p)), x === 0 && (g.gzindex = 0, g.status = 91);
              } else g.status = 91;
              if (g.status === 91) if (g.gzhead.comment) {
                p = g.pending;
                do {
                  if (g.pending === g.pending_buf_size && (g.gzhead.hcrc && g.pending > p && (s.adler = b(s.adler, g.pending_buf, g.pending - p, p)), R(s), p = g.pending, g.pending === g.pending_buf_size)) {
                    x = 1;
                    break;
                  }
                  x = g.gzindex < g.gzhead.comment.length ? 255 & g.gzhead.comment.charCodeAt(g.gzindex++) : 0, J(g, x);
                } while (x !== 0);
                g.gzhead.hcrc && g.pending > p && (s.adler = b(s.adler, g.pending_buf, g.pending - p, p)), x === 0 && (g.status = 103);
              } else g.status = 103;
              if (g.status === 103 && (g.gzhead.hcrc ? (g.pending + 2 > g.pending_buf_size && R(s), g.pending + 2 <= g.pending_buf_size && (J(g, 255 & s.adler), J(g, s.adler >> 8 & 255), s.adler = 0, g.status = O)) : g.status = O), g.pending !== 0) {
                if (R(s), s.avail_out === 0) return g.last_flush = -1, d;
              } else if (s.avail_in === 0 && H(F) <= H(M) && F !== w) return rt(s, -5);
              if (g.status === 666 && s.avail_in !== 0) return rt(s, -5);
              if (s.avail_in !== 0 || g.lookahead !== 0 || F !== _ && g.status !== 666) {
                var U = g.strategy === 2 ? function(N, Z) {
                  for (var K; ; ) {
                    if (N.lookahead === 0 && (mt(N), N.lookahead === 0)) {
                      if (Z === _) return c;
                      break;
                    }
                    if (N.match_length = 0, K = o._tr_tally(N, 0, N.window[N.strstart]), N.lookahead--, N.strstart++, K && (B(N, false), N.strm.avail_out === 0)) return c;
                  }
                  return N.insert = 0, Z === w ? (B(N, true), N.strm.avail_out === 0 ? et : $) : N.last_lit && (B(N, false), N.strm.avail_out === 0) ? c : L;
                }(g, F) : g.strategy === 3 ? function(N, Z) {
                  for (var K, V, Y, lt, st = N.window; ; ) {
                    if (N.lookahead <= X) {
                      if (mt(N), N.lookahead <= X && Z === _) return c;
                      if (N.lookahead === 0) break;
                    }
                    if (N.match_length = 0, N.lookahead >= T && 0 < N.strstart && (V = st[Y = N.strstart - 1]) === st[++Y] && V === st[++Y] && V === st[++Y]) {
                      lt = N.strstart + X;
                      do
                        ;
                      while (V === st[++Y] && V === st[++Y] && V === st[++Y] && V === st[++Y] && V === st[++Y] && V === st[++Y] && V === st[++Y] && V === st[++Y] && Y < lt);
                      N.match_length = X - (lt - Y), N.match_length > N.lookahead && (N.match_length = N.lookahead);
                    }
                    if (N.match_length >= T ? (K = o._tr_tally(N, 1, N.match_length - T), N.lookahead -= N.match_length, N.strstart += N.match_length, N.match_length = 0) : (K = o._tr_tally(N, 0, N.window[N.strstart]), N.lookahead--, N.strstart++), K && (B(N, false), N.strm.avail_out === 0)) return c;
                  }
                  return N.insert = 0, Z === w ? (B(N, true), N.strm.avail_out === 0 ? et : $) : N.last_lit && (B(N, false), N.strm.avail_out === 0) ? c : L;
                }(g, F) : a[g.level].func(g, F);
                if (U !== et && U !== $ || (g.status = 666), U === c || U === et) return s.avail_out === 0 && (g.last_flush = -1), d;
                if (U === L && (F === 1 ? o._tr_align(g) : F !== 5 && (o._tr_stored_block(g, 0, 0, false), F === 3 && (tt(g.head), g.lookahead === 0 && (g.strstart = 0, g.block_start = 0, g.insert = 0))), R(s), s.avail_out === 0)) return g.last_flush = -1, d;
              }
              return F !== w ? d : g.wrap <= 0 ? 1 : (g.wrap === 2 ? (J(g, 255 & s.adler), J(g, s.adler >> 8 & 255), J(g, s.adler >> 16 & 255), J(g, s.adler >> 24 & 255), J(g, 255 & s.total_in), J(g, s.total_in >> 8 & 255), J(g, s.total_in >> 16 & 255), J(g, s.total_in >> 24 & 255)) : (q(g, s.adler >>> 16), q(g, 65535 & s.adler)), R(s), 0 < g.wrap && (g.wrap = -g.wrap), g.pending !== 0 ? d : 1);
            }, n.deflateEnd = function(s) {
              var F;
              return s && s.state ? (F = s.state.status) !== S && F !== 69 && F !== 73 && F !== 91 && F !== 103 && F !== O && F !== 666 ? rt(s, k) : (s.state = null, F === O ? rt(s, -3) : d) : k;
            }, n.deflateSetDictionary = function(s, F) {
              var M, g, p, x, j, U, N, Z, K = F.length;
              if (!s || !s.state || (x = (M = s.state).wrap) === 2 || x === 1 && M.status !== S || M.lookahead) return k;
              for (x === 1 && (s.adler = u(s.adler, F, K, 0)), M.wrap = 0, K >= M.w_size && (x === 0 && (tt(M.head), M.strstart = 0, M.block_start = 0, M.insert = 0), Z = new l.Buf8(M.w_size), l.arraySet(Z, F, K - M.w_size, M.w_size, 0), F = Z, K = M.w_size), j = s.avail_in, U = s.next_in, N = s.input, s.avail_in = K, s.next_in = 0, s.input = F, mt(M); M.lookahead >= T; ) {
                for (g = M.strstart, p = M.lookahead - (T - 1); M.ins_h = (M.ins_h << M.hash_shift ^ M.window[g + T - 1]) & M.hash_mask, M.prev[g & M.w_mask] = M.head[M.ins_h], M.head[M.ins_h] = g, g++, --p; ) ;
                M.strstart = g, M.lookahead = T - 1, mt(M);
              }
              return M.strstart += M.lookahead, M.block_start = M.strstart, M.insert = M.lookahead, M.lookahead = 0, M.match_length = M.prev_length = T - 1, M.match_available = 0, s.next_in = U, s.input = N, s.avail_in = j, M.wrap = x, d;
            }, n.deflateInfo = "pako deflate (from Nodeca project)";
          }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(t, r, n) {
            r.exports = function() {
              this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
            };
          }, {}], 48: [function(t, r, n) {
            r.exports = function(a, l) {
              var o, u, b, y, _, w, d, k, h, m, f, v, C, A, E, D, I, W, T, X, Q, S, O, c, L;
              o = a.state, u = a.next_in, c = a.input, b = u + (a.avail_in - 5), y = a.next_out, L = a.output, _ = y - (l - a.avail_out), w = y + (a.avail_out - 257), d = o.dmax, k = o.wsize, h = o.whave, m = o.wnext, f = o.window, v = o.hold, C = o.bits, A = o.lencode, E = o.distcode, D = (1 << o.lenbits) - 1, I = (1 << o.distbits) - 1;
              t: do {
                C < 15 && (v += c[u++] << C, C += 8, v += c[u++] << C, C += 8), W = A[v & D];
                e: for (; ; ) {
                  if (v >>>= T = W >>> 24, C -= T, (T = W >>> 16 & 255) === 0) L[y++] = 65535 & W;
                  else {
                    if (!(16 & T)) {
                      if (!(64 & T)) {
                        W = A[(65535 & W) + (v & (1 << T) - 1)];
                        continue e;
                      }
                      if (32 & T) {
                        o.mode = 12;
                        break t;
                      }
                      a.msg = "invalid literal/length code", o.mode = 30;
                      break t;
                    }
                    X = 65535 & W, (T &= 15) && (C < T && (v += c[u++] << C, C += 8), X += v & (1 << T) - 1, v >>>= T, C -= T), C < 15 && (v += c[u++] << C, C += 8, v += c[u++] << C, C += 8), W = E[v & I];
                    r: for (; ; ) {
                      if (v >>>= T = W >>> 24, C -= T, !(16 & (T = W >>> 16 & 255))) {
                        if (!(64 & T)) {
                          W = E[(65535 & W) + (v & (1 << T) - 1)];
                          continue r;
                        }
                        a.msg = "invalid distance code", o.mode = 30;
                        break t;
                      }
                      if (Q = 65535 & W, C < (T &= 15) && (v += c[u++] << C, (C += 8) < T && (v += c[u++] << C, C += 8)), d < (Q += v & (1 << T) - 1)) {
                        a.msg = "invalid distance too far back", o.mode = 30;
                        break t;
                      }
                      if (v >>>= T, C -= T, (T = y - _) < Q) {
                        if (h < (T = Q - T) && o.sane) {
                          a.msg = "invalid distance too far back", o.mode = 30;
                          break t;
                        }
                        if (O = f, (S = 0) === m) {
                          if (S += k - T, T < X) {
                            for (X -= T; L[y++] = f[S++], --T; ) ;
                            S = y - Q, O = L;
                          }
                        } else if (m < T) {
                          if (S += k + m - T, (T -= m) < X) {
                            for (X -= T; L[y++] = f[S++], --T; ) ;
                            if (S = 0, m < X) {
                              for (X -= T = m; L[y++] = f[S++], --T; ) ;
                              S = y - Q, O = L;
                            }
                          }
                        } else if (S += m - T, T < X) {
                          for (X -= T; L[y++] = f[S++], --T; ) ;
                          S = y - Q, O = L;
                        }
                        for (; 2 < X; ) L[y++] = O[S++], L[y++] = O[S++], L[y++] = O[S++], X -= 3;
                        X && (L[y++] = O[S++], 1 < X && (L[y++] = O[S++]));
                      } else {
                        for (S = y - Q; L[y++] = L[S++], L[y++] = L[S++], L[y++] = L[S++], 2 < (X -= 3); ) ;
                        X && (L[y++] = L[S++], 1 < X && (L[y++] = L[S++]));
                      }
                      break;
                    }
                  }
                  break;
                }
              } while (u < b && y < w);
              u -= X = C >> 3, v &= (1 << (C -= X << 3)) - 1, a.next_in = u, a.next_out = y, a.avail_in = u < b ? b - u + 5 : 5 - (u - b), a.avail_out = y < w ? w - y + 257 : 257 - (y - w), o.hold = v, o.bits = C;
            };
          }, {}], 49: [function(t, r, n) {
            var a = t("../utils/common"), l = t("./adler32"), o = t("./crc32"), u = t("./inffast"), b = t("./inftrees"), y = 1, _ = 2, w = 0, d = -2, k = 1, h = 852, m = 592;
            function f(S) {
              return (S >>> 24 & 255) + (S >>> 8 & 65280) + ((65280 & S) << 8) + ((255 & S) << 24);
            }
            function v() {
              this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new a.Buf16(320), this.work = new a.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
            }
            function C(S) {
              var O;
              return S && S.state ? (O = S.state, S.total_in = S.total_out = O.total = 0, S.msg = "", O.wrap && (S.adler = 1 & O.wrap), O.mode = k, O.last = 0, O.havedict = 0, O.dmax = 32768, O.head = null, O.hold = 0, O.bits = 0, O.lencode = O.lendyn = new a.Buf32(h), O.distcode = O.distdyn = new a.Buf32(m), O.sane = 1, O.back = -1, w) : d;
            }
            function A(S) {
              var O;
              return S && S.state ? ((O = S.state).wsize = 0, O.whave = 0, O.wnext = 0, C(S)) : d;
            }
            function E(S, O) {
              var c, L;
              return S && S.state ? (L = S.state, O < 0 ? (c = 0, O = -O) : (c = 1 + (O >> 4), O < 48 && (O &= 15)), O && (O < 8 || 15 < O) ? d : (L.window !== null && L.wbits !== O && (L.window = null), L.wrap = c, L.wbits = O, A(S))) : d;
            }
            function D(S, O) {
              var c, L;
              return S ? (L = new v(), (S.state = L).window = null, (c = E(S, O)) !== w && (S.state = null), c) : d;
            }
            var I, W, T = true;
            function X(S) {
              if (T) {
                var O;
                for (I = new a.Buf32(512), W = new a.Buf32(32), O = 0; O < 144; ) S.lens[O++] = 8;
                for (; O < 256; ) S.lens[O++] = 9;
                for (; O < 280; ) S.lens[O++] = 7;
                for (; O < 288; ) S.lens[O++] = 8;
                for (b(y, S.lens, 0, 288, I, 0, S.work, { bits: 9 }), O = 0; O < 32; ) S.lens[O++] = 5;
                b(_, S.lens, 0, 32, W, 0, S.work, { bits: 5 }), T = false;
              }
              S.lencode = I, S.lenbits = 9, S.distcode = W, S.distbits = 5;
            }
            function Q(S, O, c, L) {
              var et, $ = S.state;
              return $.window === null && ($.wsize = 1 << $.wbits, $.wnext = 0, $.whave = 0, $.window = new a.Buf8($.wsize)), L >= $.wsize ? (a.arraySet($.window, O, c - $.wsize, $.wsize, 0), $.wnext = 0, $.whave = $.wsize) : (L < (et = $.wsize - $.wnext) && (et = L), a.arraySet($.window, O, c - L, et, $.wnext), (L -= et) ? (a.arraySet($.window, O, c - L, L, 0), $.wnext = L, $.whave = $.wsize) : ($.wnext += et, $.wnext === $.wsize && ($.wnext = 0), $.whave < $.wsize && ($.whave += et))), 0;
            }
            n.inflateReset = A, n.inflateReset2 = E, n.inflateResetKeep = C, n.inflateInit = function(S) {
              return D(S, 15);
            }, n.inflateInit2 = D, n.inflate = function(S, O) {
              var c, L, et, $, rt, H, tt, R, B, J, q, G, mt, yt, at, it, kt, gt, Pt, xt, s, F, M, g, p = 0, x = new a.Buf8(4), j = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
              if (!S || !S.state || !S.output || !S.input && S.avail_in !== 0) return d;
              (c = S.state).mode === 12 && (c.mode = 13), rt = S.next_out, et = S.output, tt = S.avail_out, $ = S.next_in, L = S.input, H = S.avail_in, R = c.hold, B = c.bits, J = H, q = tt, F = w;
              t: for (; ; ) switch (c.mode) {
                case k:
                  if (c.wrap === 0) {
                    c.mode = 13;
                    break;
                  }
                  for (; B < 16; ) {
                    if (H === 0) break t;
                    H--, R += L[$++] << B, B += 8;
                  }
                  if (2 & c.wrap && R === 35615) {
                    x[c.check = 0] = 255 & R, x[1] = R >>> 8 & 255, c.check = o(c.check, x, 2, 0), B = R = 0, c.mode = 2;
                    break;
                  }
                  if (c.flags = 0, c.head && (c.head.done = false), !(1 & c.wrap) || (((255 & R) << 8) + (R >> 8)) % 31) {
                    S.msg = "incorrect header check", c.mode = 30;
                    break;
                  }
                  if ((15 & R) != 8) {
                    S.msg = "unknown compression method", c.mode = 30;
                    break;
                  }
                  if (B -= 4, s = 8 + (15 & (R >>>= 4)), c.wbits === 0) c.wbits = s;
                  else if (s > c.wbits) {
                    S.msg = "invalid window size", c.mode = 30;
                    break;
                  }
                  c.dmax = 1 << s, S.adler = c.check = 1, c.mode = 512 & R ? 10 : 12, B = R = 0;
                  break;
                case 2:
                  for (; B < 16; ) {
                    if (H === 0) break t;
                    H--, R += L[$++] << B, B += 8;
                  }
                  if (c.flags = R, (255 & c.flags) != 8) {
                    S.msg = "unknown compression method", c.mode = 30;
                    break;
                  }
                  if (57344 & c.flags) {
                    S.msg = "unknown header flags set", c.mode = 30;
                    break;
                  }
                  c.head && (c.head.text = R >> 8 & 1), 512 & c.flags && (x[0] = 255 & R, x[1] = R >>> 8 & 255, c.check = o(c.check, x, 2, 0)), B = R = 0, c.mode = 3;
                case 3:
                  for (; B < 32; ) {
                    if (H === 0) break t;
                    H--, R += L[$++] << B, B += 8;
                  }
                  c.head && (c.head.time = R), 512 & c.flags && (x[0] = 255 & R, x[1] = R >>> 8 & 255, x[2] = R >>> 16 & 255, x[3] = R >>> 24 & 255, c.check = o(c.check, x, 4, 0)), B = R = 0, c.mode = 4;
                case 4:
                  for (; B < 16; ) {
                    if (H === 0) break t;
                    H--, R += L[$++] << B, B += 8;
                  }
                  c.head && (c.head.xflags = 255 & R, c.head.os = R >> 8), 512 & c.flags && (x[0] = 255 & R, x[1] = R >>> 8 & 255, c.check = o(c.check, x, 2, 0)), B = R = 0, c.mode = 5;
                case 5:
                  if (1024 & c.flags) {
                    for (; B < 16; ) {
                      if (H === 0) break t;
                      H--, R += L[$++] << B, B += 8;
                    }
                    c.length = R, c.head && (c.head.extra_len = R), 512 & c.flags && (x[0] = 255 & R, x[1] = R >>> 8 & 255, c.check = o(c.check, x, 2, 0)), B = R = 0;
                  } else c.head && (c.head.extra = null);
                  c.mode = 6;
                case 6:
                  if (1024 & c.flags && (H < (G = c.length) && (G = H), G && (c.head && (s = c.head.extra_len - c.length, c.head.extra || (c.head.extra = new Array(c.head.extra_len)), a.arraySet(c.head.extra, L, $, G, s)), 512 & c.flags && (c.check = o(c.check, L, G, $)), H -= G, $ += G, c.length -= G), c.length)) break t;
                  c.length = 0, c.mode = 7;
                case 7:
                  if (2048 & c.flags) {
                    if (H === 0) break t;
                    for (G = 0; s = L[$ + G++], c.head && s && c.length < 65536 && (c.head.name += String.fromCharCode(s)), s && G < H; ) ;
                    if (512 & c.flags && (c.check = o(c.check, L, G, $)), H -= G, $ += G, s) break t;
                  } else c.head && (c.head.name = null);
                  c.length = 0, c.mode = 8;
                case 8:
                  if (4096 & c.flags) {
                    if (H === 0) break t;
                    for (G = 0; s = L[$ + G++], c.head && s && c.length < 65536 && (c.head.comment += String.fromCharCode(s)), s && G < H; ) ;
                    if (512 & c.flags && (c.check = o(c.check, L, G, $)), H -= G, $ += G, s) break t;
                  } else c.head && (c.head.comment = null);
                  c.mode = 9;
                case 9:
                  if (512 & c.flags) {
                    for (; B < 16; ) {
                      if (H === 0) break t;
                      H--, R += L[$++] << B, B += 8;
                    }
                    if (R !== (65535 & c.check)) {
                      S.msg = "header crc mismatch", c.mode = 30;
                      break;
                    }
                    B = R = 0;
                  }
                  c.head && (c.head.hcrc = c.flags >> 9 & 1, c.head.done = true), S.adler = c.check = 0, c.mode = 12;
                  break;
                case 10:
                  for (; B < 32; ) {
                    if (H === 0) break t;
                    H--, R += L[$++] << B, B += 8;
                  }
                  S.adler = c.check = f(R), B = R = 0, c.mode = 11;
                case 11:
                  if (c.havedict === 0) return S.next_out = rt, S.avail_out = tt, S.next_in = $, S.avail_in = H, c.hold = R, c.bits = B, 2;
                  S.adler = c.check = 1, c.mode = 12;
                case 12:
                  if (O === 5 || O === 6) break t;
                case 13:
                  if (c.last) {
                    R >>>= 7 & B, B -= 7 & B, c.mode = 27;
                    break;
                  }
                  for (; B < 3; ) {
                    if (H === 0) break t;
                    H--, R += L[$++] << B, B += 8;
                  }
                  switch (c.last = 1 & R, B -= 1, 3 & (R >>>= 1)) {
                    case 0:
                      c.mode = 14;
                      break;
                    case 1:
                      if (X(c), c.mode = 20, O !== 6) break;
                      R >>>= 2, B -= 2;
                      break t;
                    case 2:
                      c.mode = 17;
                      break;
                    case 3:
                      S.msg = "invalid block type", c.mode = 30;
                  }
                  R >>>= 2, B -= 2;
                  break;
                case 14:
                  for (R >>>= 7 & B, B -= 7 & B; B < 32; ) {
                    if (H === 0) break t;
                    H--, R += L[$++] << B, B += 8;
                  }
                  if ((65535 & R) != (R >>> 16 ^ 65535)) {
                    S.msg = "invalid stored block lengths", c.mode = 30;
                    break;
                  }
                  if (c.length = 65535 & R, B = R = 0, c.mode = 15, O === 6) break t;
                case 15:
                  c.mode = 16;
                case 16:
                  if (G = c.length) {
                    if (H < G && (G = H), tt < G && (G = tt), G === 0) break t;
                    a.arraySet(et, L, $, G, rt), H -= G, $ += G, tt -= G, rt += G, c.length -= G;
                    break;
                  }
                  c.mode = 12;
                  break;
                case 17:
                  for (; B < 14; ) {
                    if (H === 0) break t;
                    H--, R += L[$++] << B, B += 8;
                  }
                  if (c.nlen = 257 + (31 & R), R >>>= 5, B -= 5, c.ndist = 1 + (31 & R), R >>>= 5, B -= 5, c.ncode = 4 + (15 & R), R >>>= 4, B -= 4, 286 < c.nlen || 30 < c.ndist) {
                    S.msg = "too many length or distance symbols", c.mode = 30;
                    break;
                  }
                  c.have = 0, c.mode = 18;
                case 18:
                  for (; c.have < c.ncode; ) {
                    for (; B < 3; ) {
                      if (H === 0) break t;
                      H--, R += L[$++] << B, B += 8;
                    }
                    c.lens[j[c.have++]] = 7 & R, R >>>= 3, B -= 3;
                  }
                  for (; c.have < 19; ) c.lens[j[c.have++]] = 0;
                  if (c.lencode = c.lendyn, c.lenbits = 7, M = { bits: c.lenbits }, F = b(0, c.lens, 0, 19, c.lencode, 0, c.work, M), c.lenbits = M.bits, F) {
                    S.msg = "invalid code lengths set", c.mode = 30;
                    break;
                  }
                  c.have = 0, c.mode = 19;
                case 19:
                  for (; c.have < c.nlen + c.ndist; ) {
                    for (; it = (p = c.lencode[R & (1 << c.lenbits) - 1]) >>> 16 & 255, kt = 65535 & p, !((at = p >>> 24) <= B); ) {
                      if (H === 0) break t;
                      H--, R += L[$++] << B, B += 8;
                    }
                    if (kt < 16) R >>>= at, B -= at, c.lens[c.have++] = kt;
                    else {
                      if (kt === 16) {
                        for (g = at + 2; B < g; ) {
                          if (H === 0) break t;
                          H--, R += L[$++] << B, B += 8;
                        }
                        if (R >>>= at, B -= at, c.have === 0) {
                          S.msg = "invalid bit length repeat", c.mode = 30;
                          break;
                        }
                        s = c.lens[c.have - 1], G = 3 + (3 & R), R >>>= 2, B -= 2;
                      } else if (kt === 17) {
                        for (g = at + 3; B < g; ) {
                          if (H === 0) break t;
                          H--, R += L[$++] << B, B += 8;
                        }
                        B -= at, s = 0, G = 3 + (7 & (R >>>= at)), R >>>= 3, B -= 3;
                      } else {
                        for (g = at + 7; B < g; ) {
                          if (H === 0) break t;
                          H--, R += L[$++] << B, B += 8;
                        }
                        B -= at, s = 0, G = 11 + (127 & (R >>>= at)), R >>>= 7, B -= 7;
                      }
                      if (c.have + G > c.nlen + c.ndist) {
                        S.msg = "invalid bit length repeat", c.mode = 30;
                        break;
                      }
                      for (; G--; ) c.lens[c.have++] = s;
                    }
                  }
                  if (c.mode === 30) break;
                  if (c.lens[256] === 0) {
                    S.msg = "invalid code -- missing end-of-block", c.mode = 30;
                    break;
                  }
                  if (c.lenbits = 9, M = { bits: c.lenbits }, F = b(y, c.lens, 0, c.nlen, c.lencode, 0, c.work, M), c.lenbits = M.bits, F) {
                    S.msg = "invalid literal/lengths set", c.mode = 30;
                    break;
                  }
                  if (c.distbits = 6, c.distcode = c.distdyn, M = { bits: c.distbits }, F = b(_, c.lens, c.nlen, c.ndist, c.distcode, 0, c.work, M), c.distbits = M.bits, F) {
                    S.msg = "invalid distances set", c.mode = 30;
                    break;
                  }
                  if (c.mode = 20, O === 6) break t;
                case 20:
                  c.mode = 21;
                case 21:
                  if (6 <= H && 258 <= tt) {
                    S.next_out = rt, S.avail_out = tt, S.next_in = $, S.avail_in = H, c.hold = R, c.bits = B, u(S, q), rt = S.next_out, et = S.output, tt = S.avail_out, $ = S.next_in, L = S.input, H = S.avail_in, R = c.hold, B = c.bits, c.mode === 12 && (c.back = -1);
                    break;
                  }
                  for (c.back = 0; it = (p = c.lencode[R & (1 << c.lenbits) - 1]) >>> 16 & 255, kt = 65535 & p, !((at = p >>> 24) <= B); ) {
                    if (H === 0) break t;
                    H--, R += L[$++] << B, B += 8;
                  }
                  if (it && !(240 & it)) {
                    for (gt = at, Pt = it, xt = kt; it = (p = c.lencode[xt + ((R & (1 << gt + Pt) - 1) >> gt)]) >>> 16 & 255, kt = 65535 & p, !(gt + (at = p >>> 24) <= B); ) {
                      if (H === 0) break t;
                      H--, R += L[$++] << B, B += 8;
                    }
                    R >>>= gt, B -= gt, c.back += gt;
                  }
                  if (R >>>= at, B -= at, c.back += at, c.length = kt, it === 0) {
                    c.mode = 26;
                    break;
                  }
                  if (32 & it) {
                    c.back = -1, c.mode = 12;
                    break;
                  }
                  if (64 & it) {
                    S.msg = "invalid literal/length code", c.mode = 30;
                    break;
                  }
                  c.extra = 15 & it, c.mode = 22;
                case 22:
                  if (c.extra) {
                    for (g = c.extra; B < g; ) {
                      if (H === 0) break t;
                      H--, R += L[$++] << B, B += 8;
                    }
                    c.length += R & (1 << c.extra) - 1, R >>>= c.extra, B -= c.extra, c.back += c.extra;
                  }
                  c.was = c.length, c.mode = 23;
                case 23:
                  for (; it = (p = c.distcode[R & (1 << c.distbits) - 1]) >>> 16 & 255, kt = 65535 & p, !((at = p >>> 24) <= B); ) {
                    if (H === 0) break t;
                    H--, R += L[$++] << B, B += 8;
                  }
                  if (!(240 & it)) {
                    for (gt = at, Pt = it, xt = kt; it = (p = c.distcode[xt + ((R & (1 << gt + Pt) - 1) >> gt)]) >>> 16 & 255, kt = 65535 & p, !(gt + (at = p >>> 24) <= B); ) {
                      if (H === 0) break t;
                      H--, R += L[$++] << B, B += 8;
                    }
                    R >>>= gt, B -= gt, c.back += gt;
                  }
                  if (R >>>= at, B -= at, c.back += at, 64 & it) {
                    S.msg = "invalid distance code", c.mode = 30;
                    break;
                  }
                  c.offset = kt, c.extra = 15 & it, c.mode = 24;
                case 24:
                  if (c.extra) {
                    for (g = c.extra; B < g; ) {
                      if (H === 0) break t;
                      H--, R += L[$++] << B, B += 8;
                    }
                    c.offset += R & (1 << c.extra) - 1, R >>>= c.extra, B -= c.extra, c.back += c.extra;
                  }
                  if (c.offset > c.dmax) {
                    S.msg = "invalid distance too far back", c.mode = 30;
                    break;
                  }
                  c.mode = 25;
                case 25:
                  if (tt === 0) break t;
                  if (G = q - tt, c.offset > G) {
                    if ((G = c.offset - G) > c.whave && c.sane) {
                      S.msg = "invalid distance too far back", c.mode = 30;
                      break;
                    }
                    mt = G > c.wnext ? (G -= c.wnext, c.wsize - G) : c.wnext - G, G > c.length && (G = c.length), yt = c.window;
                  } else yt = et, mt = rt - c.offset, G = c.length;
                  for (tt < G && (G = tt), tt -= G, c.length -= G; et[rt++] = yt[mt++], --G; ) ;
                  c.length === 0 && (c.mode = 21);
                  break;
                case 26:
                  if (tt === 0) break t;
                  et[rt++] = c.length, tt--, c.mode = 21;
                  break;
                case 27:
                  if (c.wrap) {
                    for (; B < 32; ) {
                      if (H === 0) break t;
                      H--, R |= L[$++] << B, B += 8;
                    }
                    if (q -= tt, S.total_out += q, c.total += q, q && (S.adler = c.check = c.flags ? o(c.check, et, q, rt - q) : l(c.check, et, q, rt - q)), q = tt, (c.flags ? R : f(R)) !== c.check) {
                      S.msg = "incorrect data check", c.mode = 30;
                      break;
                    }
                    B = R = 0;
                  }
                  c.mode = 28;
                case 28:
                  if (c.wrap && c.flags) {
                    for (; B < 32; ) {
                      if (H === 0) break t;
                      H--, R += L[$++] << B, B += 8;
                    }
                    if (R !== (4294967295 & c.total)) {
                      S.msg = "incorrect length check", c.mode = 30;
                      break;
                    }
                    B = R = 0;
                  }
                  c.mode = 29;
                case 29:
                  F = 1;
                  break t;
                case 30:
                  F = -3;
                  break t;
                case 31:
                  return -4;
                case 32:
                default:
                  return d;
              }
              return S.next_out = rt, S.avail_out = tt, S.next_in = $, S.avail_in = H, c.hold = R, c.bits = B, (c.wsize || q !== S.avail_out && c.mode < 30 && (c.mode < 27 || O !== 4)) && Q(S, S.output, S.next_out, q - S.avail_out) ? (c.mode = 31, -4) : (J -= S.avail_in, q -= S.avail_out, S.total_in += J, S.total_out += q, c.total += q, c.wrap && q && (S.adler = c.check = c.flags ? o(c.check, et, q, S.next_out - q) : l(c.check, et, q, S.next_out - q)), S.data_type = c.bits + (c.last ? 64 : 0) + (c.mode === 12 ? 128 : 0) + (c.mode === 20 || c.mode === 15 ? 256 : 0), (J == 0 && q === 0 || O === 4) && F === w && (F = -5), F);
            }, n.inflateEnd = function(S) {
              if (!S || !S.state) return d;
              var O = S.state;
              return O.window && (O.window = null), S.state = null, w;
            }, n.inflateGetHeader = function(S, O) {
              var c;
              return S && S.state && 2 & (c = S.state).wrap ? ((c.head = O).done = false, w) : d;
            }, n.inflateSetDictionary = function(S, O) {
              var c, L = O.length;
              return S && S.state ? (c = S.state).wrap !== 0 && c.mode !== 11 ? d : c.mode === 11 && l(1, O, L, 0) !== c.check ? -3 : Q(S, O, L, L) ? (c.mode = 31, -4) : (c.havedict = 1, w) : d;
            }, n.inflateInfo = "pako inflate (from Nodeca project)";
          }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(t, r, n) {
            var a = t("../utils/common"), l = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], u = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], b = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
            r.exports = function(y, _, w, d, k, h, m, f) {
              var v, C, A, E, D, I, W, T, X, Q = f.bits, S = 0, O = 0, c = 0, L = 0, et = 0, $ = 0, rt = 0, H = 0, tt = 0, R = 0, B = null, J = 0, q = new a.Buf16(16), G = new a.Buf16(16), mt = null, yt = 0;
              for (S = 0; S <= 15; S++) q[S] = 0;
              for (O = 0; O < d; O++) q[_[w + O]]++;
              for (et = Q, L = 15; 1 <= L && q[L] === 0; L--) ;
              if (L < et && (et = L), L === 0) return k[h++] = 20971520, k[h++] = 20971520, f.bits = 1, 0;
              for (c = 1; c < L && q[c] === 0; c++) ;
              for (et < c && (et = c), S = H = 1; S <= 15; S++) if (H <<= 1, (H -= q[S]) < 0) return -1;
              if (0 < H && (y === 0 || L !== 1)) return -1;
              for (G[1] = 0, S = 1; S < 15; S++) G[S + 1] = G[S] + q[S];
              for (O = 0; O < d; O++) _[w + O] !== 0 && (m[G[_[w + O]]++] = O);
              if (I = y === 0 ? (B = mt = m, 19) : y === 1 ? (B = l, J -= 257, mt = o, yt -= 257, 256) : (B = u, mt = b, -1), S = c, D = h, rt = O = R = 0, A = -1, E = (tt = 1 << ($ = et)) - 1, y === 1 && 852 < tt || y === 2 && 592 < tt) return 1;
              for (; ; ) {
                for (W = S - rt, X = m[O] < I ? (T = 0, m[O]) : m[O] > I ? (T = mt[yt + m[O]], B[J + m[O]]) : (T = 96, 0), v = 1 << S - rt, c = C = 1 << $; k[D + (R >> rt) + (C -= v)] = W << 24 | T << 16 | X | 0, C !== 0; ) ;
                for (v = 1 << S - 1; R & v; ) v >>= 1;
                if (v !== 0 ? (R &= v - 1, R += v) : R = 0, O++, --q[S] == 0) {
                  if (S === L) break;
                  S = _[w + m[O]];
                }
                if (et < S && (R & E) !== A) {
                  for (rt === 0 && (rt = et), D += c, H = 1 << ($ = S - rt); $ + rt < L && !((H -= q[$ + rt]) <= 0); ) $++, H <<= 1;
                  if (tt += 1 << $, y === 1 && 852 < tt || y === 2 && 592 < tt) return 1;
                  k[A = R & E] = et << 24 | $ << 16 | D - h | 0;
                }
              }
              return R !== 0 && (k[D + R] = S - rt << 24 | 64 << 16 | 0), f.bits = et, 0;
            };
          }, { "../utils/common": 41 }], 51: [function(t, r, n) {
            r.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
          }, {}], 52: [function(t, r, n) {
            var a = t("../utils/common"), l = 0, o = 1;
            function u(p) {
              for (var x = p.length; 0 <= --x; ) p[x] = 0;
            }
            var b = 0, y = 29, _ = 256, w = _ + 1 + y, d = 30, k = 19, h = 2 * w + 1, m = 15, f = 16, v = 7, C = 256, A = 16, E = 17, D = 18, I = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], W = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], T = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], X = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], Q = new Array(2 * (w + 2));
            u(Q);
            var S = new Array(2 * d);
            u(S);
            var O = new Array(512);
            u(O);
            var c = new Array(256);
            u(c);
            var L = new Array(y);
            u(L);
            var et, $, rt, H = new Array(d);
            function tt(p, x, j, U, N) {
              this.static_tree = p, this.extra_bits = x, this.extra_base = j, this.elems = U, this.max_length = N, this.has_stree = p && p.length;
            }
            function R(p, x) {
              this.dyn_tree = p, this.max_code = 0, this.stat_desc = x;
            }
            function B(p) {
              return p < 256 ? O[p] : O[256 + (p >>> 7)];
            }
            function J(p, x) {
              p.pending_buf[p.pending++] = 255 & x, p.pending_buf[p.pending++] = x >>> 8 & 255;
            }
            function q(p, x, j) {
              p.bi_valid > f - j ? (p.bi_buf |= x << p.bi_valid & 65535, J(p, p.bi_buf), p.bi_buf = x >> f - p.bi_valid, p.bi_valid += j - f) : (p.bi_buf |= x << p.bi_valid & 65535, p.bi_valid += j);
            }
            function G(p, x, j) {
              q(p, j[2 * x], j[2 * x + 1]);
            }
            function mt(p, x) {
              for (var j = 0; j |= 1 & p, p >>>= 1, j <<= 1, 0 < --x; ) ;
              return j >>> 1;
            }
            function yt(p, x, j) {
              var U, N, Z = new Array(m + 1), K = 0;
              for (U = 1; U <= m; U++) Z[U] = K = K + j[U - 1] << 1;
              for (N = 0; N <= x; N++) {
                var V = p[2 * N + 1];
                V !== 0 && (p[2 * N] = mt(Z[V]++, V));
              }
            }
            function at(p) {
              var x;
              for (x = 0; x < w; x++) p.dyn_ltree[2 * x] = 0;
              for (x = 0; x < d; x++) p.dyn_dtree[2 * x] = 0;
              for (x = 0; x < k; x++) p.bl_tree[2 * x] = 0;
              p.dyn_ltree[2 * C] = 1, p.opt_len = p.static_len = 0, p.last_lit = p.matches = 0;
            }
            function it(p) {
              8 < p.bi_valid ? J(p, p.bi_buf) : 0 < p.bi_valid && (p.pending_buf[p.pending++] = p.bi_buf), p.bi_buf = 0, p.bi_valid = 0;
            }
            function kt(p, x, j, U) {
              var N = 2 * x, Z = 2 * j;
              return p[N] < p[Z] || p[N] === p[Z] && U[x] <= U[j];
            }
            function gt(p, x, j) {
              for (var U = p.heap[j], N = j << 1; N <= p.heap_len && (N < p.heap_len && kt(x, p.heap[N + 1], p.heap[N], p.depth) && N++, !kt(x, U, p.heap[N], p.depth)); ) p.heap[j] = p.heap[N], j = N, N <<= 1;
              p.heap[j] = U;
            }
            function Pt(p, x, j) {
              var U, N, Z, K, V = 0;
              if (p.last_lit !== 0) for (; U = p.pending_buf[p.d_buf + 2 * V] << 8 | p.pending_buf[p.d_buf + 2 * V + 1], N = p.pending_buf[p.l_buf + V], V++, U === 0 ? G(p, N, x) : (G(p, (Z = c[N]) + _ + 1, x), (K = I[Z]) !== 0 && q(p, N -= L[Z], K), G(p, Z = B(--U), j), (K = W[Z]) !== 0 && q(p, U -= H[Z], K)), V < p.last_lit; ) ;
              G(p, C, x);
            }
            function xt(p, x) {
              var j, U, N, Z = x.dyn_tree, K = x.stat_desc.static_tree, V = x.stat_desc.has_stree, Y = x.stat_desc.elems, lt = -1;
              for (p.heap_len = 0, p.heap_max = h, j = 0; j < Y; j++) Z[2 * j] !== 0 ? (p.heap[++p.heap_len] = lt = j, p.depth[j] = 0) : Z[2 * j + 1] = 0;
              for (; p.heap_len < 2; ) Z[2 * (N = p.heap[++p.heap_len] = lt < 2 ? ++lt : 0)] = 1, p.depth[N] = 0, p.opt_len--, V && (p.static_len -= K[2 * N + 1]);
              for (x.max_code = lt, j = p.heap_len >> 1; 1 <= j; j--) gt(p, Z, j);
              for (N = Y; j = p.heap[1], p.heap[1] = p.heap[p.heap_len--], gt(p, Z, 1), U = p.heap[1], p.heap[--p.heap_max] = j, p.heap[--p.heap_max] = U, Z[2 * N] = Z[2 * j] + Z[2 * U], p.depth[N] = (p.depth[j] >= p.depth[U] ? p.depth[j] : p.depth[U]) + 1, Z[2 * j + 1] = Z[2 * U + 1] = N, p.heap[1] = N++, gt(p, Z, 1), 2 <= p.heap_len; ) ;
              p.heap[--p.heap_max] = p.heap[1], function(st, Ct) {
                var jt, Et, Ut, bt, Kt, ie, At = Ct.dyn_tree, Be = Ct.max_code, fn = Ct.stat_desc.static_tree, pn = Ct.stat_desc.has_stree, mn = Ct.stat_desc.extra_bits, ze = Ct.stat_desc.extra_base, $t = Ct.stat_desc.max_length, Yt = 0;
                for (bt = 0; bt <= m; bt++) st.bl_count[bt] = 0;
                for (At[2 * st.heap[st.heap_max] + 1] = 0, jt = st.heap_max + 1; jt < h; jt++) $t < (bt = At[2 * At[2 * (Et = st.heap[jt]) + 1] + 1] + 1) && (bt = $t, Yt++), At[2 * Et + 1] = bt, Be < Et || (st.bl_count[bt]++, Kt = 0, ze <= Et && (Kt = mn[Et - ze]), ie = At[2 * Et], st.opt_len += ie * (bt + Kt), pn && (st.static_len += ie * (fn[2 * Et + 1] + Kt)));
                if (Yt !== 0) {
                  do {
                    for (bt = $t - 1; st.bl_count[bt] === 0; ) bt--;
                    st.bl_count[bt]--, st.bl_count[bt + 1] += 2, st.bl_count[$t]--, Yt -= 2;
                  } while (0 < Yt);
                  for (bt = $t; bt !== 0; bt--) for (Et = st.bl_count[bt]; Et !== 0; ) Be < (Ut = st.heap[--jt]) || (At[2 * Ut + 1] !== bt && (st.opt_len += (bt - At[2 * Ut + 1]) * At[2 * Ut], At[2 * Ut + 1] = bt), Et--);
                }
              }(p, x), yt(Z, lt, p.bl_count);
            }
            function s(p, x, j) {
              var U, N, Z = -1, K = x[1], V = 0, Y = 7, lt = 4;
              for (K === 0 && (Y = 138, lt = 3), x[2 * (j + 1) + 1] = 65535, U = 0; U <= j; U++) N = K, K = x[2 * (U + 1) + 1], ++V < Y && N === K || (V < lt ? p.bl_tree[2 * N] += V : N !== 0 ? (N !== Z && p.bl_tree[2 * N]++, p.bl_tree[2 * A]++) : V <= 10 ? p.bl_tree[2 * E]++ : p.bl_tree[2 * D]++, Z = N, lt = (V = 0) === K ? (Y = 138, 3) : N === K ? (Y = 6, 3) : (Y = 7, 4));
            }
            function F(p, x, j) {
              var U, N, Z = -1, K = x[1], V = 0, Y = 7, lt = 4;
              for (K === 0 && (Y = 138, lt = 3), U = 0; U <= j; U++) if (N = K, K = x[2 * (U + 1) + 1], !(++V < Y && N === K)) {
                if (V < lt) for (; G(p, N, p.bl_tree), --V != 0; ) ;
                else N !== 0 ? (N !== Z && (G(p, N, p.bl_tree), V--), G(p, A, p.bl_tree), q(p, V - 3, 2)) : V <= 10 ? (G(p, E, p.bl_tree), q(p, V - 3, 3)) : (G(p, D, p.bl_tree), q(p, V - 11, 7));
                Z = N, lt = (V = 0) === K ? (Y = 138, 3) : N === K ? (Y = 6, 3) : (Y = 7, 4);
              }
            }
            u(H);
            var M = false;
            function g(p, x, j, U) {
              q(p, (b << 1) + (U ? 1 : 0), 3), function(N, Z, K, V) {
                it(N), V && (J(N, K), J(N, ~K)), a.arraySet(N.pending_buf, N.window, Z, K, N.pending), N.pending += K;
              }(p, x, j, true);
            }
            n._tr_init = function(p) {
              M || (function() {
                var x, j, U, N, Z, K = new Array(m + 1);
                for (N = U = 0; N < y - 1; N++) for (L[N] = U, x = 0; x < 1 << I[N]; x++) c[U++] = N;
                for (c[U - 1] = N, N = Z = 0; N < 16; N++) for (H[N] = Z, x = 0; x < 1 << W[N]; x++) O[Z++] = N;
                for (Z >>= 7; N < d; N++) for (H[N] = Z << 7, x = 0; x < 1 << W[N] - 7; x++) O[256 + Z++] = N;
                for (j = 0; j <= m; j++) K[j] = 0;
                for (x = 0; x <= 143; ) Q[2 * x + 1] = 8, x++, K[8]++;
                for (; x <= 255; ) Q[2 * x + 1] = 9, x++, K[9]++;
                for (; x <= 279; ) Q[2 * x + 1] = 7, x++, K[7]++;
                for (; x <= 287; ) Q[2 * x + 1] = 8, x++, K[8]++;
                for (yt(Q, w + 1, K), x = 0; x < d; x++) S[2 * x + 1] = 5, S[2 * x] = mt(x, 5);
                et = new tt(Q, I, _ + 1, w, m), $ = new tt(S, W, 0, d, m), rt = new tt(new Array(0), T, 0, k, v);
              }(), M = true), p.l_desc = new R(p.dyn_ltree, et), p.d_desc = new R(p.dyn_dtree, $), p.bl_desc = new R(p.bl_tree, rt), p.bi_buf = 0, p.bi_valid = 0, at(p);
            }, n._tr_stored_block = g, n._tr_flush_block = function(p, x, j, U) {
              var N, Z, K = 0;
              0 < p.level ? (p.strm.data_type === 2 && (p.strm.data_type = function(V) {
                var Y, lt = 4093624447;
                for (Y = 0; Y <= 31; Y++, lt >>>= 1) if (1 & lt && V.dyn_ltree[2 * Y] !== 0) return l;
                if (V.dyn_ltree[18] !== 0 || V.dyn_ltree[20] !== 0 || V.dyn_ltree[26] !== 0) return o;
                for (Y = 32; Y < _; Y++) if (V.dyn_ltree[2 * Y] !== 0) return o;
                return l;
              }(p)), xt(p, p.l_desc), xt(p, p.d_desc), K = function(V) {
                var Y;
                for (s(V, V.dyn_ltree, V.l_desc.max_code), s(V, V.dyn_dtree, V.d_desc.max_code), xt(V, V.bl_desc), Y = k - 1; 3 <= Y && V.bl_tree[2 * X[Y] + 1] === 0; Y--) ;
                return V.opt_len += 3 * (Y + 1) + 5 + 5 + 4, Y;
              }(p), N = p.opt_len + 3 + 7 >>> 3, (Z = p.static_len + 3 + 7 >>> 3) <= N && (N = Z)) : N = Z = j + 5, j + 4 <= N && x !== -1 ? g(p, x, j, U) : p.strategy === 4 || Z === N ? (q(p, 2 + (U ? 1 : 0), 3), Pt(p, Q, S)) : (q(p, 4 + (U ? 1 : 0), 3), function(V, Y, lt, st) {
                var Ct;
                for (q(V, Y - 257, 5), q(V, lt - 1, 5), q(V, st - 4, 4), Ct = 0; Ct < st; Ct++) q(V, V.bl_tree[2 * X[Ct] + 1], 3);
                F(V, V.dyn_ltree, Y - 1), F(V, V.dyn_dtree, lt - 1);
              }(p, p.l_desc.max_code + 1, p.d_desc.max_code + 1, K + 1), Pt(p, p.dyn_ltree, p.dyn_dtree)), at(p), U && it(p);
            }, n._tr_tally = function(p, x, j) {
              return p.pending_buf[p.d_buf + 2 * p.last_lit] = x >>> 8 & 255, p.pending_buf[p.d_buf + 2 * p.last_lit + 1] = 255 & x, p.pending_buf[p.l_buf + p.last_lit] = 255 & j, p.last_lit++, x === 0 ? p.dyn_ltree[2 * j]++ : (p.matches++, x--, p.dyn_ltree[2 * (c[j] + _ + 1)]++, p.dyn_dtree[2 * B(x)]++), p.last_lit === p.lit_bufsize - 1;
            }, n._tr_align = function(p) {
              q(p, 2, 3), G(p, C, Q), function(x) {
                x.bi_valid === 16 ? (J(x, x.bi_buf), x.bi_buf = 0, x.bi_valid = 0) : 8 <= x.bi_valid && (x.pending_buf[x.pending++] = 255 & x.bi_buf, x.bi_buf >>= 8, x.bi_valid -= 8);
              }(p);
            };
          }, { "../utils/common": 41 }], 53: [function(t, r, n) {
            r.exports = function() {
              this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
            };
          }, {}], 54: [function(t, r, n) {
            (function(a) {
              (function(l, o) {
                if (!l.setImmediate) {
                  var u, b, y, _, w = 1, d = {}, k = false, h = l.document, m = Object.getPrototypeOf && Object.getPrototypeOf(l);
                  m = m && m.setTimeout ? m : l, u = {}.toString.call(l.process) === "[object process]" ? function(A) {
                    process.nextTick(function() {
                      v(A);
                    });
                  } : function() {
                    if (l.postMessage && !l.importScripts) {
                      var A = true, E = l.onmessage;
                      return l.onmessage = function() {
                        A = false;
                      }, l.postMessage("", "*"), l.onmessage = E, A;
                    }
                  }() ? (_ = "setImmediate$" + Math.random() + "$", l.addEventListener ? l.addEventListener("message", C, false) : l.attachEvent("onmessage", C), function(A) {
                    l.postMessage(_ + A, "*");
                  }) : l.MessageChannel ? ((y = new MessageChannel()).port1.onmessage = function(A) {
                    v(A.data);
                  }, function(A) {
                    y.port2.postMessage(A);
                  }) : h && "onreadystatechange" in h.createElement("script") ? (b = h.documentElement, function(A) {
                    var E = h.createElement("script");
                    E.onreadystatechange = function() {
                      v(A), E.onreadystatechange = null, b.removeChild(E), E = null;
                    }, b.appendChild(E);
                  }) : function(A) {
                    setTimeout(v, 0, A);
                  }, m.setImmediate = function(A) {
                    typeof A != "function" && (A = new Function("" + A));
                    for (var E = new Array(arguments.length - 1), D = 0; D < E.length; D++) E[D] = arguments[D + 1];
                    var I = { callback: A, args: E };
                    return d[w] = I, u(w), w++;
                  }, m.clearImmediate = f;
                }
                function f(A) {
                  delete d[A];
                }
                function v(A) {
                  if (k) setTimeout(v, 0, A);
                  else {
                    var E = d[A];
                    if (E) {
                      k = true;
                      try {
                        (function(D) {
                          var I = D.callback, W = D.args;
                          switch (W.length) {
                            case 0:
                              I();
                              break;
                            case 1:
                              I(W[0]);
                              break;
                            case 2:
                              I(W[0], W[1]);
                              break;
                            case 3:
                              I(W[0], W[1], W[2]);
                              break;
                            default:
                              I.apply(o, W);
                          }
                        })(E);
                      } finally {
                        f(A), k = false;
                      }
                    }
                  }
                }
                function C(A) {
                  A.source === l && typeof A.data == "string" && A.data.indexOf(_) === 0 && v(+A.data.slice(_.length));
                }
              })(typeof self == "undefined" ? a === void 0 ? this : a : self);
            }).call(this, typeof vt != "undefined" ? vt : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
          }, {}] }, {}, [10])(10);
        });
      })(Ht);
      var Qt = Ht.exports;
      const It = Jt(Qt);
      var ot;
      (function(i) {
        i.OfficeDocument = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument", i.FontTable = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable", i.Image = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", i.Numbering = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering", i.Styles = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles", i.StylesWithEffects = "http://schemas.microsoft.com/office/2007/relationships/stylesWithEffects", i.Theme = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme", i.Settings = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings", i.WebSettings = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings", i.Hyperlink = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink", i.Footnotes = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes", i.Endnotes = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/endnotes", i.Footer = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer", i.Header = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header", i.ExtendedProperties = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties", i.CoreProperties = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties", i.CustomProperties = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/custom-properties", i.Comments = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments", i.CommentsExtended = "http://schemas.microsoft.com/office/2011/relationships/commentsExtended";
      })(ot || (ot = {}));
      function Ot(i, e) {
        return e.elements(i).map((t) => ({ id: e.attr(t, "Id"), type: e.attr(t, "Type"), target: e.attr(t, "Target"), targetMode: e.attr(t, "TargetMode") }));
      }
      const oe = { wordml: "http://schemas.openxmlformats.org/wordprocessingml/2006/main", drawingml: "http://schemas.openxmlformats.org/drawingml/2006/main", picture: "http://schemas.openxmlformats.org/drawingml/2006/picture", compatibility: "http://schemas.openxmlformats.org/markup-compatibility/2006", math: "http://schemas.openxmlformats.org/officeDocument/2006/math" }, pt = { Dxa: { mul: 0.05, unit: "pt" }, Emu: { mul: 1 / 12700, unit: "pt" }, FontSize: { mul: 0.5, unit: "pt" }, Border: { mul: 0.125, unit: "pt" }, Point: { mul: 1, unit: "pt" }, Percent: { mul: 0.02, unit: "%" }, LineHeight: { mul: 1 / 240, unit: "" }, VmlEmu: { mul: 1 / 12700, unit: "" } };
      function le(i, e = pt.Dxa) {
        return i == null || /.+(p[xt]|[%])$/.test(i) ? i : `${(parseInt(i) * e.mul).toFixed(2)}${e.unit}`;
      }
      function Te(i, e = false) {
        switch (i) {
          case "1":
            return true;
          case "0":
            return false;
          case "on":
            return true;
          case "off":
            return false;
          case "true":
            return true;
          case "false":
            return false;
          default:
            return e;
        }
      }
      function ce(i, e, t) {
        if (i.namespaceURI != oe.wordml) return false;
        switch (i.localName) {
          case "color":
            e.color = t.attr(i, "val");
            break;
          case "sz":
            e.fontSize = t.lengthAttr(i, "val", pt.FontSize);
            break;
          default:
            return false;
        }
        return true;
      }
      function Ie(i, e = false) {
        e && (i = i.replace(/<[?].*[?]>/, "")), i = Fe(i);
        const t = new DOMParser().parseFromString(i, "application/xml"), r = Oe(t);
        if (r) throw new Error(r);
        return t;
      }
      function Oe(i) {
        var e;
        return (e = i.getElementsByTagName("parsererror")[0]) == null ? void 0 : e.textContent;
      }
      function Fe(i) {
        return i.charCodeAt(0) === 65279 ? i.substring(1) : i;
      }
      function De(i) {
        return new XMLSerializer().serializeToString(i);
      }
      class he {
        elements(e, t = null) {
          const r = [];
          for (let n = 0, a = e.childNodes.length; n < a; n++) {
            let l = e.childNodes.item(n);
            l.nodeType == 1 && (t == null || l.localName == t) && r.push(l);
          }
          return r;
        }
        element(e, t) {
          for (let r = 0, n = e.childNodes.length; r < n; r++) {
            let a = e.childNodes.item(r);
            if (a.nodeType == 1 && a.localName == t) return a;
          }
          return null;
        }
        elementAttr(e, t, r) {
          var n = this.element(e, t);
          return n ? this.attr(n, r) : void 0;
        }
        attrs(e) {
          return Array.from(e.attributes);
        }
        attr(e, t) {
          for (let r = 0, n = e.attributes.length; r < n; r++) {
            let a = e.attributes.item(r);
            if (a.localName == t) return a.value;
          }
          return null;
        }
        intAttr(e, t, r = null) {
          var n = this.attr(e, t);
          return n ? parseInt(n) : r;
        }
        hexAttr(e, t, r = null) {
          var n = this.attr(e, t);
          return n ? parseInt(n, 16) : r;
        }
        floatAttr(e, t, r = null) {
          var n = this.attr(e, t);
          return n ? parseFloat(n) : r;
        }
        boolAttr(e, t, r = null) {
          return Te(this.attr(e, t), r);
        }
        lengthAttr(e, t, r = pt.Dxa) {
          return le(this.attr(e, t), r);
        }
      }
      const P = new he();
      class St {
        constructor(e, t) {
          this._package = e, this.path = t;
        }
        load() {
          return wt(this, null, function* () {
            this.rels = yield this._package.loadRelationships(this.path);
            const e = yield this._package.load(this.path), t = this._package.parseXmlDocument(e);
            this._package.options.keepOrigin && (this._xmlDocument = t), this.parseXml(t.firstElementChild);
          });
        }
        save() {
          this._package.update(this.path, De(this._xmlDocument));
        }
        parseXml(e) {
        }
      }
      const Le = { embedRegular: "regular", embedBold: "bold", embedItalic: "italic", embedBoldItalic: "boldItalic" };
      function je(i, e) {
        return e.elements(i).map((t) => Ue(t, e));
      }
      function Ue(i, e) {
        let t = { name: e.attr(i, "name"), embedFontRefs: [] };
        for (let r of e.elements(i)) switch (r.localName) {
          case "family":
            t.family = e.attr(r, "val");
            break;
          case "altName":
            t.altName = e.attr(r, "val");
            break;
          case "embedRegular":
          case "embedBold":
          case "embedItalic":
          case "embedBoldItalic":
            t.embedFontRefs.push($e(r, e));
            break;
        }
        return t;
      }
      function $e(i, e) {
        return { id: e.attr(i, "id"), key: e.attr(i, "fontKey"), type: Le[i.localName] };
      }
      class We extends St {
        parseXml(e) {
          this.fonts = je(e, this._package.xmlParser);
        }
      }
      function He(i) {
        return i == null ? void 0 : i.replace(/[ .]+/g, "-").replace(/[&]+/g, "and").toLowerCase();
      }
      function Zt(i) {
        let e = i.lastIndexOf("/") + 1, t = e == 0 ? "" : i.substring(0, e), r = e == 0 ? i : i.substring(e);
        return [t, r];
      }
      function te(i, e) {
        try {
          const t = "http://docx/";
          return new URL(i, t + e).toString().substring(t.length);
        } catch (t) {
          return `${e}${i}`;
        }
      }
      function Nt(i, e) {
        return i.reduce((t, r) => (t[e(r)] = r, t), {});
      }
      function Ze(i) {
        return new Promise((e, t) => {
          const r = new FileReader();
          r.onloadend = () => e(r.result), r.onerror = () => t(), r.readAsDataURL(i);
        });
      }
      function ee(i) {
        return i && typeof i == "object" && !Array.isArray(i);
      }
      function Ve(i) {
        return typeof i == "string" || i instanceof String;
      }
      function Vt(i, ...e) {
        var r;
        if (!e.length) return i;
        const t = e.shift();
        if (ee(i) && ee(t)) for (const n in t) if (ee(t[n])) {
          const a = (r = i[n]) != null ? r : i[n] = {};
          Vt(a, t[n]);
        } else i[n] = t[n];
        return Vt(i, ...e);
      }
      function Ft(i) {
        return Array.isArray(i) ? i : [i];
      }
      class re {
        constructor(e, t) {
          this._zip = e, this.options = t, this.xmlParser = new he();
        }
        get(e) {
          var r;
          const t = Xe(e);
          return (r = this._zip.files[t]) != null ? r : this._zip.files[t.replace(/\//g, "\\")];
        }
        update(e, t) {
          this._zip.file(e, t);
        }
        static load(e, t) {
          return wt(this, null, function* () {
            const r = yield It.loadAsync(e);
            return new re(r, t);
          });
        }
        save(e = "blob") {
          return this._zip.generateAsync({ type: e });
        }
        load(e, t = "string") {
          var r, n;
          return (n = (r = this.get(e)) == null ? void 0 : r.async(t)) != null ? n : Promise.resolve(null);
        }
        loadRelationships(e = null) {
          return wt(this, null, function* () {
            let t = "_rels/.rels";
            if (e != null) {
              const [n, a] = Zt(e);
              t = `${n}_rels/${a}.rels`;
            }
            const r = yield this.load(t);
            return r ? Ot(this.parseXmlDocument(r).firstElementChild, this.xmlParser) : null;
          });
        }
        parseXmlDocument(e) {
          return Ie(e, this.options.trimXmlDeclaration);
        }
      }
      function Xe(i) {
        return i.startsWith("/") ? i.substr(1) : i;
      }
      class Ge extends St {
        constructor(e, t, r) {
          super(e, t), this._documentParser = r;
        }
        parseXml(e) {
          this.body = this._documentParser.parseDocumentFile(e);
        }
      }
      function Xt(i, e) {
        return { type: e.attr(i, "val"), color: e.attr(i, "color"), size: e.lengthAttr(i, "sz", pt.Border), offset: e.lengthAttr(i, "space", pt.Point), frame: e.boolAttr(i, "frame"), shadow: e.boolAttr(i, "shadow") };
      }
      function qe(i, e) {
        var t = {};
        for (let r of e.elements(i)) switch (r.localName) {
          case "left":
            t.left = Xt(r, e);
            break;
          case "top":
            t.top = Xt(r, e);
            break;
          case "right":
            t.right = Xt(r, e);
            break;
          case "bottom":
            t.bottom = Xt(r, e);
            break;
        }
        return t;
      }
      var ue;
      (function(i) {
        i.Continuous = "continuous", i.NextPage = "nextPage", i.NextColumn = "nextColumn", i.EvenPage = "evenPage", i.OddPage = "oddPage";
      })(ue || (ue = {}));
      function de(i, e = P) {
        var r, n;
        var t = {};
        for (let a of e.elements(i)) switch (a.localName) {
          case "pgSz":
            t.pageSize = { width: e.lengthAttr(a, "w"), height: e.lengthAttr(a, "h"), orientation: e.attr(a, "orient") };
            break;
          case "type":
            t.type = e.attr(a, "val");
            break;
          case "pgMar":
            t.pageMargins = { left: e.lengthAttr(a, "left"), right: e.lengthAttr(a, "right"), top: e.lengthAttr(a, "top"), bottom: e.lengthAttr(a, "bottom"), header: e.lengthAttr(a, "header"), footer: e.lengthAttr(a, "footer"), gutter: e.lengthAttr(a, "gutter") };
            break;
          case "cols":
            t.columns = Ke(a, e);
            break;
          case "headerReference":
            ((r = t.headerRefs) != null ? r : t.headerRefs = []).push(fe(a, e));
            break;
          case "footerReference":
            ((n = t.footerRefs) != null ? n : t.footerRefs = []).push(fe(a, e));
            break;
          case "titlePg":
            t.titlePage = e.boolAttr(a, "val", true);
            break;
          case "pgBorders":
            t.pageBorders = qe(a, e);
            break;
          case "pgNumType":
            t.pageNumber = Ye(a, e);
            break;
        }
        return t;
      }
      function Ke(i, e) {
        return { numberOfColumns: e.intAttr(i, "num"), space: e.lengthAttr(i, "space"), separator: e.boolAttr(i, "sep"), equalWidth: e.boolAttr(i, "equalWidth", true), columns: e.elements(i, "col").map((t) => ({ width: e.lengthAttr(t, "w"), space: e.lengthAttr(t, "space") })) };
      }
      function Ye(i, e) {
        return { chapSep: e.attr(i, "chapSep"), chapStyle: e.attr(i, "chapStyle"), format: e.attr(i, "fmt"), start: e.intAttr(i, "start") };
      }
      function fe(i, e) {
        return { id: e.attr(i, "id"), type: e.attr(i, "type") };
      }
      function Je(i, e) {
        return { before: e.lengthAttr(i, "before"), after: e.lengthAttr(i, "after"), line: e.intAttr(i, "line"), lineRule: e.attr(i, "lineRule") };
      }
      function ne(i, e) {
        let t = {};
        for (let r of e.elements(i)) Qe(r, t, e);
        return t;
      }
      function Qe(i, e, t) {
        return !!ce(i, e, t);
      }
      function pe(i, e) {
        let t = {};
        for (let r of e.elements(i)) me(r, t, e);
        return t;
      }
      function me(i, e, t) {
        if (i.namespaceURI != oe.wordml) return false;
        if (ce(i, e, t)) return true;
        switch (i.localName) {
          case "tabs":
            e.tabs = tr(i, t);
            break;
          case "sectPr":
            e.sectionProps = de(i, t);
            break;
          case "numPr":
            e.numbering = er(i, t);
            break;
          case "spacing":
            return e.lineSpacing = Je(i, t), false;
          case "textAlignment":
            return e.textAlignment = t.attr(i, "val"), false;
          case "keepLines":
            e.keepLines = t.boolAttr(i, "val", true);
            break;
          case "keepNext":
            e.keepNext = t.boolAttr(i, "val", true);
            break;
          case "pageBreakBefore":
            e.pageBreakBefore = t.boolAttr(i, "val", true);
            break;
          case "outlineLvl":
            e.outlineLevel = t.intAttr(i, "val");
            break;
          case "pStyle":
            e.styleName = t.attr(i, "val");
            break;
          case "rPr":
            e.runProps = ne(i, t);
            break;
          default:
            return false;
        }
        return true;
      }
      function tr(i, e) {
        return e.elements(i, "tab").map((t) => ({ position: e.lengthAttr(t, "pos"), leader: e.attr(t, "leader"), style: e.attr(t, "val") }));
      }
      function er(i, e) {
        var t = {};
        for (let r of e.elements(i)) switch (r.localName) {
          case "numId":
            t.id = e.attr(r, "val");
            break;
          case "ilvl":
            t.level = e.intAttr(r, "val");
            break;
        }
        return t;
      }
      function rr(i, e) {
        let t = { numberings: [], abstractNumberings: [], bulletPictures: [] };
        for (let r of e.elements(i)) switch (r.localName) {
          case "num":
            t.numberings.push(nr(r, e));
            break;
          case "abstractNum":
            t.abstractNumberings.push(ar(r, e));
            break;
          case "numPicBullet":
            t.bulletPictures.push(ir(r, e));
            break;
        }
        return t;
      }
      function nr(i, e) {
        let t = { id: e.attr(i, "numId"), overrides: [] };
        for (let r of e.elements(i)) switch (r.localName) {
          case "abstractNumId":
            t.abstractId = e.attr(r, "val");
            break;
          case "lvlOverride":
            t.overrides.push(sr(r, e));
            break;
        }
        return t;
      }
      function ar(i, e) {
        let t = { id: e.attr(i, "abstractNumId"), levels: [] };
        for (let r of e.elements(i)) switch (r.localName) {
          case "name":
            t.name = e.attr(r, "val");
            break;
          case "multiLevelType":
            t.multiLevelType = e.attr(r, "val");
            break;
          case "numStyleLink":
            t.numberingStyleLink = e.attr(r, "val");
            break;
          case "styleLink":
            t.styleLink = e.attr(r, "val");
            break;
          case "lvl":
            t.levels.push(ge(r, e));
            break;
        }
        return t;
      }
      function ge(i, e) {
        let t = { level: e.intAttr(i, "ilvl") };
        for (let r of e.elements(i)) switch (r.localName) {
          case "start":
            t.start = e.attr(r, "val");
            break;
          case "lvlRestart":
            t.restart = e.intAttr(r, "val");
            break;
          case "numFmt":
            t.format = e.attr(r, "val");
            break;
          case "lvlText":
            t.text = e.attr(r, "val");
            break;
          case "lvlJc":
            t.justification = e.attr(r, "val");
            break;
          case "lvlPicBulletId":
            t.bulletPictureId = e.attr(r, "val");
            break;
          case "pStyle":
            t.paragraphStyle = e.attr(r, "val");
            break;
          case "pPr":
            t.paragraphProps = pe(r, e);
            break;
          case "rPr":
            t.runProps = ne(r, e);
            break;
        }
        return t;
      }
      function sr(i, e) {
        let t = { level: e.intAttr(i, "ilvl") };
        for (let r of e.elements(i)) switch (r.localName) {
          case "startOverride":
            t.start = e.intAttr(r, "val");
            break;
          case "lvl":
            t.numberingLevel = ge(r, e);
            break;
        }
        return t;
      }
      function ir(i, e) {
        var t = e.element(i, "pict"), r = t && e.element(t, "shape"), n = r && e.element(r, "imagedata");
        return n ? { id: e.attr(i, "numPicBulletId"), referenceId: e.attr(n, "id"), style: e.attr(r, "style") } : null;
      }
      class or extends St {
        constructor(e, t, r) {
          super(e, t), this._documentParser = r;
        }
        parseXml(e) {
          Object.assign(this, rr(e, this._package.xmlParser)), this.domNumberings = this._documentParser.parseNumberingFile(e);
        }
      }
      class lr extends St {
        constructor(e, t, r) {
          super(e, t), this._documentParser = r;
        }
        parseXml(e) {
          this.styles = this._documentParser.parseStylesFile(e);
        }
      }
      var z;
      (function(i) {
        i.Document = "document", i.Paragraph = "paragraph", i.Run = "run", i.Break = "break", i.NoBreakHyphen = "noBreakHyphen", i.Table = "table", i.Row = "row", i.Cell = "cell", i.Hyperlink = "hyperlink", i.SmartTag = "smartTag", i.Drawing = "drawing", i.Image = "image", i.Text = "text", i.Tab = "tab", i.Symbol = "symbol", i.BookmarkStart = "bookmarkStart", i.BookmarkEnd = "bookmarkEnd", i.Footer = "footer", i.Header = "header", i.FootnoteReference = "footnoteReference", i.EndnoteReference = "endnoteReference", i.Footnote = "footnote", i.Endnote = "endnote", i.SimpleField = "simpleField", i.ComplexField = "complexField", i.Instruction = "instruction", i.VmlPicture = "vmlPicture", i.MmlMath = "mmlMath", i.MmlMathParagraph = "mmlMathParagraph", i.MmlFraction = "mmlFraction", i.MmlFunction = "mmlFunction", i.MmlFunctionName = "mmlFunctionName", i.MmlNumerator = "mmlNumerator", i.MmlDenominator = "mmlDenominator", i.MmlRadical = "mmlRadical", i.MmlBase = "mmlBase", i.MmlDegree = "mmlDegree", i.MmlSuperscript = "mmlSuperscript", i.MmlSubscript = "mmlSubscript", i.MmlPreSubSuper = "mmlPreSubSuper", i.MmlSubArgument = "mmlSubArgument", i.MmlSuperArgument = "mmlSuperArgument", i.MmlNary = "mmlNary", i.MmlDelimiter = "mmlDelimiter", i.MmlRun = "mmlRun", i.MmlEquationArray = "mmlEquationArray", i.MmlLimit = "mmlLimit", i.MmlLimitLower = "mmlLimitLower", i.MmlMatrix = "mmlMatrix", i.MmlMatrixRow = "mmlMatrixRow", i.MmlBox = "mmlBox", i.MmlBar = "mmlBar", i.MmlGroupChar = "mmlGroupChar", i.VmlElement = "vmlElement", i.Inserted = "inserted", i.Deleted = "deleted", i.DeletedText = "deletedText", i.Comment = "comment", i.CommentReference = "commentReference", i.CommentRangeStart = "commentRangeStart", i.CommentRangeEnd = "commentRangeEnd";
      })(z || (z = {}));
      class zt {
        constructor() {
          this.children = [], this.cssStyle = {};
        }
      }
      class cr extends zt {
        constructor() {
          super(...arguments), this.type = z.Header;
        }
      }
      class hr extends zt {
        constructor() {
          super(...arguments), this.type = z.Footer;
        }
      }
      class be extends St {
        constructor(e, t, r) {
          super(e, t), this._documentParser = r;
        }
        parseXml(e) {
          this.rootElement = this.createRootElement(), this.rootElement.children = this._documentParser.parseBodyElements(e);
        }
      }
      class ur extends be {
        createRootElement() {
          return new cr();
        }
      }
      class dr extends be {
        createRootElement() {
          return new hr();
        }
      }
      function fr(i, e) {
        const t = {};
        for (let r of e.elements(i)) switch (r.localName) {
          case "Template":
            t.template = r.textContent;
            break;
          case "Pages":
            t.pages = Dt(r.textContent);
            break;
          case "Words":
            t.words = Dt(r.textContent);
            break;
          case "Characters":
            t.characters = Dt(r.textContent);
            break;
          case "Application":
            t.application = r.textContent;
            break;
          case "Lines":
            t.lines = Dt(r.textContent);
            break;
          case "Paragraphs":
            t.paragraphs = Dt(r.textContent);
            break;
          case "Company":
            t.company = r.textContent;
            break;
          case "AppVersion":
            t.appVersion = r.textContent;
            break;
        }
        return t;
      }
      function Dt(i) {
        if (typeof i != "undefined") return parseInt(i);
      }
      class pr extends St {
        parseXml(e) {
          this.props = fr(e, this._package.xmlParser);
        }
      }
      function mr(i, e) {
        const t = {};
        for (let r of e.elements(i)) switch (r.localName) {
          case "title":
            t.title = r.textContent;
            break;
          case "description":
            t.description = r.textContent;
            break;
          case "subject":
            t.subject = r.textContent;
            break;
          case "creator":
            t.creator = r.textContent;
            break;
          case "keywords":
            t.keywords = r.textContent;
            break;
          case "language":
            t.language = r.textContent;
            break;
          case "lastModifiedBy":
            t.lastModifiedBy = r.textContent;
            break;
          case "revision":
            r.textContent && (t.revision = parseInt(r.textContent));
            break;
        }
        return t;
      }
      class gr extends St {
        parseXml(e) {
          this.props = mr(e, this._package.xmlParser);
        }
      }
      class br {
      }
      function vr(i, e) {
        var t = new br(), r = e.element(i, "themeElements");
        for (let n of e.elements(r)) switch (n.localName) {
          case "clrScheme":
            t.colorScheme = kr(n, e);
            break;
          case "fontScheme":
            t.fontScheme = yr(n, e);
            break;
        }
        return t;
      }
      function kr(i, e) {
        var t = { name: e.attr(i, "name"), colors: {} };
        for (let a of e.elements(i)) {
          var r = e.element(a, "srgbClr"), n = e.element(a, "sysClr");
          r ? t.colors[a.localName] = e.attr(r, "val") : n && (t.colors[a.localName] = e.attr(n, "lastClr"));
        }
        return t;
      }
      function yr(i, e) {
        var t = { name: e.attr(i, "name") };
        for (let r of e.elements(i)) switch (r.localName) {
          case "majorFont":
            t.majorFont = ve(r, e);
            break;
          case "minorFont":
            t.minorFont = ve(r, e);
            break;
        }
        return t;
      }
      function ve(i, e) {
        return { latinTypeface: e.elementAttr(i, "latin", "typeface"), eaTypeface: e.elementAttr(i, "ea", "typeface"), csTypeface: e.elementAttr(i, "cs", "typeface") };
      }
      class _r extends St {
        constructor(e, t) {
          super(e, t);
        }
        parseXml(e) {
          this.theme = vr(e, this._package.xmlParser);
        }
      }
      class ke {
      }
      class wr extends ke {
        constructor() {
          super(...arguments), this.type = z.Footnote;
        }
      }
      class Sr extends ke {
        constructor() {
          super(...arguments), this.type = z.Endnote;
        }
      }
      class ye extends St {
        constructor(e, t, r) {
          super(e, t), this._documentParser = r;
        }
      }
      class Cr extends ye {
        constructor(e, t, r) {
          super(e, t, r);
        }
        parseXml(e) {
          this.notes = this._documentParser.parseNotes(e, "footnote", wr);
        }
      }
      class xr extends ye {
        constructor(e, t, r) {
          super(e, t, r);
        }
        parseXml(e) {
          this.notes = this._documentParser.parseNotes(e, "endnote", Sr);
        }
      }
      function Pr(i, e) {
        var t = {};
        for (let r of e.elements(i)) switch (r.localName) {
          case "defaultTabStop":
            t.defaultTabStop = e.lengthAttr(r, "val");
            break;
          case "footnotePr":
            t.footnoteProps = _e(r, e);
            break;
          case "endnotePr":
            t.endnoteProps = _e(r, e);
            break;
          case "autoHyphenation":
            t.autoHyphenation = e.boolAttr(r, "val");
            break;
        }
        return t;
      }
      function _e(i, e) {
        var t = { defaultNoteIds: [] };
        for (let r of e.elements(i)) switch (r.localName) {
          case "numFmt":
            t.nummeringFormat = e.attr(r, "val");
            break;
          case "footnote":
          case "endnote":
            t.defaultNoteIds.push(e.attr(r, "id"));
            break;
        }
        return t;
      }
      class Er extends St {
        constructor(e, t) {
          super(e, t);
        }
        parseXml(e) {
          this.settings = Pr(e, this._package.xmlParser);
        }
      }
      function Ar(i, e) {
        return e.elements(i, "property").map((t) => {
          const r = t.firstChild;
          return { formatId: e.attr(t, "fmtid"), name: e.attr(t, "name"), type: r.nodeName, value: r.textContent };
        });
      }
      class Nr extends St {
        parseXml(e) {
          this.props = Ar(e, this._package.xmlParser);
        }
      }
      class Br extends St {
        constructor(e, t, r) {
          super(e, t), this._documentParser = r;
        }
        parseXml(e) {
          this.comments = this._documentParser.parseComments(e), this.commentMap = Nt(this.comments, (t) => t.id);
        }
      }
      class zr extends St {
        constructor(e, t) {
          super(e, t), this.comments = [];
        }
        parseXml(e) {
          const t = this._package.xmlParser;
          for (let r of t.elements(e, "commentEx")) this.comments.push({ paraId: t.attr(r, "paraId"), paraIdParent: t.attr(r, "paraIdParent"), done: t.boolAttr(r, "done") });
          this.commentMap = Nt(this.comments, (r) => r.paraId);
        }
      }
      const Rr = [{ type: ot.OfficeDocument, target: "word/document.xml" }, { type: ot.ExtendedProperties, target: "docProps/app.xml" }, { type: ot.CoreProperties, target: "docProps/core.xml" }, { type: ot.CustomProperties, target: "docProps/custom.xml" }];
      class ae {
        constructor() {
          this.parts = [], this.partsMap = {};
        }
        static load(e, t, r) {
          return wt(this, null, function* () {
            var n = new ae();
            return n._options = r, n._parser = t, n._package = yield re.load(e, r), n.rels = yield n._package.loadRelationships(), yield Promise.all(Rr.map((a) => {
              var o;
              const l = (o = n.rels.find((u) => u.type === a.type)) != null ? o : a;
              return n.loadRelationshipPart(l.target, l.type);
            })), n;
          });
        }
        save(e = "blob") {
          return this._package.save(e);
        }
        loadRelationshipPart(e, t) {
          return wt(this, null, function* () {
            var n;
            if (this.partsMap[e]) return this.partsMap[e];
            if (!this._package.get(e)) return null;
            let r = null;
            switch (t) {
              case ot.OfficeDocument:
                this.documentPart = r = new Ge(this._package, e, this._parser);
                break;
              case ot.FontTable:
                this.fontTablePart = r = new We(this._package, e);
                break;
              case ot.Numbering:
                this.numberingPart = r = new or(this._package, e, this._parser);
                break;
              case ot.Styles:
                this.stylesPart = r = new lr(this._package, e, this._parser);
                break;
              case ot.Theme:
                this.themePart = r = new _r(this._package, e);
                break;
              case ot.Footnotes:
                this.footnotesPart = r = new Cr(this._package, e, this._parser);
                break;
              case ot.Endnotes:
                this.endnotesPart = r = new xr(this._package, e, this._parser);
                break;
              case ot.Footer:
                r = new dr(this._package, e, this._parser);
                break;
              case ot.Header:
                r = new ur(this._package, e, this._parser);
                break;
              case ot.CoreProperties:
                this.corePropsPart = r = new gr(this._package, e);
                break;
              case ot.ExtendedProperties:
                this.extendedPropsPart = r = new pr(this._package, e);
                break;
              case ot.CustomProperties:
                r = new Nr(this._package, e);
                break;
              case ot.Settings:
                this.settingsPart = r = new Er(this._package, e);
                break;
              case ot.Comments:
                this.commentsPart = r = new Br(this._package, e, this._parser);
                break;
              case ot.CommentsExtended:
                this.commentsExtendedPart = r = new zr(this._package, e);
                break;
            }
            if (r == null) return Promise.resolve(null);
            if (this.partsMap[e] = r, this.parts.push(r), yield r.load(), ((n = r.rels) == null ? void 0 : n.length) > 0) {
              const [a] = Zt(r.path);
              yield Promise.all(r.rels.map((l) => this.loadRelationshipPart(te(l.target, a), l.type)));
            }
            return r;
          });
        }
        loadDocumentImage(e, t) {
          return wt(this, null, function* () {
            const r = yield this.loadResource(t != null ? t : this.documentPart, e, "blob");
            return this.blobToURL(r);
          });
        }
        loadNumberingImage(e) {
          return wt(this, null, function* () {
            const t = yield this.loadResource(this.numberingPart, e, "blob");
            return this.blobToURL(t);
          });
        }
        loadFont(e, t) {
          return wt(this, null, function* () {
            const r = yield this.loadResource(this.fontTablePart, e, "uint8array");
            return r && this.blobToURL(new Blob([Mr(r, t)]));
          });
        }
        blobToURL(e) {
          return e ? this._options.useBase64URL ? Ze(e) : URL.createObjectURL(e) : null;
        }
        findPartByRelId(e, t = null) {
          var a;
          var r = ((a = t.rels) != null ? a : this.rels).find((l) => l.id == e);
          const n = t ? Zt(t.path)[0] : "";
          return r ? this.partsMap[te(r.target, n)] : null;
        }
        getPathById(e, t) {
          const r = e.rels.find((a) => a.id == t), [n] = Zt(e.path);
          return r ? te(r.target, n) : null;
        }
        loadResource(e, t, r) {
          const n = this.getPathById(e, t);
          return n ? this._package.load(n, r) : Promise.resolve(null);
        }
      }
      function Mr(i, e) {
        const r = e.replace(/{|}|-/g, ""), n = new Array(16);
        for (let a = 0; a < 16; a++) n[16 - a - 1] = parseInt(r.substr(a * 2, 2), 16);
        for (let a = 0; a < 32; a++) i[a] = i[a] ^ n[a % 16];
        return i;
      }
      function Tr(i, e) {
        return { type: z.BookmarkStart, id: e.attr(i, "id"), name: e.attr(i, "name"), colFirst: e.intAttr(i, "colFirst"), colLast: e.intAttr(i, "colLast") };
      }
      function Ir(i, e) {
        return { type: z.BookmarkEnd, id: e.attr(i, "id") };
      }
      class Or extends zt {
        constructor() {
          super(...arguments), this.type = z.VmlElement, this.attrs = {};
        }
      }
      function we(i, e) {
        var t = new Or();
        switch (i.localName) {
          case "rect":
            t.tagName = "rect", Object.assign(t.attrs, { width: "100%", height: "100%" });
            break;
          case "oval":
            t.tagName = "ellipse", Object.assign(t.attrs, { cx: "50%", cy: "50%", rx: "50%", ry: "50%" });
            break;
          case "line":
            t.tagName = "line";
            break;
          case "shape":
            t.tagName = "g";
            break;
          case "textbox":
            t.tagName = "foreignObject", Object.assign(t.attrs, { width: "100%", height: "100%" });
            break;
          default:
            return null;
        }
        for (const r of P.attrs(i)) switch (r.localName) {
          case "style":
            t.cssStyleText = r.value;
            break;
          case "fillcolor":
            t.attrs.fill = r.value;
            break;
          case "from":
            const [n, a] = Se(r.value);
            Object.assign(t.attrs, { x1: n, y1: a });
            break;
          case "to":
            const [l, o] = Se(r.value);
            Object.assign(t.attrs, { x2: l, y2: o });
            break;
        }
        for (const r of P.elements(i)) switch (r.localName) {
          case "stroke":
            Object.assign(t.attrs, Fr(r));
            break;
          case "fill":
            Object.assign(t.attrs, Dr());
            break;
          case "imagedata":
            t.tagName = "image", Object.assign(t.attrs, { width: "100%", height: "100%" }), t.imageHref = { id: P.attr(r, "id"), title: P.attr(r, "title") };
            break;
          case "txbxContent":
            t.children.push(...e.parseBodyElements(r));
            break;
          default:
            const n = we(r, e);
            n && t.children.push(n);
            break;
        }
        return t;
      }
      function Fr(i) {
        var e;
        return { stroke: P.attr(i, "color"), "stroke-width": (e = P.lengthAttr(i, "weight", pt.Emu)) != null ? e : "1px" };
      }
      function Dr(i) {
        return {};
      }
      function Se(i) {
        return i.split(",");
      }
      class Lr extends zt {
        constructor() {
          super(...arguments), this.type = z.Comment;
        }
      }
      class jr extends zt {
        constructor(e) {
          super(), this.id = e, this.type = z.CommentReference;
        }
      }
      class Ur extends zt {
        constructor(e) {
          super(), this.id = e, this.type = z.CommentRangeStart;
        }
      }
      class $r extends zt {
        constructor(e) {
          super(), this.id = e, this.type = z.CommentRangeEnd;
        }
      }
      var Gt = { shd: "inherit", color: "black", borderColor: "black", highlight: "transparent" };
      const Wr = [], Ce = { oMath: z.MmlMath, oMathPara: z.MmlMathParagraph, f: z.MmlFraction, func: z.MmlFunction, fName: z.MmlFunctionName, num: z.MmlNumerator, den: z.MmlDenominator, rad: z.MmlRadical, deg: z.MmlDegree, e: z.MmlBase, sSup: z.MmlSuperscript, sSub: z.MmlSubscript, sPre: z.MmlPreSubSuper, sup: z.MmlSuperArgument, sub: z.MmlSubArgument, d: z.MmlDelimiter, nary: z.MmlNary, eqArr: z.MmlEquationArray, lim: z.MmlLimit, limLow: z.MmlLimitLower, m: z.MmlMatrix, mr: z.MmlMatrixRow, box: z.MmlBox, bar: z.MmlBar, groupChr: z.MmlGroupChar };
      class Hr {
        constructor(e) {
          this.options = _t({ ignoreWidth: false, debug: false }, e);
        }
        parseNotes(e, t, r) {
          var n = [];
          for (let a of P.elements(e, t)) {
            const l = new r();
            l.id = P.attr(a, "id"), l.noteType = P.attr(a, "type"), l.children = this.parseBodyElements(a), n.push(l);
          }
          return n;
        }
        parseComments(e) {
          var t = [];
          for (let r of P.elements(e, "comment")) {
            const n = new Lr();
            n.id = P.attr(r, "id"), n.author = P.attr(r, "author"), n.initials = P.attr(r, "initials"), n.date = P.attr(r, "date"), n.children = this.parseBodyElements(r), t.push(n);
          }
          return t;
        }
        parseDocumentFile(e) {
          var t = P.element(e, "body"), r = P.element(e, "background"), n = P.element(t, "sectPr");
          return { type: z.Document, children: this.parseBodyElements(t), props: n ? de(n, P) : {}, cssStyle: r ? this.parseBackground(r) : {} };
        }
        parseBackground(e) {
          var t = {}, r = ut.colorAttr(e, "color");
          return r && (t["background-color"] = r), t;
        }
        parseBodyElements(e) {
          var t = [];
          for (let r of P.elements(e)) switch (r.localName) {
            case "p":
              t.push(this.parseParagraph(r));
              break;
            case "tbl":
              t.push(this.parseTable(r));
              break;
            case "sdt":
              t.push(...this.parseSdt(r, (n) => this.parseBodyElements(n)));
              break;
          }
          return t;
        }
        parseStylesFile(e) {
          var t = [];
          return ut.foreach(e, (r) => {
            switch (r.localName) {
              case "style":
                t.push(this.parseStyle(r));
                break;
              case "docDefaults":
                t.push(this.parseDefaultStyles(r));
                break;
            }
          }), t;
        }
        parseDefaultStyles(e) {
          var t = { id: null, name: null, target: null, basedOn: null, styles: [] };
          return ut.foreach(e, (r) => {
            switch (r.localName) {
              case "rPrDefault":
                var n = P.element(r, "rPr");
                n && t.styles.push({ target: "span", values: this.parseDefaultProperties(n, {}) });
                break;
              case "pPrDefault":
                var a = P.element(r, "pPr");
                a && t.styles.push({ target: "p", values: this.parseDefaultProperties(a, {}) });
                break;
            }
          }), t;
        }
        parseStyle(e) {
          var t = { id: P.attr(e, "styleId"), isDefault: P.boolAttr(e, "default"), name: null, target: null, basedOn: null, styles: [], linked: null };
          switch (P.attr(e, "type")) {
            case "paragraph":
              t.target = "p";
              break;
            case "table":
              t.target = "table";
              break;
            case "character":
              t.target = "span";
              break;
          }
          return ut.foreach(e, (r) => {
            switch (r.localName) {
              case "basedOn":
                t.basedOn = P.attr(r, "val");
                break;
              case "name":
                t.name = P.attr(r, "val");
                break;
              case "link":
                t.linked = P.attr(r, "val");
                break;
              case "next":
                t.next = P.attr(r, "val");
                break;
              case "aliases":
                t.aliases = P.attr(r, "val").split(",");
                break;
              case "pPr":
                t.styles.push({ target: "p", values: this.parseDefaultProperties(r, {}) }), t.paragraphProps = pe(r, P);
                break;
              case "rPr":
                t.styles.push({ target: "span", values: this.parseDefaultProperties(r, {}) }), t.runProps = ne(r, P);
                break;
              case "tblPr":
              case "tcPr":
                t.styles.push({ target: "td", values: this.parseDefaultProperties(r, {}) });
                break;
              case "tblStylePr":
                for (let n of this.parseTableStyle(r)) t.styles.push(n);
                break;
              case "rsid":
              case "qFormat":
              case "hidden":
              case "semiHidden":
              case "unhideWhenUsed":
              case "autoRedefine":
              case "uiPriority":
                break;
              default:
                this.options.debug && console.warn(`DOCX: Unknown style element: ${r.localName}`);
            }
          }), t;
        }
        parseTableStyle(e) {
          var t = [], r = P.attr(e, "type"), n = "", a = "";
          switch (r) {
            case "firstRow":
              a = ".first-row", n = "tr.first-row td";
              break;
            case "lastRow":
              a = ".last-row", n = "tr.last-row td";
              break;
            case "firstCol":
              a = ".first-col", n = "td.first-col";
              break;
            case "lastCol":
              a = ".last-col", n = "td.last-col";
              break;
            case "band1Vert":
              a = ":not(.no-vband)", n = "td.odd-col";
              break;
            case "band2Vert":
              a = ":not(.no-vband)", n = "td.even-col";
              break;
            case "band1Horz":
              a = ":not(.no-hband)", n = "tr.odd-row";
              break;
            case "band2Horz":
              a = ":not(.no-hband)", n = "tr.even-row";
              break;
            default:
              return [];
          }
          return ut.foreach(e, (l) => {
            switch (l.localName) {
              case "pPr":
                t.push({ target: `${n} p`, mod: a, values: this.parseDefaultProperties(l, {}) });
                break;
              case "rPr":
                t.push({ target: `${n} span`, mod: a, values: this.parseDefaultProperties(l, {}) });
                break;
              case "tblPr":
              case "tcPr":
                t.push({ target: n, mod: a, values: this.parseDefaultProperties(l, {}) });
                break;
            }
          }), t;
        }
        parseNumberingFile(e) {
          var t = [], r = {}, n = [];
          return ut.foreach(e, (a) => {
            switch (a.localName) {
              case "abstractNum":
                this.parseAbstractNumbering(a, n).forEach((u) => t.push(u));
                break;
              case "numPicBullet":
                n.push(this.parseNumberingPicBullet(a));
                break;
              case "num":
                var l = P.attr(a, "numId"), o = P.elementAttr(a, "abstractNumId", "val");
                r[o] = l;
                break;
            }
          }), t.forEach((a) => a.id = r[a.id]), t;
        }
        parseNumberingPicBullet(e) {
          var t = P.element(e, "pict"), r = t && P.element(t, "shape"), n = r && P.element(r, "imagedata");
          return n ? { id: P.intAttr(e, "numPicBulletId"), src: P.attr(n, "id"), style: P.attr(r, "style") } : null;
        }
        parseAbstractNumbering(e, t) {
          var r = [], n = P.attr(e, "abstractNumId");
          return ut.foreach(e, (a) => {
            switch (a.localName) {
              case "lvl":
                r.push(this.parseNumberingLevel(n, a, t));
                break;
            }
          }), r;
        }
        parseNumberingLevel(e, t, r) {
          var n = { id: e, level: P.intAttr(t, "ilvl"), start: 1, pStyleName: void 0, pStyle: {}, rStyle: {}, suff: "tab" };
          return ut.foreach(t, (a) => {
            switch (a.localName) {
              case "start":
                n.start = P.intAttr(a, "val");
                break;
              case "pPr":
                this.parseDefaultProperties(a, n.pStyle);
                break;
              case "rPr":
                this.parseDefaultProperties(a, n.rStyle);
                break;
              case "lvlPicBulletId":
                var l = P.intAttr(a, "val");
                n.bullet = r.find((o) => (o == null ? void 0 : o.id) == l);
                break;
              case "lvlText":
                n.levelText = P.attr(a, "val");
                break;
              case "pStyle":
                n.pStyleName = P.attr(a, "val");
                break;
              case "numFmt":
                n.format = P.attr(a, "val");
                break;
              case "suff":
                n.suff = P.attr(a, "val");
                break;
            }
          }), n;
        }
        parseSdt(e, t) {
          const r = P.element(e, "sdtContent");
          return r ? t(r) : [];
        }
        parseInserted(e, t) {
          var r, n;
          return { type: z.Inserted, children: (n = (r = t(e)) == null ? void 0 : r.children) != null ? n : [] };
        }
        parseDeleted(e, t) {
          var r, n;
          return { type: z.Deleted, children: (n = (r = t(e)) == null ? void 0 : r.children) != null ? n : [] };
        }
        parseParagraph(e) {
          var t = { type: z.Paragraph, children: [] };
          for (let r of P.elements(e)) switch (r.localName) {
            case "pPr":
              this.parseParagraphProperties(r, t);
              break;
            case "r":
              t.children.push(this.parseRun(r, t));
              break;
            case "hyperlink":
              t.children.push(this.parseHyperlink(r, t));
              break;
            case "smartTag":
              t.children.push(this.parseSmartTag(r, t));
              break;
            case "bookmarkStart":
              t.children.push(Tr(r, P));
              break;
            case "bookmarkEnd":
              t.children.push(Ir(r, P));
              break;
            case "commentRangeStart":
              t.children.push(new Ur(P.attr(r, "id")));
              break;
            case "commentRangeEnd":
              t.children.push(new $r(P.attr(r, "id")));
              break;
            case "oMath":
            case "oMathPara":
              t.children.push(this.parseMathElement(r));
              break;
            case "sdt":
              t.children.push(...this.parseSdt(r, (n) => this.parseParagraph(n).children));
              break;
            case "ins":
              t.children.push(this.parseInserted(r, (n) => this.parseParagraph(n)));
              break;
            case "del":
              t.children.push(this.parseDeleted(r, (n) => this.parseParagraph(n)));
              break;
          }
          return t;
        }
        parseParagraphProperties(e, t) {
          this.parseDefaultProperties(e, t.cssStyle = {}, null, (r) => {
            if (me(r, t, P)) return true;
            switch (r.localName) {
              case "pStyle":
                t.styleName = P.attr(r, "val");
                break;
              case "cnfStyle":
                t.className = ct.classNameOfCnfStyle(r);
                break;
              case "framePr":
                this.parseFrame(r, t);
                break;
              case "rPr":
                break;
              default:
                return false;
            }
            return true;
          });
        }
        parseFrame(e, t) {
          var r = P.attr(e, "dropCap");
          r == "drop" && (t.cssStyle.float = "left");
        }
        parseHyperlink(e, t) {
          var r = { type: z.Hyperlink, parent: t, children: [] }, n = P.attr(e, "anchor"), a = P.attr(e, "id");
          return n && (r.href = "#" + n), a && (r.id = a), ut.foreach(e, (l) => {
            switch (l.localName) {
              case "r":
                r.children.push(this.parseRun(l, r));
                break;
            }
          }), r;
        }
        parseSmartTag(e, t) {
          var r = { type: z.SmartTag, parent: t, children: [] }, n = P.attr(e, "uri"), a = P.attr(e, "element");
          return n && (r.uri = n), a && (r.element = a), ut.foreach(e, (l) => {
            switch (l.localName) {
              case "r":
                r.children.push(this.parseRun(l, r));
                break;
            }
          }), r;
        }
        parseRun(e, t) {
          var r = { type: z.Run, parent: t, children: [] };
          return ut.foreach(e, (n) => {
            switch (n = this.checkAlternateContent(n), n.localName) {
              case "t":
                r.children.push({ type: z.Text, text: n.textContent });
                break;
              case "delText":
                r.children.push({ type: z.DeletedText, text: n.textContent });
                break;
              case "commentReference":
                r.children.push(new jr(P.attr(n, "id")));
                break;
              case "fldSimple":
                r.children.push({ type: z.SimpleField, instruction: P.attr(n, "instr"), lock: P.boolAttr(n, "lock", false), dirty: P.boolAttr(n, "dirty", false) });
                break;
              case "instrText":
                r.fieldRun = true, r.children.push({ type: z.Instruction, text: n.textContent });
                break;
              case "fldChar":
                r.fieldRun = true, r.children.push({ type: z.ComplexField, charType: P.attr(n, "fldCharType"), lock: P.boolAttr(n, "lock", false), dirty: P.boolAttr(n, "dirty", false) });
                break;
              case "noBreakHyphen":
                r.children.push({ type: z.NoBreakHyphen });
                break;
              case "br":
                r.children.push({ type: z.Break, break: P.attr(n, "type") || "textWrapping" });
                break;
              case "lastRenderedPageBreak":
                r.children.push({ type: z.Break, break: "lastRenderedPageBreak" });
                break;
              case "sym":
                r.children.push({ type: z.Symbol, font: P.attr(n, "font"), char: P.attr(n, "char") });
                break;
              case "tab":
                r.children.push({ type: z.Tab });
                break;
              case "footnoteReference":
                r.children.push({ type: z.FootnoteReference, id: P.attr(n, "id") });
                break;
              case "endnoteReference":
                r.children.push({ type: z.EndnoteReference, id: P.attr(n, "id") });
                break;
              case "drawing":
                let a = this.parseDrawing(n);
                a && (r.children = [a]);
                break;
              case "pict":
                r.children.push(this.parseVmlPicture(n));
                break;
              case "rPr":
                this.parseRunProperties(n, r);
                break;
            }
          }), r;
        }
        parseMathElement(e) {
          const t = `${e.localName}Pr`, r = { type: Ce[e.localName], children: [] };
          for (const a of P.elements(e)) if (Ce[a.localName]) r.children.push(this.parseMathElement(a));
          else if (a.localName == "r") {
            var n = this.parseRun(a);
            n.type = z.MmlRun, r.children.push(n);
          } else a.localName == t && (r.props = this.parseMathProperies(a));
          return r;
        }
        parseMathProperies(e) {
          const t = {};
          for (const r of P.elements(e)) switch (r.localName) {
            case "chr":
              t.char = P.attr(r, "val");
              break;
            case "vertJc":
              t.verticalJustification = P.attr(r, "val");
              break;
            case "pos":
              t.position = P.attr(r, "val");
              break;
            case "degHide":
              t.hideDegree = P.boolAttr(r, "val");
              break;
            case "begChr":
              t.beginChar = P.attr(r, "val");
              break;
            case "endChr":
              t.endChar = P.attr(r, "val");
              break;
          }
          return t;
        }
        parseRunProperties(e, t) {
          this.parseDefaultProperties(e, t.cssStyle = {}, null, (r) => {
            switch (r.localName) {
              case "rStyle":
                t.styleName = P.attr(r, "val");
                break;
              case "vertAlign":
                t.verticalAlign = ct.valueOfVertAlign(r, true);
                break;
              default:
                return false;
            }
            return true;
          });
        }
        parseVmlPicture(e) {
          const t = { type: z.VmlPicture, children: [] };
          for (const r of P.elements(e)) {
            const n = we(r, this);
            n && t.children.push(n);
          }
          return t;
        }
        checkAlternateContent(e) {
          var a;
          if (e.localName != "AlternateContent") return e;
          var t = P.element(e, "Choice");
          if (t) {
            var r = P.attr(t, "Requires"), n = e.lookupNamespaceURI(r);
            if (Wr.includes(n)) return t.firstElementChild;
          }
          return (a = P.element(e, "Fallback")) == null ? void 0 : a.firstElementChild;
        }
        parseDrawing(e) {
          for (var t of P.elements(e)) switch (t.localName) {
            case "inline":
            case "anchor":
              return this.parseDrawingWrapper(t);
          }
        }
        parseDrawingWrapper(e) {
          var w;
          var t = { type: z.Drawing, children: [], cssStyle: {} }, r = e.localName == "anchor";
          let n = null, a = P.boolAttr(e, "simplePos");
          P.boolAttr(e, "behindDoc");
          let l = { relative: "page", align: "left", offset: "0" }, o = { relative: "page", align: "top", offset: "0" };
          for (var u of P.elements(e)) switch (u.localName) {
            case "simplePos":
              a && (l.offset = P.lengthAttr(u, "x", pt.Emu), o.offset = P.lengthAttr(u, "y", pt.Emu));
              break;
            case "extent":
              t.cssStyle.width = P.lengthAttr(u, "cx", pt.Emu), t.cssStyle.height = P.lengthAttr(u, "cy", pt.Emu);
              break;
            case "positionH":
            case "positionV":
              if (!a) {
                let d = u.localName == "positionH" ? l : o;
                var b = P.element(u, "align"), y = P.element(u, "posOffset");
                d.relative = (w = P.attr(u, "relativeFrom")) != null ? w : d.relative, b && (d.align = b.textContent), y && (d.offset = ut.sizeValue(y, pt.Emu));
              }
              break;
            case "wrapTopAndBottom":
              n = "wrapTopAndBottom";
              break;
            case "wrapNone":
              n = "wrapNone";
              break;
            case "graphic":
              var _ = this.parseGraphic(u);
              _ && t.children.push(_);
              break;
          }
          return n == "wrapTopAndBottom" ? (t.cssStyle.display = "block", l.align && (t.cssStyle["text-align"] = l.align, t.cssStyle.width = "100%")) : n == "wrapNone" ? (t.cssStyle.display = "block", t.cssStyle.position = "relative", t.cssStyle.width = "0px", t.cssStyle.height = "0px", l.offset && (t.cssStyle.left = l.offset), o.offset && (t.cssStyle.top = o.offset)) : r && (l.align == "left" || l.align == "right") && (t.cssStyle.float = l.align), t;
        }
        parseGraphic(e) {
          var t = P.element(e, "graphicData");
          for (let r of P.elements(t)) switch (r.localName) {
            case "pic":
              return this.parsePicture(r);
          }
          return null;
        }
        parsePicture(e) {
          var t = { type: z.Image, src: "", cssStyle: {} }, r = P.element(e, "blipFill"), n = P.element(r, "blip");
          t.src = P.attr(n, "embed");
          var a = P.element(e, "spPr"), l = P.element(a, "xfrm");
          t.cssStyle.position = "relative";
          for (var o of P.elements(l)) switch (o.localName) {
            case "ext":
              t.cssStyle.width = P.lengthAttr(o, "cx", pt.Emu), t.cssStyle.height = P.lengthAttr(o, "cy", pt.Emu);
              break;
            case "off":
              t.cssStyle.left = P.lengthAttr(o, "x", pt.Emu), t.cssStyle.top = P.lengthAttr(o, "y", pt.Emu);
              break;
          }
          return t;
        }
        parseTable(e) {
          var t = { type: z.Table, children: [] };
          return ut.foreach(e, (r) => {
            switch (r.localName) {
              case "tr":
                t.children.push(this.parseTableRow(r));
                break;
              case "tblGrid":
                t.columns = this.parseTableColumns(r);
                break;
              case "tblPr":
                this.parseTableProperties(r, t);
                break;
            }
          }), t;
        }
        parseTableColumns(e) {
          var t = [];
          return ut.foreach(e, (r) => {
            switch (r.localName) {
              case "gridCol":
                t.push({ width: P.lengthAttr(r, "w") });
                break;
            }
          }), t;
        }
        parseTableProperties(e, t) {
          switch (t.cssStyle = {}, t.cellStyle = {}, this.parseDefaultProperties(e, t.cssStyle, t.cellStyle, (r) => {
            switch (r.localName) {
              case "tblStyle":
                t.styleName = P.attr(r, "val");
                break;
              case "tblLook":
                t.className = ct.classNameOftblLook(r);
                break;
              case "tblpPr":
                this.parseTablePosition(r, t);
                break;
              case "tblStyleColBandSize":
                t.colBandSize = P.intAttr(r, "val");
                break;
              case "tblStyleRowBandSize":
                t.rowBandSize = P.intAttr(r, "val");
                break;
              default:
                return false;
            }
            return true;
          }), t.cssStyle["text-align"]) {
            case "center":
              delete t.cssStyle["text-align"], t.cssStyle["margin-left"] = "auto", t.cssStyle["margin-right"] = "auto";
              break;
            case "right":
              delete t.cssStyle["text-align"], t.cssStyle["margin-left"] = "auto";
              break;
          }
        }
        parseTablePosition(e, t) {
          var r = P.lengthAttr(e, "topFromText"), n = P.lengthAttr(e, "bottomFromText"), a = P.lengthAttr(e, "rightFromText"), l = P.lengthAttr(e, "leftFromText");
          t.cssStyle.float = "left", t.cssStyle["margin-bottom"] = ct.addSize(t.cssStyle["margin-bottom"], n), t.cssStyle["margin-left"] = ct.addSize(t.cssStyle["margin-left"], l), t.cssStyle["margin-right"] = ct.addSize(t.cssStyle["margin-right"], a), t.cssStyle["margin-top"] = ct.addSize(t.cssStyle["margin-top"], r);
        }
        parseTableRow(e) {
          var t = { type: z.Row, children: [] };
          return ut.foreach(e, (r) => {
            switch (r.localName) {
              case "tc":
                t.children.push(this.parseTableCell(r));
                break;
              case "trPr":
                this.parseTableRowProperties(r, t);
                break;
            }
          }), t;
        }
        parseTableRowProperties(e, t) {
          t.cssStyle = this.parseDefaultProperties(e, {}, null, (r) => {
            switch (r.localName) {
              case "cnfStyle":
                t.className = ct.classNameOfCnfStyle(r);
                break;
              case "tblHeader":
                t.isHeader = P.boolAttr(r, "val");
                break;
              default:
                return false;
            }
            return true;
          });
        }
        parseTableCell(e) {
          var t = { type: z.Cell, children: [] };
          return ut.foreach(e, (r) => {
            switch (r.localName) {
              case "tbl":
                t.children.push(this.parseTable(r));
                break;
              case "p":
                t.children.push(this.parseParagraph(r));
                break;
              case "tcPr":
                this.parseTableCellProperties(r, t);
                break;
            }
          }), t;
        }
        parseTableCellProperties(e, t) {
          t.cssStyle = this.parseDefaultProperties(e, {}, null, (r) => {
            var n;
            switch (r.localName) {
              case "gridSpan":
                t.span = P.intAttr(r, "val", null);
                break;
              case "vMerge":
                t.verticalMerge = (n = P.attr(r, "val")) != null ? n : "continue";
                break;
              case "cnfStyle":
                t.className = ct.classNameOfCnfStyle(r);
                break;
              default:
                return false;
            }
            return true;
          });
        }
        parseDefaultProperties(e, t = null, r = null, n = null) {
          return t = t || {}, ut.foreach(e, (a) => {
            if (!(n != null && n(a))) switch (a.localName) {
              case "jc":
                t["text-align"] = ct.valueOfJc(a);
                break;
              case "textAlignment":
                t["vertical-align"] = ct.valueOfTextAlignment(a);
                break;
              case "color":
                t.color = ut.colorAttr(a, "val", null, Gt.color);
                break;
              case "sz":
                t["font-size"] = t["min-height"] = P.lengthAttr(a, "val", pt.FontSize);
                break;
              case "shd":
                t["background-color"] = ut.colorAttr(a, "fill", null, Gt.shd);
                break;
              case "highlight":
                t["background-color"] = ut.colorAttr(a, "val", null, Gt.highlight);
                break;
              case "vertAlign":
                break;
              case "position":
                t.verticalAlign = P.lengthAttr(a, "val", pt.FontSize);
                break;
              case "tcW":
                if (this.options.ignoreWidth) break;
              case "tblW":
                t.width = ct.valueOfSize(a, "w");
                break;
              case "trHeight":
                this.parseTrHeight(a, t);
                break;
              case "strike":
                t["text-decoration"] = P.boolAttr(a, "val", true) ? "line-through" : "none";
                break;
              case "b":
                t["font-weight"] = P.boolAttr(a, "val", true) ? "bold" : "normal";
                break;
              case "i":
                t["font-style"] = P.boolAttr(a, "val", true) ? "italic" : "normal";
                break;
              case "caps":
                t["text-transform"] = P.boolAttr(a, "val", true) ? "uppercase" : "none";
                break;
              case "smallCaps":
                t["font-variant"] = P.boolAttr(a, "val", true) ? "small-caps" : "none";
                break;
              case "u":
                this.parseUnderline(a, t);
                break;
              case "ind":
              case "tblInd":
                this.parseIndentation(a, t);
                break;
              case "rFonts":
                this.parseFont(a, t);
                break;
              case "tblBorders":
                this.parseBorderProperties(a, r || t);
                break;
              case "tblCellSpacing":
                t["border-spacing"] = ct.valueOfMargin(a), t["border-collapse"] = "separate";
                break;
              case "pBdr":
                this.parseBorderProperties(a, t);
                break;
              case "bdr":
                t.border = ct.valueOfBorder(a);
                break;
              case "tcBorders":
                this.parseBorderProperties(a, t);
                break;
              case "vanish":
                P.boolAttr(a, "val", true) && (t.display = "none");
                break;
              case "kern":
                break;
              case "noWrap":
                break;
              case "tblCellMar":
              case "tcMar":
                this.parseMarginProperties(a, r || t);
                break;
              case "tblLayout":
                t["table-layout"] = ct.valueOfTblLayout(a);
                break;
              case "vAlign":
                t["vertical-align"] = ct.valueOfTextAlignment(a);
                break;
              case "spacing":
                e.localName == "pPr" && this.parseSpacing(a, t);
                break;
              case "wordWrap":
                P.boolAttr(a, "val") && (t["overflow-wrap"] = "break-word");
                break;
              case "suppressAutoHyphens":
                t.hyphens = P.boolAttr(a, "val", true) ? "none" : "auto";
                break;
              case "lang":
                t.$lang = P.attr(a, "val");
                break;
              case "bCs":
              case "iCs":
              case "szCs":
              case "tabs":
              case "outlineLvl":
              case "contextualSpacing":
              case "tblStyleColBandSize":
              case "tblStyleRowBandSize":
              case "webHidden":
              case "pageBreakBefore":
              case "suppressLineNumbers":
              case "keepLines":
              case "keepNext":
              case "widowControl":
              case "bidi":
              case "rtl":
              case "noProof":
                break;
              default:
                this.options.debug && console.warn(`DOCX: Unknown document element: ${e.localName}.${a.localName}`);
                break;
            }
          }), t;
        }
        parseUnderline(e, t) {
          var r = P.attr(e, "val");
          if (r != null) {
            switch (r) {
              case "dash":
              case "dashDotDotHeavy":
              case "dashDotHeavy":
              case "dashedHeavy":
              case "dashLong":
              case "dashLongHeavy":
              case "dotDash":
              case "dotDotDash":
                t["text-decoration"] = "underline dashed";
                break;
              case "dotted":
              case "dottedHeavy":
                t["text-decoration"] = "underline dotted";
                break;
              case "double":
                t["text-decoration"] = "underline double";
                break;
              case "single":
              case "thick":
                t["text-decoration"] = "underline";
                break;
              case "wave":
              case "wavyDouble":
              case "wavyHeavy":
                t["text-decoration"] = "underline wavy";
                break;
              case "words":
                t["text-decoration"] = "underline";
                break;
              case "none":
                t["text-decoration"] = "none";
                break;
            }
            var n = ut.colorAttr(e, "color");
            n && (t["text-decoration-color"] = n);
          }
        }
        parseFont(e, t) {
          var r = P.attr(e, "ascii"), n = ct.themeValue(e, "asciiTheme"), a = [r, n].filter((l) => l).join(", ");
          a.length > 0 && (t["font-family"] = a);
        }
        parseIndentation(e, t) {
          var r = P.lengthAttr(e, "firstLine"), n = P.lengthAttr(e, "hanging"), a = P.lengthAttr(e, "left"), l = P.lengthAttr(e, "start"), o = P.lengthAttr(e, "right"), u = P.lengthAttr(e, "end");
          r && (t["text-indent"] = r), n && (t["text-indent"] = `-${n}`), (a || l) && (t["margin-left"] = a || l), (o || u) && (t["margin-right"] = o || u);
        }
        parseSpacing(e, t) {
          var r = P.lengthAttr(e, "before"), n = P.lengthAttr(e, "after"), a = P.intAttr(e, "line", null), l = P.attr(e, "lineRule");
          if (r && (t["margin-top"] = r), n && (t["margin-bottom"] = n), a !== null) switch (l) {
            case "auto":
              t["line-height"] = `${(a / 240).toFixed(2)}`;
              break;
            case "atLeast":
              t["line-height"] = `calc(100% + ${a / 20}pt)`;
              break;
            default:
              t["line-height"] = t["min-height"] = `${a / 20}pt`;
              break;
          }
        }
        parseMarginProperties(e, t) {
          ut.foreach(e, (r) => {
            switch (r.localName) {
              case "left":
                t["padding-left"] = ct.valueOfMargin(r);
                break;
              case "right":
                t["padding-right"] = ct.valueOfMargin(r);
                break;
              case "top":
                t["padding-top"] = ct.valueOfMargin(r);
                break;
              case "bottom":
                t["padding-bottom"] = ct.valueOfMargin(r);
                break;
            }
          });
        }
        parseTrHeight(e, t) {
          switch (P.attr(e, "hRule")) {
            case "exact":
              t.height = P.lengthAttr(e, "val");
              break;
            case "atLeast":
            default:
              t.height = P.lengthAttr(e, "val");
              break;
          }
        }
        parseBorderProperties(e, t) {
          ut.foreach(e, (r) => {
            switch (r.localName) {
              case "start":
              case "left":
                t["border-left"] = ct.valueOfBorder(r);
                break;
              case "end":
              case "right":
                t["border-right"] = ct.valueOfBorder(r);
                break;
              case "top":
                t["border-top"] = ct.valueOfBorder(r);
                break;
              case "bottom":
                t["border-bottom"] = ct.valueOfBorder(r);
                break;
            }
          });
        }
      }
      const Zr = ["black", "blue", "cyan", "darkBlue", "darkCyan", "darkGray", "darkGreen", "darkMagenta", "darkRed", "darkYellow", "green", "lightGray", "magenta", "none", "red", "white", "yellow"];
      class ut {
        static foreach(e, t) {
          for (var r = 0; r < e.childNodes.length; r++) {
            let n = e.childNodes[r];
            n.nodeType == Node.ELEMENT_NODE && t(n);
          }
        }
        static colorAttr(e, t, r = null, n = "black") {
          var a = P.attr(e, t);
          if (a) return a == "auto" ? n : Zr.includes(a) ? a : `#${a}`;
          var l = P.attr(e, "themeColor");
          return l ? `var(--docx-${l}-color)` : r;
        }
        static sizeValue(e, t = pt.Dxa) {
          return le(e.textContent, t);
        }
      }
      class ct {
        static themeValue(e, t) {
          var r = P.attr(e, t);
          return r ? `var(--docx-${r}-font)` : null;
        }
        static valueOfSize(e, t) {
          var r = pt.Dxa;
          switch (P.attr(e, "type")) {
            case "dxa":
              break;
            case "pct":
              r = pt.Percent;
              break;
            case "auto":
              return "auto";
          }
          return P.lengthAttr(e, t, r);
        }
        static valueOfMargin(e) {
          return P.lengthAttr(e, "w");
        }
        static valueOfBorder(e) {
          var t = P.attr(e, "val");
          if (t == "nil") return "none";
          var r = ut.colorAttr(e, "color"), n = P.lengthAttr(e, "sz", pt.Border);
          return `${n} solid ${r == "auto" ? Gt.borderColor : r}`;
        }
        static valueOfTblLayout(e) {
          var t = P.attr(e, "val");
          return t == "fixed" ? "fixed" : "auto";
        }
        static classNameOfCnfStyle(e) {
          const t = P.attr(e, "val");
          return ["first-row", "last-row", "first-col", "last-col", "odd-col", "even-col", "odd-row", "even-row", "ne-cell", "nw-cell", "se-cell", "sw-cell"].filter((n, a) => t[a] == "1").join(" ");
        }
        static valueOfJc(e) {
          var t = P.attr(e, "val");
          switch (t) {
            case "start":
            case "left":
              return "left";
            case "center":
              return "center";
            case "end":
            case "right":
              return "right";
            case "both":
              return "justify";
          }
          return t;
        }
        static valueOfVertAlign(e, t = false) {
          var r = P.attr(e, "val");
          switch (r) {
            case "subscript":
              return "sub";
            case "superscript":
              return t ? "sup" : "super";
          }
          return t ? null : r;
        }
        static valueOfTextAlignment(e) {
          var t = P.attr(e, "val");
          switch (t) {
            case "auto":
            case "baseline":
              return "baseline";
            case "top":
              return "top";
            case "center":
              return "middle";
            case "bottom":
              return "bottom";
          }
          return t;
        }
        static addSize(e, t) {
          return e == null ? t : t == null ? e : `calc(${e} + ${t})`;
        }
        static classNameOftblLook(e) {
          const t = P.hexAttr(e, "val", 0);
          let r = "";
          return (P.boolAttr(e, "firstRow") || t & 32) && (r += " first-row"), (P.boolAttr(e, "lastRow") || t & 64) && (r += " last-row"), (P.boolAttr(e, "firstColumn") || t & 128) && (r += " first-col"), (P.boolAttr(e, "lastColumn") || t & 256) && (r += " last-col"), (P.boolAttr(e, "noHBand") || t & 512) && (r += " no-hband"), (P.boolAttr(e, "noVBand") || t & 1024) && (r += " no-vband"), r.trim();
        }
      }
      const xe = { pos: 0, leader: "none", style: "left" }, Vr = 50;
      function Xr(i = document.body) {
        const e = document.createElement("div");
        e.style.width = "100pt", i.appendChild(e);
        const t = 100 / e.offsetWidth;
        return i.removeChild(e), t;
      }
      function Gr(i, e, t, r = 72 / 96) {
        const n = i.closest("p"), a = i.getBoundingClientRect(), l = n.getBoundingClientRect(), o = getComputedStyle(n), u = (e == null ? void 0 : e.length) > 0 ? e.map((v) => ({ pos: Pe(v.position), leader: v.leader, style: v.style })).sort((v, C) => v.pos - C.pos) : [xe], b = u[u.length - 1], y = l.width * r, _ = Pe(t);
        let w = b.pos + _;
        if (w < y) for (; w < y && u.length < Vr; w += _) u.push(Wt(_t({}, xe), { pos: w }));
        const d = parseFloat(o.marginLeft), k = l.left + d, h = (a.left - k) * r, m = u.find((v) => v.style != "clear" && v.pos > h);
        if (m == null) return;
        let f = 1;
        if (m.style == "right" || m.style == "center") {
          const v = Array.from(n.querySelectorAll(`.${i.className}`)), C = v.indexOf(i) + 1, A = document.createRange();
          A.setStart(i, 1), C < v.length ? A.setEndBefore(v[C]) : A.setEndAfter(n);
          const E = m.style == "center" ? 0.5 : 1, D = A.getBoundingClientRect(), I = D.left + E * D.width - (l.left - d);
          f = m.pos - I * r;
        } else f = m.pos - h;
        switch (i.innerHTML = "&nbsp;", i.style.textDecoration = "inherit", i.style.wordSpacing = `${f.toFixed(0)}pt`, m.leader) {
          case "dot":
          case "middleDot":
            i.style.textDecoration = "underline", i.style.textDecorationStyle = "dotted";
            break;
          case "hyphen":
          case "heavy":
          case "underscore":
            i.style.textDecoration = "underline";
            break;
        }
      }
      function Pe(i) {
        return parseFloat(i);
      }
      const nt = { svg: "http://www.w3.org/2000/svg", mathML: "http://www.w3.org/1998/Math/MathML" };
      class qr {
        constructor(e) {
          this.htmlDocument = e, this.className = "docx", this.styleMap = {}, this.currentPart = null, this.tableVerticalMerges = [], this.currentVerticalMerge = null, this.tableCellPositions = [], this.currentCellPosition = null, this.footnoteMap = {}, this.endnoteMap = {}, this.currentEndnoteIds = [], this.usedHederFooterParts = [], this.currentTabs = [], this.tabsTimeout = 0, this.commentMap = {}, this.tasks = [], this.postRenderTasks = [], this.createElement = Rt;
        }
        render(e, t, r = null, n) {
          var l;
          this.document = e, this.options = n, this.className = n.className, this.rootSelector = n.inWrapper ? `.${this.className}-wrapper` : ":root", this.styleMap = null, this.tasks = [], this.options.renderComments && globalThis.Highlight && (this.commentHighlight = new Highlight()), r = r || t, Ae(r), Ae(t), Lt(r, "docxjs library predefined styles"), r.appendChild(this.renderDefaultStyle()), e.themePart && (Lt(r, "docxjs document theme values"), this.renderTheme(e.themePart, r)), e.stylesPart != null && (this.styleMap = this.processStyles(e.stylesPart.styles), Lt(r, "docxjs document styles"), r.appendChild(this.renderStyles(e.stylesPart.styles))), e.numberingPart && (this.prodessNumberings(e.numberingPart.domNumberings), Lt(r, "docxjs document numbering styles"), r.appendChild(this.renderNumbering(e.numberingPart.domNumberings, r))), e.footnotesPart && (this.footnoteMap = Nt(e.footnotesPart.notes, (o) => o.id)), e.endnotesPart && (this.endnoteMap = Nt(e.endnotesPart.notes, (o) => o.id)), e.settingsPart && (this.defaultTabSize = (l = e.settingsPart.settings) == null ? void 0 : l.defaultTabStop), !n.ignoreFonts && e.fontTablePart && this.renderFontTable(e.fontTablePart, r);
          var a = this.renderSections(e.documentPart.body);
          this.options.inWrapper ? t.appendChild(this.renderWrapper(a)) : se(t, a), this.commentHighlight && n.renderComments && CSS.highlights.set(`${this.className}-comments`, this.commentHighlight), this.refreshTabStops(), this.postRenderTasks.forEach((o) => o());
        }
        renderTheme(e, t) {
          var o, u;
          const r = {}, n = (o = e.theme) == null ? void 0 : o.fontScheme;
          n && (n.majorFont && (r["--docx-majorHAnsi-font"] = n.majorFont.latinTypeface), n.minorFont && (r["--docx-minorHAnsi-font"] = n.minorFont.latinTypeface));
          const a = (u = e.theme) == null ? void 0 : u.colorScheme;
          if (a) for (let [b, y] of Object.entries(a.colors)) r[`--docx-${b}-color`] = `#${y}`;
          const l = this.styleToString(`.${this.className}`, r);
          t.appendChild(Mt(l));
        }
        renderFontTable(e, t) {
          for (let r of e.fonts) for (let n of r.embedFontRefs) this.tasks.push(this.document.loadFont(n.id, n.key).then((a) => {
            const l = { "font-family": r.name, src: `url(${a})` };
            (n.type == "bold" || n.type == "boldItalic") && (l["font-weight"] = "bold"), (n.type == "italic" || n.type == "boldItalic") && (l["font-style"] = "italic"), Lt(t, `docxjs ${r.name} font`);
            const o = this.styleToString("@font-face", l);
            t.appendChild(Mt(o)), this.refreshTabStops();
          }));
        }
        processStyleName(e) {
          return e ? `${this.className}_${He(e)}` : this.className;
        }
        processStyles(e) {
          const t = Nt(e.filter((n) => n.id != null), (n) => n.id);
          for (const n of e.filter((a) => a.basedOn)) {
            var r = t[n.basedOn];
            if (r) {
              n.paragraphProps = Vt(n.paragraphProps, r.paragraphProps), n.runProps = Vt(n.runProps, r.runProps);
              for (const a of r.styles) {
                const l = n.styles.find((o) => o.target == a.target);
                l ? this.copyStyleProperties(a.values, l.values) : n.styles.push(Wt(_t({}, a), { values: _t({}, a.values) }));
              }
            } else this.options.debug && console.warn(`Can't find base style ${n.basedOn}`);
          }
          for (let n of e) n.cssName = this.processStyleName(n.id);
          return t;
        }
        prodessNumberings(e) {
          var t;
          for (let r of e.filter((n) => n.pStyleName)) {
            const n = this.findStyle(r.pStyleName);
            (t = n == null ? void 0 : n.paragraphProps) != null && t.numbering && (n.paragraphProps.numbering.level = r.level);
          }
        }
        processElement(e) {
          if (e.children) for (var t of e.children) t.parent = e, t.type == z.Table ? this.processTable(t) : this.processElement(t);
        }
        processTable(e) {
          for (var t of e.children) for (var r of t.children) r.cssStyle = this.copyStyleProperties(e.cellStyle, r.cssStyle, ["border-left", "border-right", "border-top", "border-bottom", "padding-left", "padding-right", "padding-top", "padding-bottom"]), this.processElement(r);
        }
        copyStyleProperties(e, t, r = null) {
          if (!e) return t;
          t == null && (t = {}), r == null && (r = Object.getOwnPropertyNames(e));
          for (var n of r) e.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = e[n]);
          return t;
        }
        createPageElement(e, t) {
          var r = this.createElement("section", { className: e });
          return t && (t.pageMargins && (r.style.paddingLeft = t.pageMargins.left, r.style.paddingRight = t.pageMargins.right, r.style.paddingTop = t.pageMargins.top, r.style.paddingBottom = t.pageMargins.bottom), t.pageSize && (this.options.ignoreWidth || (r.style.width = t.pageSize.width), this.options.ignoreHeight || (r.style.minHeight = t.pageSize.height))), r;
        }
        createSectionContent(e) {
          var t = this.createElement("article");
          return e.columns && e.columns.numberOfColumns && (t.style.columnCount = `${e.columns.numberOfColumns}`, t.style.columnGap = e.columns.space, e.columns.separator && (t.style.columnRule = "1px solid black")), t;
        }
        renderSections(e) {
          const t = [];
          this.processElement(e);
          const r = this.splitBySection(e.children, e.props), n = this.groupByPageBreaks(r);
          let a = null;
          for (let o = 0, u = n.length; o < u; o++) {
            this.currentFootnoteIds = [];
            let y = n[o][0].sectProps;
            const _ = this.createPageElement(this.className, y);
            this.renderStyleValues(e.cssStyle, _), this.options.renderHeaders && this.renderHeaderFooter(y.headerRefs, y, t.length, a != y, _);
            for (const w of n[o]) {
              var l = this.createSectionContent(w.sectProps);
              this.renderElements(w.elements, l), _.appendChild(l), y = w.sectProps;
            }
            this.options.renderFootnotes && this.renderNotes(this.currentFootnoteIds, this.footnoteMap, _), this.options.renderEndnotes && o == u - 1 && this.renderNotes(this.currentEndnoteIds, this.endnoteMap, _), this.options.renderFooters && this.renderHeaderFooter(y.footerRefs, y, t.length, a != y, _), t.push(_), a = y;
          }
          return t;
        }
        renderHeaderFooter(e, t, r, n, a) {
          var u, b;
          if (e) {
            var l = (b = (u = t.titlePage && n ? e.find((y) => y.type == "first") : null) != null ? u : r % 2 == 1 ? e.find((y) => y.type == "even") : null) != null ? b : e.find((y) => y.type == "default"), o = l && this.document.findPartByRelId(l.id, this.document.documentPart);
            if (o) {
              this.currentPart = o, this.usedHederFooterParts.includes(o.path) || (this.processElement(o.rootElement), this.usedHederFooterParts.push(o.path));
              const [y] = this.renderElements([o.rootElement], a);
              t != null && t.pageMargins && (o.rootElement.type === z.Header ? (y.style.marginTop = `calc(${t.pageMargins.header} - ${t.pageMargins.top})`, y.style.minHeight = `calc(${t.pageMargins.top} - ${t.pageMargins.header})`) : o.rootElement.type === z.Footer && (y.style.marginBottom = `calc(${t.pageMargins.footer} - ${t.pageMargins.bottom})`, y.style.minHeight = `calc(${t.pageMargins.bottom} - ${t.pageMargins.footer})`)), this.currentPart = null;
            }
          }
        }
        isPageBreakElement(e) {
          return e.type != z.Break ? false : e.break == "lastRenderedPageBreak" ? !this.options.ignoreLastRenderedPageBreak : e.break == "page";
        }
        isPageBreakSection(e, t) {
          var r, n, a, l, o, u;
          return !e || !t ? false : ((r = e.pageSize) == null ? void 0 : r.orientation) != ((n = t.pageSize) == null ? void 0 : n.orientation) || ((a = e.pageSize) == null ? void 0 : a.width) != ((l = t.pageSize) == null ? void 0 : l.width) || ((o = e.pageSize) == null ? void 0 : o.height) != ((u = t.pageSize) == null ? void 0 : u.height);
        }
        splitBySection(e, t) {
          var _;
          var r = { sectProps: null, elements: [], pageBreak: false }, n = [r];
          for (let w of e) {
            if (w.type == z.Paragraph) {
              const d = this.findStyle(w.styleName);
              (_ = d == null ? void 0 : d.paragraphProps) != null && _.pageBreakBefore && (r.sectProps = a, r.pageBreak = true, r = { sectProps: null, elements: [], pageBreak: false }, n.push(r));
            }
            if (r.elements.push(w), w.type == z.Paragraph) {
              const d = w;
              var a = d.sectionProps, l = -1, o = -1;
              if (this.options.breakPages && d.children && (l = d.children.findIndex((k) => {
                var h, m;
                return o = (m = (h = k.children) == null ? void 0 : h.findIndex(this.isPageBreakElement.bind(this))) != null ? m : -1, o != -1;
              })), (a || l != -1) && (r.sectProps = a, r.pageBreak = l != -1, r = { sectProps: null, elements: [], pageBreak: false }, n.push(r)), l != -1) {
                let k = d.children[l], h = o < k.children.length - 1;
                if (l < d.children.length - 1 || h) {
                  var u = w.children, b = Wt(_t({}, w), { children: u.slice(l) });
                  if (w.children = u.slice(0, l), r.elements.push(b), h) {
                    let m = k.children, f = Wt(_t({}, k), { children: m.slice(0, o) });
                    w.children.push(f), k.children = m.slice(o);
                  }
                }
              }
            }
          }
          let y = null;
          for (let w = n.length - 1; w >= 0; w--) n[w].sectProps == null ? n[w].sectProps = y != null ? y : t : y = n[w].sectProps;
          return n;
        }
        groupByPageBreaks(e) {
          let t = [], r;
          const n = [t];
          for (let a of e) t.push(a), (this.options.ignoreLastRenderedPageBreak || a.pageBreak || this.isPageBreakSection(r, a.sectProps)) && n.push(t = []), r = a.sectProps;
          return n.filter((a) => a.length > 0);
        }
        renderWrapper(e) {
          return this.createElement("div", { className: `${this.className}-wrapper` }, e);
        }
        renderDefaultStyle() {
          var e = this.className, t = `
.${e}-wrapper { background: gray; padding: 30px; padding-bottom: 0px; display: flex; flex-flow: column; align-items: center; } 
.${e}-wrapper>section.${e} { background: white; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5); margin-bottom: 30px; }
.${e} { color: black; hyphens: auto; text-underline-position: from-font; }
section.${e} { box-sizing: border-box; display: flex; flex-flow: column nowrap; position: relative; overflow: hidden; }
section.${e}>article { margin-bottom: auto; z-index: 1; }
section.${e}>footer { z-index: 1; }
.${e} table { border-collapse: collapse; }
.${e} table td, .${e} table th { vertical-align: top; }
.${e} p { margin: 0pt; min-height: 1em; }
.${e} span { white-space: pre-wrap; overflow-wrap: break-word; }
.${e} a { color: inherit; text-decoration: inherit; }
.${e} svg { fill: transparent; }
`;
          return this.options.renderComments && (t += `
.${e}-comment-ref { cursor: default; }
.${e}-comment-popover { display: none; z-index: 1000; padding: 0.5rem; background: white; position: absolute; box-shadow: 0 0 0.25rem rgba(0, 0, 0, 0.25); width: 30ch; }
.${e}-comment-ref:hover~.${e}-comment-popover { display: block; }
.${e}-comment-author,.${e}-comment-date { font-size: 0.875rem; color: #888; }
`), Mt(t);
        }
        renderNumbering(e, t) {
          var r = "", n = [];
          for (var a of e) {
            var l = `p.${this.numberingClass(a.id, a.level)}`, o = "none";
            if (a.bullet) {
              let u = `--${this.className}-${a.bullet.src}`.toLowerCase();
              r += this.styleToString(`${l}:before`, { content: "' '", display: "inline-block", background: `var(${u})` }, a.bullet.style), this.tasks.push(this.document.loadNumberingImage(a.bullet.src).then((b) => {
                var y = `${this.rootSelector} { ${u}: url(${b}) }`;
                t.appendChild(Mt(y));
              }));
            } else if (a.levelText) {
              let u = this.numberingCounter(a.id, a.level);
              const b = u + " " + (a.start - 1);
              a.level > 0 && (r += this.styleToString(`p.${this.numberingClass(a.id, a.level - 1)}`, { "counter-reset": b })), n.push(b), r += this.styleToString(`${l}:before`, _t({ content: this.levelTextToContent(a.levelText, a.suff, a.id, this.numFormatToCssValue(a.format)), "counter-increment": u }, a.rStyle));
            } else o = this.numFormatToCssValue(a.format);
            r += this.styleToString(l, _t({ display: "list-item", "list-style-position": "inside", "list-style-type": o }, a.pStyle));
          }
          return n.length > 0 && (r += this.styleToString(this.rootSelector, { "counter-reset": n.join(" ") })), Mt(r);
        }
        renderStyles(e) {
          var u;
          var t = "";
          const r = this.styleMap, n = Nt(e.filter((b) => b.isDefault), (b) => b.target);
          for (const b of e) {
            var a = b.styles;
            if (b.linked) {
              var l = b.linked && r[b.linked];
              l ? a = a.concat(l.styles) : this.options.debug && console.warn(`Can't find linked style ${b.linked}`);
            }
            for (const y of a) {
              var o = `${(u = b.target) != null ? u : ""}.${b.cssName}`;
              b.target != y.target && (o += ` ${y.target}`), n[b.target] == b && (o = `.${this.className} ${b.target}, ` + o), t += this.styleToString(o, y.values);
            }
          }
          return Mt(t);
        }
        renderNotes(e, t, r) {
          var n = e.map((l) => t[l]).filter((l) => l);
          if (n.length > 0) {
            var a = this.createElement("ol", null, this.renderElements(n));
            r.appendChild(a);
          }
        }
        renderElement(e) {
          switch (e.type) {
            case z.Paragraph:
              return this.renderParagraph(e);
            case z.BookmarkStart:
              return this.renderBookmarkStart(e);
            case z.BookmarkEnd:
              return null;
            case z.Run:
              return this.renderRun(e);
            case z.Table:
              return this.renderTable(e);
            case z.Row:
              return this.renderTableRow(e);
            case z.Cell:
              return this.renderTableCell(e);
            case z.Hyperlink:
              return this.renderHyperlink(e);
            case z.SmartTag:
              return this.renderSmartTag(e);
            case z.Drawing:
              return this.renderDrawing(e);
            case z.Image:
              return this.renderImage(e);
            case z.Text:
              return this.renderText(e);
            case z.Text:
              return this.renderText(e);
            case z.DeletedText:
              return this.renderDeletedText(e);
            case z.Tab:
              return this.renderTab(e);
            case z.Symbol:
              return this.renderSymbol(e);
            case z.Break:
              return this.renderBreak(e);
            case z.Footer:
              return this.renderContainer(e, "footer");
            case z.Header:
              return this.renderContainer(e, "header");
            case z.Footnote:
            case z.Endnote:
              return this.renderContainer(e, "li");
            case z.FootnoteReference:
              return this.renderFootnoteReference(e);
            case z.EndnoteReference:
              return this.renderEndnoteReference(e);
            case z.NoBreakHyphen:
              return this.createElement("wbr");
            case z.VmlPicture:
              return this.renderVmlPicture(e);
            case z.VmlElement:
              return this.renderVmlElement(e);
            case z.MmlMath:
              return this.renderContainerNS(e, nt.mathML, "math", { xmlns: nt.mathML });
            case z.MmlMathParagraph:
              return this.renderContainer(e, "span");
            case z.MmlFraction:
              return this.renderContainerNS(e, nt.mathML, "mfrac");
            case z.MmlBase:
              return this.renderContainerNS(e, nt.mathML, e.parent.type == z.MmlMatrixRow ? "mtd" : "mrow");
            case z.MmlNumerator:
            case z.MmlDenominator:
            case z.MmlFunction:
            case z.MmlLimit:
            case z.MmlBox:
              return this.renderContainerNS(e, nt.mathML, "mrow");
            case z.MmlGroupChar:
              return this.renderMmlGroupChar(e);
            case z.MmlLimitLower:
              return this.renderContainerNS(e, nt.mathML, "munder");
            case z.MmlMatrix:
              return this.renderContainerNS(e, nt.mathML, "mtable");
            case z.MmlMatrixRow:
              return this.renderContainerNS(e, nt.mathML, "mtr");
            case z.MmlRadical:
              return this.renderMmlRadical(e);
            case z.MmlSuperscript:
              return this.renderContainerNS(e, nt.mathML, "msup");
            case z.MmlSubscript:
              return this.renderContainerNS(e, nt.mathML, "msub");
            case z.MmlDegree:
            case z.MmlSuperArgument:
            case z.MmlSubArgument:
              return this.renderContainerNS(e, nt.mathML, "mn");
            case z.MmlFunctionName:
              return this.renderContainerNS(e, nt.mathML, "ms");
            case z.MmlDelimiter:
              return this.renderMmlDelimiter(e);
            case z.MmlRun:
              return this.renderMmlRun(e);
            case z.MmlNary:
              return this.renderMmlNary(e);
            case z.MmlPreSubSuper:
              return this.renderMmlPreSubSuper(e);
            case z.MmlBar:
              return this.renderMmlBar(e);
            case z.MmlEquationArray:
              return this.renderMllList(e);
            case z.Inserted:
              return this.renderInserted(e);
            case z.Deleted:
              return this.renderDeleted(e);
            case z.CommentRangeStart:
              return this.renderCommentRangeStart(e);
            case z.CommentRangeEnd:
              return this.renderCommentRangeEnd(e);
            case z.CommentReference:
              return this.renderCommentReference(e);
          }
          return null;
        }
        renderChildren(e, t) {
          return this.renderElements(e.children, t);
        }
        renderElements(e, t) {
          if (e == null) return null;
          var r = e.flatMap((n) => this.renderElement(n)).filter((n) => n != null);
          return t && se(t, r), r;
        }
        renderContainer(e, t, r) {
          return this.createElement(t, r, this.renderChildren(e));
        }
        renderContainerNS(e, t, r, n) {
          return ht(t, r, n, this.renderChildren(e));
        }
        renderParagraph(e) {
          var a, l, o, u;
          var t = this.createElement("p");
          const r = this.findStyle(e.styleName);
          (l = e.tabs) != null || (e.tabs = (a = r == null ? void 0 : r.paragraphProps) == null ? void 0 : a.tabs), this.renderClass(e, t), this.renderChildren(e, t), this.renderStyleValues(e.cssStyle, t), this.renderCommonProperties(t.style, e);
          const n = (u = e.numbering) != null ? u : (o = r == null ? void 0 : r.paragraphProps) == null ? void 0 : o.numbering;
          return n && t.classList.add(this.numberingClass(n.id, n.level)), t;
        }
        renderRunProperties(e, t) {
          this.renderCommonProperties(e, t);
        }
        renderCommonProperties(e, t) {
          t != null && (t.color && (e.color = t.color), t.fontSize && (e["font-size"] = t.fontSize));
        }
        renderHyperlink(e) {
          var t = this.createElement("a");
          if (this.renderChildren(e, t), this.renderStyleValues(e.cssStyle, t), e.href) t.href = e.href;
          else if (e.id) {
            const r = this.document.documentPart.rels.find((n) => n.id == e.id && n.targetMode === "External");
            t.href = r == null ? void 0 : r.target;
          }
          return t;
        }
        renderSmartTag(e) {
          var t = this.createElement("span");
          return this.renderChildren(e, t), t;
        }
        renderCommentRangeStart(e) {
          var n;
          if (!this.options.renderComments) return null;
          const t = new Range();
          (n = this.commentHighlight) == null || n.add(t);
          const r = this.htmlDocument.createComment(`start of comment #${e.id}`);
          return this.later(() => t.setStart(r, 0)), this.commentMap[e.id] = t, r;
        }
        renderCommentRangeEnd(e) {
          if (!this.options.renderComments) return null;
          const t = this.commentMap[e.id], r = this.htmlDocument.createComment(`end of comment #${e.id}`);
          return this.later(() => t == null ? void 0 : t.setEnd(r, 0)), r;
        }
        renderCommentReference(e) {
          var l;
          if (!this.options.renderComments) return null;
          var t = (l = this.document.commentsPart) == null ? void 0 : l.commentMap[e.id];
          if (!t) return null;
          const r = new DocumentFragment(), n = Rt("span", { className: `${this.className}-comment-ref` }, ["💬"]), a = Rt("div", { className: `${this.className}-comment-popover` });
          return this.renderCommentContent(t, a), r.appendChild(this.htmlDocument.createComment(`comment #${t.id} by ${t.author} on ${t.date}`)), r.appendChild(n), r.appendChild(a), r;
        }
        renderCommentContent(e, t) {
          t.appendChild(Rt("div", { className: `${this.className}-comment-author` }, [e.author])), t.appendChild(Rt("div", { className: `${this.className}-comment-date` }, [new Date(e.date).toLocaleString()])), this.renderChildren(e, t);
        }
        renderDrawing(e) {
          var t = this.createElement("div");
          return t.style.display = "inline-block", t.style.position = "relative", t.style.textIndent = "0px", this.renderChildren(e, t), this.renderStyleValues(e.cssStyle, t), t;
        }
        renderImage(e) {
          let t = this.createElement("img");
          return this.renderStyleValues(e.cssStyle, t), this.document && this.tasks.push(this.document.loadDocumentImage(e.src, this.currentPart).then((r) => {
            t.src = r;
          })), t;
        }
        renderText(e) {
          return this.htmlDocument.createTextNode(e.text);
        }
        renderDeletedText(e) {
          return this.options.renderEndnotes ? this.htmlDocument.createTextNode(e.text) : null;
        }
        renderBreak(e) {
          return e.break == "textWrapping" ? this.createElement("br") : null;
        }
        renderInserted(e) {
          return this.options.renderChanges ? this.renderContainer(e, "ins") : this.renderChildren(e);
        }
        renderDeleted(e) {
          return this.options.renderChanges ? this.renderContainer(e, "del") : null;
        }
        renderSymbol(e) {
          var t = this.createElement("span");
          return t.style.fontFamily = e.font, t.innerHTML = `&#x${e.char};`, t;
        }
        renderFootnoteReference(e) {
          var t = this.createElement("sup");
          return this.currentFootnoteIds.push(e.id), t.textContent = `${this.currentFootnoteIds.length}`, t;
        }
        renderEndnoteReference(e) {
          var t = this.createElement("sup");
          return this.currentEndnoteIds.push(e.id), t.textContent = `${this.currentEndnoteIds.length}`, t;
        }
        renderTab(e) {
          var n;
          var t = this.createElement("span");
          if (t.innerHTML = "&emsp;", this.options.experimental) {
            t.className = this.tabStopClass();
            var r = (n = Kr(e, z.Paragraph)) == null ? void 0 : n.tabs;
            this.currentTabs.push({ stops: r, span: t });
          }
          return t;
        }
        renderBookmarkStart(e) {
          var t = this.createElement("span");
          return t.id = e.name, t;
        }
        renderRun(e) {
          if (e.fieldRun) return null;
          const t = this.createElement("span");
          if (e.id && (t.id = e.id), this.renderClass(e, t), this.renderStyleValues(e.cssStyle, t), e.verticalAlign) {
            const r = this.createElement(e.verticalAlign);
            this.renderChildren(e, r), t.appendChild(r);
          } else this.renderChildren(e, t);
          return t;
        }
        renderTable(e) {
          let t = this.createElement("table");
          return this.tableCellPositions.push(this.currentCellPosition), this.tableVerticalMerges.push(this.currentVerticalMerge), this.currentVerticalMerge = {}, this.currentCellPosition = { col: 0, row: 0 }, e.columns && t.appendChild(this.renderTableColumns(e.columns)), this.renderClass(e, t), this.renderChildren(e, t), this.renderStyleValues(e.cssStyle, t), this.currentVerticalMerge = this.tableVerticalMerges.pop(), this.currentCellPosition = this.tableCellPositions.pop(), t;
        }
        renderTableColumns(e) {
          let t = this.createElement("colgroup");
          for (let r of e) {
            let n = this.createElement("col");
            r.width && (n.style.width = r.width), t.appendChild(n);
          }
          return t;
        }
        renderTableRow(e) {
          let t = this.createElement("tr");
          return this.currentCellPosition.col = 0, this.renderClass(e, t), this.renderChildren(e, t), this.renderStyleValues(e.cssStyle, t), this.currentCellPosition.row++, t;
        }
        renderTableCell(e) {
          let t = this.createElement("td");
          const r = this.currentCellPosition.col;
          return e.verticalMerge ? e.verticalMerge == "restart" ? (this.currentVerticalMerge[r] = t, t.rowSpan = 1) : this.currentVerticalMerge[r] && (this.currentVerticalMerge[r].rowSpan += 1, t.style.display = "none") : this.currentVerticalMerge[r] = null, this.renderClass(e, t), this.renderChildren(e, t), this.renderStyleValues(e.cssStyle, t), e.span && (t.colSpan = e.span), this.currentCellPosition.col += t.colSpan, t;
        }
        renderVmlPicture(e) {
          var t = Rt("div");
          return this.renderChildren(e, t), t;
        }
        renderVmlElement(e) {
          var n, a;
          var t = Ee("svg");
          t.setAttribute("style", e.cssStyleText);
          const r = this.renderVmlChildElement(e);
          return (n = e.imageHref) != null && n.id && this.tasks.push((a = this.document) == null ? void 0 : a.loadDocumentImage(e.imageHref.id, this.currentPart).then((l) => r.setAttribute("href", l))), t.appendChild(r), requestAnimationFrame(() => {
            const l = t.firstElementChild.getBBox();
            t.setAttribute("width", `${Math.ceil(l.x + l.width)}`), t.setAttribute("height", `${Math.ceil(l.y + l.height)}`);
          }), t;
        }
        renderVmlChildElement(e) {
          const t = Ee(e.tagName);
          Object.entries(e.attrs).forEach(([r, n]) => t.setAttribute(r, n));
          for (let r of e.children) r.type == z.VmlElement ? t.appendChild(this.renderVmlChildElement(r)) : t.appendChild(...Ft(this.renderElement(r)));
          return t;
        }
        renderMmlRadical(e) {
          var n;
          const t = e.children.find((a) => a.type == z.MmlBase);
          if ((n = e.props) != null && n.hideDegree) return ht(nt.mathML, "msqrt", null, this.renderElements([t]));
          const r = e.children.find((a) => a.type == z.MmlDegree);
          return ht(nt.mathML, "mroot", null, this.renderElements([t, r]));
        }
        renderMmlDelimiter(e) {
          var r, n;
          const t = [];
          return t.push(ht(nt.mathML, "mo", null, [(r = e.props.beginChar) != null ? r : "("])), t.push(...this.renderElements(e.children)), t.push(ht(nt.mathML, "mo", null, [(n = e.props.endChar) != null ? n : ")"])), ht(nt.mathML, "mrow", null, t);
        }
        renderMmlNary(e) {
          var b, y;
          const t = [], r = Nt(e.children, (_) => _.type), n = r[z.MmlSuperArgument], a = r[z.MmlSubArgument], l = n ? ht(nt.mathML, "mo", null, Ft(this.renderElement(n))) : null, o = a ? ht(nt.mathML, "mo", null, Ft(this.renderElement(a))) : null, u = ht(nt.mathML, "mo", null, [(y = (b = e.props) == null ? void 0 : b.char) != null ? y : "∫"]);
          return l || o ? t.push(ht(nt.mathML, "munderover", null, [u, o, l])) : l ? t.push(ht(nt.mathML, "mover", null, [u, l])) : o ? t.push(ht(nt.mathML, "munder", null, [u, o])) : t.push(u), t.push(...this.renderElements(r[z.MmlBase].children)), ht(nt.mathML, "mrow", null, t);
        }
        renderMmlPreSubSuper(e) {
          const t = [], r = Nt(e.children, (b) => b.type), n = r[z.MmlSuperArgument], a = r[z.MmlSubArgument], l = n ? ht(nt.mathML, "mo", null, Ft(this.renderElement(n))) : null, o = a ? ht(nt.mathML, "mo", null, Ft(this.renderElement(a))) : null, u = ht(nt.mathML, "mo", null);
          return t.push(ht(nt.mathML, "msubsup", null, [u, o, l])), t.push(...this.renderElements(r[z.MmlBase].children)), ht(nt.mathML, "mrow", null, t);
        }
        renderMmlGroupChar(e) {
          const t = e.props.verticalJustification === "bot" ? "mover" : "munder", r = this.renderContainerNS(e, nt.mathML, t);
          return e.props.char && r.appendChild(ht(nt.mathML, "mo", null, [e.props.char])), r;
        }
        renderMmlBar(e) {
          const t = this.renderContainerNS(e, nt.mathML, "mrow");
          switch (e.props.position) {
            case "top":
              t.style.textDecoration = "overline";
              break;
            case "bottom":
              t.style.textDecoration = "underline";
              break;
          }
          return t;
        }
        renderMmlRun(e) {
          const t = ht(nt.mathML, "ms");
          return this.renderClass(e, t), this.renderStyleValues(e.cssStyle, t), this.renderChildren(e, t), t;
        }
        renderMllList(e) {
          const t = ht(nt.mathML, "mtable");
          this.renderClass(e, t), this.renderStyleValues(e.cssStyle, t), this.renderChildren(e);
          for (let r of this.renderChildren(e)) t.appendChild(ht(nt.mathML, "mtr", null, [ht(nt.mathML, "mtd", null, [r])]));
          return t;
        }
        renderStyleValues(e, t) {
          for (let r in e) r.startsWith("$") ? t.setAttribute(r.slice(1), e[r]) : t.style[r] = e[r];
        }
        renderClass(e, t) {
          e.className && (t.className = e.className), e.styleName && t.classList.add(this.processStyleName(e.styleName));
        }
        findStyle(e) {
          var t;
          return e && ((t = this.styleMap) == null ? void 0 : t[e]);
        }
        numberingClass(e, t) {
          return `${this.className}-num-${e}-${t}`;
        }
        tabStopClass() {
          return `${this.className}-tab-stop`;
        }
        styleToString(e, t, r = null) {
          let n = `${e} {\r
`;
          for (const a in t) a.startsWith("$") || (n += `  ${a}: ${t[a]};\r
`);
          return r && (n += r), n + `}\r
`;
        }
        numberingCounter(e, t) {
          return `${this.className}-num-${e}-${t}`;
        }
        levelTextToContent(e, t, r, n) {
          var o;
          const a = { tab: "\\9", space: "\\a0" };
          var l = e.replace(/%\d*/g, (u) => {
            let b = parseInt(u.substring(1), 10) - 1;
            return `"counter(${this.numberingCounter(r, b)}, ${n})"`;
          });
          return `"${l}${(o = a[t]) != null ? o : ""}"`;
        }
        numFormatToCssValue(e) {
          var r;
          var t = { none: "none", bullet: "disc", decimal: "decimal", lowerLetter: "lower-alpha", upperLetter: "upper-alpha", lowerRoman: "lower-roman", upperRoman: "upper-roman", decimalZero: "decimal-leading-zero", aiueo: "katakana", aiueoFullWidth: "katakana", chineseCounting: "simp-chinese-informal", chineseCountingThousand: "simp-chinese-informal", chineseLegalSimplified: "simp-chinese-formal", chosung: "hangul-consonant", ideographDigital: "cjk-ideographic", ideographTraditional: "cjk-heavenly-stem", ideographLegalTraditional: "trad-chinese-formal", ideographZodiac: "cjk-earthly-branch", iroha: "katakana-iroha", irohaFullWidth: "katakana-iroha", japaneseCounting: "japanese-informal", japaneseDigitalTenThousand: "cjk-decimal", japaneseLegal: "japanese-formal", thaiNumbers: "thai", koreanCounting: "korean-hangul-formal", koreanDigital: "korean-hangul-formal", koreanDigital2: "korean-hanja-informal", hebrew1: "hebrew", hebrew2: "hebrew", hindiNumbers: "devanagari", ganada: "hangul", taiwaneseCounting: "cjk-ideographic", taiwaneseCountingThousand: "cjk-ideographic", taiwaneseDigital: "cjk-decimal" };
          return (r = t[e]) != null ? r : e;
        }
        refreshTabStops() {
          this.options.experimental && (clearTimeout(this.tabsTimeout), this.tabsTimeout = setTimeout(() => {
            const e = Xr();
            for (let t of this.currentTabs) Gr(t.span, t.stops, this.defaultTabSize, e);
          }, 500));
        }
        later(e) {
          this.postRenderTasks.push(e);
        }
      }
      function Rt(i, e, t) {
        return ht(void 0, i, e, t);
      }
      function Ee(i, e, t) {
        return ht(nt.svg, i, e, t);
      }
      function ht(i, e, t, r) {
        var n = i ? document.createElementNS(i, e) : document.createElement(e);
        return Object.assign(n, t), r && se(n, r), n;
      }
      function Ae(i) {
        i.innerHTML = "";
      }
      function se(i, e) {
        e.forEach((t) => i.appendChild(Ve(t) ? document.createTextNode(t) : t));
      }
      function Mt(i) {
        return Rt("style", { innerHTML: i });
      }
      function Lt(i, e) {
        i.appendChild(document.createComment(e));
      }
      function Kr(i, e) {
        for (var t = i.parent; t != null && t.type != e; ) t = t.parent;
        return t;
      }
      const Ne = { ignoreHeight: false, ignoreWidth: false, ignoreFonts: false, breakPages: true, debug: false, experimental: false, className: "docx", inWrapper: true, trimXmlDeclaration: true, ignoreLastRenderedPageBreak: true, renderHeaders: true, renderFooters: true, renderFootnotes: true, renderEndnotes: true, useBase64URL: false, renderChanges: false, renderComments: false };
      function Yr(i, e) {
        const t = _t(_t({}, Ne), e);
        return ae.load(i, new Hr(t), t);
      }
      function Jr(i, e, t, r) {
        return wt(this, null, function* () {
          const n = _t(_t({}, Ne), r), a = new qr(window.document);
          return a.render(i, e, t, n), Promise.allSettled(a.tasks);
        });
      }
      function Qr(i, e, t, r) {
        return wt(this, null, function* () {
          const n = yield Yr(i, r);
          return yield Jr(n, e, t, r), n;
        });
      }
      const tn = { ignoreLastRenderedPageBreak: false };
      function en(i, e = {}) {
        return typeof i == "string" ? rn(i, e) : Promise.resolve(i);
      }
      function rn(i, e) {
        return fetch(i, e).then((t) => t.status !== 200 ? Promise.reject(t) : t);
      }
      function nn(i) {
        return wt(this, null, function* () {
          let e;
          return i instanceof Blob ? e = i : i instanceof Response ? e = yield i.blob() : i instanceof ArrayBuffer && (e = new Blob([i])), e;
        });
      }
      function an(i, e, t = {}) {
        if (!i) return e.innerHTML = "", Promise.resolve();
        let r;
        return i instanceof Blob ? r = i : i instanceof Response ? r = i.blob() : i instanceof ArrayBuffer && (r = new Blob([i])), Qr(r, e, e, _t(_t({}, tn), t));
      }
      const Tt = { getData: en, render: an, getBlob: nn };
      function sn(i, e) {
        return wt(this, null, function* () {
          e && (e instanceof ArrayBuffer && (e = new Blob([e])), on(i, URL.createObjectURL(e)));
        });
      }
      function on(i, e) {
        let t = document.createElement("a");
        t.download = i, t.style.display = "none", t.href = e, document.body.appendChild(t), t.click(), document.body.removeChild(t);
      }
      const _n = "", ln = (i, e) => {
        const t = i.__vccOpts || i;
        for (const [r, n] of e) t[r] = n;
        return t;
      }, cn = dt.defineComponent({ name: "VueOfficeDocx", props: { src: [String, ArrayBuffer, Blob], requestOptions: { type: Object, default: () => ({}) }, options: { type: Object, default: () => ({}) } }, emits: ["rendered", "error"], setup(i, { emit: e }) {
        const t = dt.ref(null);
        let r = null;
        function n() {
          let l = t.value;
          Tt.getData(i.src, i.requestOptions).then((o) => wt(this, null, function* () {
            r = yield Tt.getBlob(o), Tt.render(r, l, i.options).then(() => {
              e("rendered");
            }).catch((u) => {
              Tt.render("", l, i.options), e("error", u);
            });
          })).catch((o) => {
            Tt.render("", l, i.options), e("error", o);
          });
        }
        dt.onMounted(() => {
          i.src && n();
        }), dt.watch(() => i.src, () => {
          i.src ? n() : Tt.render("", t.value, i.options).then(() => {
            e("rendered");
          });
        });
        function a(l) {
          sn(l || `vue-office-docx-${(/* @__PURE__ */ new Date()).getTime()}.docx`, r);
        }
        return { rootRef: t, save: a };
      } }), hn = { class: "vue-office-docx" }, un = { class: "vue-office-docx-main", ref: "rootRef" };
      function dn(i, e, t, r, n, a) {
        return ft.openBlock(), ft.createElementBlock("div", hn, [ft.createElementVNode("div", un, null, 512)]);
      }
      const qt = ln(cn, [["render", dn]]);
      return qt.install = function(i) {
        i.component(qt.name, qt);
      }, qt;
    });
  }
});
export default require_lib2();
/*! Bundled license information:

@vue/compiler-core/dist/compiler-core.esm-bundler.js:
  (**
  * @vue/compiler-core v3.5.14
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/compiler-dom/dist/compiler-dom.esm-bundler.js:
  (**
  * @vue/compiler-dom v3.5.14
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

vue/dist/vue.cjs.js:
  (**
  * vue v3.5.14
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue-office/docx/lib/index.js:
  (*!
  
      JSZip v3.10.1 - A JavaScript class for generating and reading zip files
      <http://stuartk.com/jszip>
  
      (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
      Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
      JSZip uses the library pako released under the MIT license :
      https://github.com/nodeca/pako/blob/main/LICENSE
      *)
*/
//# sourceMappingURL=@vue-office_docx.js.map
